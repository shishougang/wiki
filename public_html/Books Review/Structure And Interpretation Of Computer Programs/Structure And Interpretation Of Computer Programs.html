<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Structure And Interpretation Of Computer Programs Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Structure And Interpretation Of Computer Programs Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-04-14T18:55+0800"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./assets/stylesheet.css" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Structure And Interpretation Of Computer Programs Notes</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Sites</a></li>
<li><a href="#sec-2">Solutions</a></li>
<li><a href="#sec-3">Foreword</a></li>
<li><a href="#sec-4">Preface to the First Edition</a></li>
<li><a href="#sec-5">Chapter 1 Building Abstractions with Procedures</a>
<ul>
<li><a href="#sec-5-1">1.1 The Elements of Programming</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Sites</h2>
<div class="outline-text-2" id="text-1">

<p><a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Solutions</h2>
<div class="outline-text-2" id="text-2">

<p><a href="http://community.schemewiki.org/?SICP-Solutions">http://community.schemewiki.org/?SICP-Solutions</a>
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Foreword</h2>
<div class="outline-text-2" id="text-3">

<p>Our traffic with the subject matter of this book involves us with
three foci of phenomena: the human mind, collections of computer
programs, and the computer.
</p>
<p>
We call such programs algorithms, and a great deal is known of their optimal behavior, particularly
with respect to the two important parameters of execution time and data storage requirements. A
programmer should acquire good algorithms and idioms. Even though some programs resist precise
specifications, it is the responsibility of the programmer to estimate, and always to attempt to improve,
their performance.
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Preface to the First Edition</h2>
<div class="outline-text-2" id="text-4">

<p>Our design of this introductory computer-science subject reflects two major concerns. First, we want to
establish the idea that a computer language is not just a way of getting a computer to perform operations
but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must
be written for people to read, and only incidentally for machines to execute. Second, we believe that the
essential material to be addressed by a subject at this level is not the syntax of particular programming-
language constructs, nor clever algorithms for computing particular functions efficiently, nor even the
mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to
control the intellectual complexity of large software systems.
</p>
<p>
Our goal is that students who complete this subject should have a good feel for the elements of style and
the aesthetics of programming. They should have command of the major techniques for controlling
complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in
an exemplary style. They should know what not to read, and what they need not understand at any
moment. They should feel secure about modifying a program, retaining the spirit and style of the original
author.
</p>
<p>
These skills are by no means unique to computer programming. The techniques we teach and draw upon
are common to all of engineering design. We control complexity by building abstractions that hide details
when appropriate. We control complexity by establishing conventional interfaces that enable us to
construct systems by combining standard, well-understood pieces in a ``mix and match'' way. We control
complexity by establishing new languages for describing a design, each of which emphasizes particular
aspects of the design and deemphasizes others.
</p>
<p>
Underlying our approach to this subject is our conviction that ``computer science'' is not a science and that
its significance has little to do with computers. The computer revolution is a revolution in the way we
think and in the way we express what we think. The essence of this change is the emergence of what might
best be called procedural epistemology &ndash; the study of the structure of knowledge from an imperative point
of view, as opposed to the more declarative point of view taken by classical mathematical subjects.
Mathematics provides a framework for dealing precisely with notions of ``what is.'' Computation provides
a framework for dealing precisely with notions of ``how to.''
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">Chapter 1 Building Abstractions with Procedures</h2>
<div class="outline-text-2" id="text-5">


<p class="verse">
The acts of the mind, wherein it exerts its power over simple ideas, are chiefly<br/>
these three: 1. Combining several simple ideas into one compound one, and thus all<br/>
complex ideas are made. 2. The second is bringing two ideas, whether simple or<br/>
complex, together, and setting them by one another so as to take a view of them at<br/>
once, without uniting them into one, by which it gets all its ideas of relations. 3.<br/>
The third is separating them from all other ideas that accompany them in their real<br/>
existence: this is called abstraction, and thus all its general ideas are made.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; John Locke, An Essay Concerning Human Understanding (1690)<br/>
</p>


<p>
 Lisp was invented in the late
1950s as a formalism for reasoning about the use of certain kinds of logical expressions, called recursion
equations, as a model for computation. The language was conceived by John McCarthy and is based on
his paper ``Recursive Functions of Symbolic Expressions and Their Computation by Machine'' (McCarthy
1960).
</p>
<p>
Lisp, whose
name is an acronym for LISt Processing, was designed to provide symbol-manipulating capabilities for
attacking programming problems such as the symbolic differentiation and integration of algebraic
expressions.
</p>

</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1">1.1 The Elements of Programming</h3>
<div class="outline-text-3" id="text-5-1">

<p>Every powerful language has three mechanisms for
accomplishing this:
</p><ul>
<li>primitive expressions, which represent the simplest entities the language is concerned with,
</li>
<li>means of combination, by which compound elements are built from simpler ones, and
</li>
<li>means of abstraction, by which compound elements can be named and manipulated as units.
</li>
</ul>



<p>
In the Scheme dialect of Lisp, we name things with define. Typing
</p>


<pre class="src src-lisp">(define size 2)
</pre>


<p>
It should be clear that the possibility of associating values with symbols and later retrieving them means
that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This
memory is called the environment (more precisely the global environment, since we will see later that a
computation may involve a number of different environments).
</p>

<p>
We have identified in Lisp some of the elements that must appear in any powerful programming language:
</p><ul>
<li>Numbers and arithmetic operations are primitive data and procedures.
</li>
<li>Nesting of combinations provides a means of combining operations.
</li>
<li>Definitions that associate names with values provide a limited means of abstraction.
</li>
</ul>


<p>
The general form of a procedure definition is
(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)
</p><ul>
<li id="sec-5-1-1">1.1.5 The Substitution Model for Procedure Application<br/>
We can assume that the mechanism for applying primitive procedures to arguments is built into the
interpreter. For compound procedures, the application process is as follows:

<p>
To apply a compound procedure to arguments, evaluate the body of the procedure with each
formal parameter replaced by the corresponding argument.
</p>
<p>
(+ (square 6) (square 10))
If we use the definition of square, this reduces to
(+ (* 6 6) (* 10 10))
which reduces by multiplication to
(+ 36 100)
and finally to
136
The process we have just described is called the substitution model for procedure application. It can be
taken as a model that determines the ``meaning'' of procedure application, insofar as the procedures in this
chapter are concerned.
 <b>Applicative order versus normal order</b>
According to the description of evaluation given in section 1.1.3, the interpreter first evaluates the operator
and operands and then applies the resulting procedure to the resulting arguments. This is not the only way
to perform evaluation. An alternative evaluation model would not evaluate the operands until their values
were needed. Instead it would first substitute operand expressions for parameters until it obtained an
expression involving only primitive operators, and would then perform the evaluation. If we used this
method, the evaluation of
(f 5)
would proceed according to the sequence of expansions
</p>


<pre class="src src-lisp">(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
followed by the reductions
(+
(+
(* 6 6)
(* 10 10))
36
100)
136
</pre>


<p>
This alternative ``fully expand and then reduce'' evaluation method is known as normal-order evaluation,
in contrast to the ``evaluate the arguments and then apply'' method that the interpreter actually uses, which
is called applicative-order evaluation.
</p>
<p>
Lisp uses applicative-order evaluation, partly because of the additional efficiency obtained from avoiding
multiple evaluations of expressions such as those illustrated with (+ 5 1) and (* 5 2) above and,
more significantly, because normal-order evaluation becomes much more complicated to deal with when
we leave the realm of procedures that can be modeled by substitution. On the other hand, normal-order
evaluation can be an extremely valuable tool, and we will investigate some of its implications in chapters 3
and 4.
</p>
</li>
</ul>
<ul>
<li id="sec-5-1-2">1.1.6 Conditional Expressions and Predicates<br/>
It is called cond (which stands for ``conditional'')

<p>
The general form of a conditional expression is
(cond (&lt;p1&gt; &lt;e1&gt;)
(&lt;p2&gt; &lt;e2&gt;)
(&lt;pn&gt; &lt;en&gt;))
</p>
<p>
consisting of the symbol cond followed by parenthesized pairs of expressions (&lt;p&gt; &lt;e&gt;) called
clauses. The first expression in each pair is a predicate &ndash; that is, an expression whose value is interpreted
as either true or false.
</p>
<p>
Conditional expressions are evaluated as follows. The predicate &lt;p1&gt; is evaluated first. If its value is false,
then &lt;p2&gt; is evaluated. If &lt;p2&gt;'s value is also false, then &lt;p3&gt; is evaluated. This process continues until a
predicate is found whose value is true, in which case the interpreter returns the value of the corresponding
consequent expression &lt;e&gt; of the clause as the value of the conditional expression. If none of the &lt;p&gt;'s is
found to be true, the value of the cond is undefined.
</p>
<p>
This uses the special form if, a restricted type of conditional that can be used when there are precisely
two cases in the case analysis. The general form of an if expression is
(if &lt;predicate&gt; &lt;consequent&gt; &lt;alternative&gt;)
</p>
<p>
To evaluate an if expression, the interpreter starts by evaluating the &lt;predicate&gt; part of the expression. If
the &lt;predicate&gt; evaluates to a true value, the interpreter then evaluates the &lt;consequent&gt; and returns its
value. Otherwise it evaluates the &lt;alternative&gt; and returns its value.
</p>
<p>
In addition to primitive predicates such as &lt;, =, and &gt;, there are logical composition operations, which
enable us to construct compound predicates. The three most frequently used are these:
</p>
<ul>
<li>(and &lt;e1&gt; &hellip; &lt;en&gt;)
</li>
</ul>

<p>The interpreter evaluates the expressions &lt;e&gt; one at a time, in left-to-right order. If any &lt;e&gt;
evaluates to false, the value of the and expression is false, and the rest of the &lt;e&gt;'s are not
evaluated. If all &lt;e&gt;'s evaluate to true values, the value of the and expression is the value of the
last one.
</p>
<ul>
<li>(or &lt;e1&gt; &hellip; &lt;en&gt;)
</li>
</ul>

<p>The interpreter evaluates the expressions &lt;e&gt; one at a time, in left-to-right order. If any &lt;e&gt;
evaluates to a true value, that value is returned as the value of the or expression, and the rest of
the &lt;e&gt;'s are not evaluated. If all &lt;e&gt;'s evaluate to false, the value of the or expression is false.
</p>
<ul>
<li>(not &lt;e&gt;)
</li>
</ul>

<p>The value of a not expression is true when the expression &lt;e&gt; evaluates to false, and false
otherwise.
</p>
<p>
Notice that and and or are special forms, not procedures, because the subexpressions are not necessarily
all evaluated. Not is an ordinary procedure.
</p>
<p>
Exercise 1.5. Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is
using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:
(define (p) (p))
(define (test x y)
(if (= x 0)
0
y))
Then he evaluates the expression
(test 0 (p))
What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior
will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that
the evaluation rule for the special form if is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate
the consequent or the alternative expression.)
</p>
</li>
</ul>
<ul>
<li id="sec-5-1-3">1.1.7 Example: Square Roots by Newton's Method<br/>
</li>
</ul>
<ul>
<li id="sec-5-1-4">1.1.8 Procedures as Black-Box Abstractions<br/>























</li>
</ul>
</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-04-14T18:55+0800</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
