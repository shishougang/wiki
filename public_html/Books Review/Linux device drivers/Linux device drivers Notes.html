<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Linux device drivers Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Linux device drivers Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-05-10T22:38+0800"/>
<meta name="author" content="Shi Shougang"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" href="./assets/stylesheet.css" type="text/css"/>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:70%;white-space:nowrap;">
 <a accesskey="h" href="../../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Linux device drivers Notes</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">General</a>
<ul>
<li><a href="#sec-1-1">Make</a></li>
<li><a href="#sec-1-2">Generate Files</a></li>
<li><a href="#sec-1-3">Some important Data Structures</a></li>
<li><a href="#sec-1-4">Files</a></li>
<li><a href="#sec-1-5">Test</a></li>
</ul>
</li>
<li><a href="#sec-2">misc-modules</a>
<ul>
<li><a href="#sec-2-1"><code>hello.c</code></a></li>
<li><a href="#sec-2-2"><code>hellop.c</code></a></li>
<li><a href="#sec-2-3"><code>complete.c</code></a></li>
<li><a href="#sec-2-4"><code>faulty.c</code></a></li>
<li><a href="#sec-2-5"><code>jiq.c</code></a></li>
<li><a href="#sec-2-6"><code>kdataalign.c</code></a></li>
<li><a href="#sec-2-7"><code>kdatasize.c</code></a></li>
<li><a href="#sec-2-8"><code>sleepy.c</code></a></li>
<li><a href="#sec-2-9"><code>jit.c</code></a></li>
<li><a href="#sec-2-10"><code>seq.c</code></a></li>
<li><a href="#sec-2-11"><code>silly.c</code></a></li>
</ul>
</li>
<li><a href="#sec-3">misc-progs</a>
<ul>
<li><a href="#sec-3-1">dataalign.c</a></li>
<li><a href="#sec-3-2">datasize.c</a></li>
<li><a href="#sec-3-3">asynctest.c</a></li>
<li><a href="#sec-3-4">gdbline</a></li>
<li><a href="#sec-3-5">inp.c</a></li>
<li><a href="#sec-3-6">load50.c</a></li>
<li><a href="#sec-3-7">mapcmp.c</a></li>
<li><a href="#sec-3-8">mapper.c</a></li>
<li><a href="#sec-3-9">nbtest.c</a></li>
<li><a href="#sec-3-10">netifdebug.c</a></li>
<li><a href="#sec-3-11">outp.c</a></li>
<li><a href="#sec-3-12">polltest.c</a></li>
<li><a href="#sec-3-13">setconsole.c</a></li>
<li><a href="#sec-3-14">setlevel.c</a></li>
</ul>
</li>
<li><a href="#sec-4">skull</a></li>
<li><a href="#sec-5">scull</a></li>
<li><a href="#sec-6">short</a></li>
<li><a href="#sec-7">scullc</a></li>
<li><a href="#sec-8">sculld</a></li>
<li><a href="#sec-9">scullp</a></li>
<li><a href="#sec-10">scullv</a></li>
<li><a href="#sec-11">simple</a></li>
<li><a href="#sec-12">shortprint</a></li>
<li><a href="#sec-13">pci</a></li>
<li><a href="#sec-14">usb</a></li>
<li><a href="#sec-15">lddbus</a></li>
<li><a href="#sec-16">sbull</a></li>
<li><a href="#sec-17">snull</a></li>
<li><a href="#sec-18">tty</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">General</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Make</h3>
<div class="outline-text-3" id="text-1-1">




<pre class="src src-sh">KERNELDIR ?= /lib/modules/$(shell uname -r)/build
<span style="color: #ff7f24;">#  </span><span style="color: #ff7f24;">-r, --kernel-release         &#36755;&#20986;&#20869;&#26680;&#21457;&#34892;&#21495;</span>
$(MAKE) -C $(KERNELDIR) <span style="color: #eedd82;">M</span>=$(PWD) modules
</pre>

<p>
KERNELRELEASE是在内核源码的顶层Makefile中定义的一个变量，在第一次读取
执行此Makefile时，KERNELRELEASE没有被定义， 所以make将读取执行else之后
的内容。如果make的目标是clean，直接执行clean操作，然后结束。当make的目
标为all时，-C $(KDIR) 指明跳转到内核源码目录下读取那里的Makefile；
M=$(PWD) 表明然后返回到当前目录继续读入、执行当前的Makefile。当从内核
源码目录返回时，KERNELRELEASE已被被定义，kbuild也被启动去解析kbuild语
法的语句，make将继续读取else之前的内容。else之前的内容为kbuild语法的语
句, 指明模块源码中各文件的依赖关系，以及要生成的目标模块名。
mymodule-objs := file1.o file2.o表示mymoudule.o 由file1.o与file2.o 连
接生成。obj-m := mymodule.o表示编译连接后将生成mymodule.o模块。
</p>
<p>
 <code>kbuild</code>
</p>


<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Use make M=dir to specify directory of external module to build </span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Old syntax make ... SUBDIRS=$PWD is still supported </span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">Setting the environment variable KBUILD_EXTMOD take precedence </span>
ifdef SUBDIRS 
KBUILD_EXTMOD ?= $(SUBDIRS) 
endif 
ifdef M //&#22914;&#26524;&#27809;&#26377;&#23450;&#20041;&#25110;&#36171;&#20540;M&#65292;&#27492;&#22788;M&#26410;&#23450;&#20041;&#65288;undefined&#65289; 
<span style="color: #87cefa;">ifeq</span> (<span style="color: #ffa07a;">"$(origin M)"</span>, <span style="color: #ffa07a;">"command line"</span>) //&#22914;&#26524;&#23450;&#20041;&#20102;&#65292;&#27492;&#21477;&#29992;&#26469;&#21028;&#26029;M&#26159;&#21542;&#20174;&#21629;&#20196;&#34892;&#26469; 
KBUILD_EXTMOD := $(M) 
endif 
</pre>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Generate Files</h3>
<div class="outline-text-3" id="text-1-2">




<pre class="src src-sh">|-- modules.order
|-- Module.symvers
|-- XXX.ko
|-- XXX.mod.c
|-- XXX.mod.o
|-- XXX.o
</pre>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Some important Data Structures</h3>
<div class="outline-text-3" id="text-1-3">

<ul>
<li id="sec-1-3-1">File Operation<br/>
The structure, defined in &lt;linux/fs.h&gt;, is a collection of function
pointers. Each open file (represented internally by a file structure,
which we will examine shortly) is associated with its own set of
functions (by including a field called f<sub>op</sub> that points to a
file<sub>operations</sub> structure).


<p>
struct module *owner
</p>
<p>
    The first file<sub>operations</sub> field is not an operation at all; it is a pointer to the module that "owns" the structure. This field is used to prevent the module from being unloaded while its operations are in use. Almost all the time, it is simply initialized to THIS<sub>MODULE</sub>, a macro defined in &lt;linux/module.h&gt;.
</p>
<p>
loff<sub>t</sub> (*llseek) (struct file *, loff<sub>t</sub>, int);
</p>
<p>
    The llseek method is used to change the current read/write position in a file, and the new position is returned as a (positive) return value. The loff<sub>t</sub> parameter is a "long offset" and is at least 64 bits wide even on 32-bit platforms. Errors are signaled by a negative return value. If this function pointer is NULL, seek calls will modify the position counter in the file structure (described in Section 3.3.2) in potentially unpredictable ways.
</p>
<p>
ssize<sub>t</sub> (*read) (struct file *, char _ <sub>user</sub> *, size<sub>t</sub>, loff<sub>t</sub> *);
</p>
<p>
    Used to retrieve data from the device. A null pointer in this position causes the read system call to fail with -EINVAL ("Invalid argument"). A nonnegative return value represents the number of bytes successfully read (the return value is a "signed size" type, usually the native integer type for the target platform).
</p>
<p>
ssize<sub>t</sub> (*aio<sub>read</sub>)(struct kiocb *, char _ <sub>user</sub> *, size<sub>t</sub>, loff<sub>t</sub>);
</p>
<p>
    Initiates an asynchronous read—a read operation that might not complete before the function returns. If this method is NULL, all operations will be processed (synchronously) by read instead.
</p>
<p>
ssize<sub>t</sub> (*write) (struct file *, const char _ <sub>user</sub> *, size<sub>t</sub>, loff<sub>t</sub> *);
</p>
<p>
    Sends data to the device. If NULL, -EINVAL is returned to the program calling the write system call. The return value, if nonnegative, represents the number of bytes successfully written.
</p>
<p>
ssize<sub>t</sub> (*aio<sub>write</sub>)(struct kiocb *, const char _ <sub>user</sub> *, size<sub>t</sub>, loff<sub>t</sub> *);
</p>
<p>
    Initiates an asynchronous write operation on the device.
</p>
<p>
int (*readdir) (struct file *, void *, filldir<sub>t</sub>);
</p>
<p>
    This field should be NULL for device files; it is used for reading directories and is useful only for filesystems.
</p>
<p>
unsigned int (*poll) (struct file *, struct poll<sub>table</sub><sub>struct</sub> *);
</p>
<p>
    The poll method is the back end of three system calls: poll, epoll, and select, all of which are used to query whether a read or write to one or more file descriptors would block. The poll method should return a bit mask indicating whether non-blocking reads or writes are possible, and, possibly, provide the kernel with information that can be used to put the calling process to sleep until I/O becomes possible. If a driver leaves its poll method NULL, the device is assumed to be both readable and writable without blocking.
</p>
<p>
int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
</p>
<p>
    The ioctl system call offers a way to issue device-specific commands (such as formatting a track of a floppy disk, which is neither reading nor writing). Additionally, a few ioctl commands are recognized by the kernel without referring to the fops table. If the device doesn't provide an ioctl method, the system call returns an error for any request that isn't predefined (-ENOTTY, "No such ioctl for device").
</p>
<p>
int (*mmap) (struct file *, struct vm<sub>area</sub><sub>struct</sub> *);
</p>
<p>
    mmap is used to request a mapping of device memory to a process's address space. If this method is NULL, the mmap system call returns -ENODEV.
</p>
<p>
int (*open) (struct inode *, struct file *);
</p>
<p>
    Though this is always the first operation performed on the device file, the driver is not required to declare a corresponding method. If this entry is NULL, opening the device always succeeds, but your driver isn't notified.
</p>
<p>
int (*flush) (struct file *);
</p>
<p>
    The flush operation is invoked when a process closes its copy of a file descriptor for a device; it should execute (and wait for) any outstanding operations on the device. This must not be confused with the fsync operation requested by user programs. Currently, flush is used in very few drivers; the SCSI tape driver uses it, for example, to ensure that all data written makes it to the tape before the device is closed. If flush is NULL, the kernel simply ignores the user application request.
</p>
<p>
int (*release) (struct inode *, struct file *);
</p>
<p>
    This operation is invoked when the file structure is being released. Like open, release can be NULL.
</p>
<p>
        Note that release isn't invoked every time a process calls close. Whenever a file structure is shared (for example, after a fork or a dup), release won't be invoked until all copies are closed. If you need to flush pending data when any copy is closed, you should implement the flush method.
</p>

<p>
int (*fsync) (struct file *, struct dentry *, int);
</p>
<p>
    This method is the back end of the fsync system call, which a user calls to flush any pending data. If this pointer is NULL, the system call returns -EINVAL.
</p>
<p>
int (*aio<sub>fsync</sub>)(struct kiocb *, int);
</p>
<p>
    This is the asynchronous version of the fsync method.
</p>
<p>
int (*fasync) (int, struct file *, int);
</p>
<p>
    This operation is used to notify the device of a change in its FASYNC flag. Asynchronous notification is an advanced topic and is described in Chapter 6. The field can be NULL if the driver doesn't support asynchronous notification.
</p>
<p>
int (*lock) (struct file *, int, struct file<sub>lock</sub> *);
</p>
<p>
    The lock method is used to implement file locking; locking is an indispensable feature for regular files but is almost never implemented by device drivers.
</p>
<p>
ssize<sub>t</sub> (*readv) (struct file *, const struct iovec *, unsigned long, loff<sub>t</sub> *);
</p>

<p>
ssize<sub>t</sub> (*writev) (struct file *, const struct iovec *, unsigned long, loff<sub>t</sub> *);
</p>
<p>
    These methods implement scatter/gather read and write operations. Applications occasionally need to do a single read or write operation involving multiple memory areas; these system calls allow them to do so without forcing extra copy operations on the data. If these function pointers are left NULL, the read and write methods are called (perhaps more than once) instead.
</p>
<p>
ssize<sub>t</sub> (*sendfile)(struct file *, loff<sub>t</sub> *, size<sub>t</sub>, read<sub>actor</sub><sub>t</sub>, void *);
</p>
<p>
    This method implements the read side of the sendfile system call, which moves the data from one file descriptor to another with a minimum of copying. It is used, for example, by a web server that needs to send the contents of a file out a network connection. Device drivers usually leave sendfile NULL.
</p>
<p>
ssize<sub>t</sub> (*sendpage) (struct file *, struct page *, int, size<sub>t</sub>, loff<sub>t</sub> *,
</p>

<p>
int);
</p>
<p>
    sendpage is the other half of sendfile; it is called by the kernel to send data, one page at a time, to the corresponding file. Device drivers do not usually implement sendpage.
</p>
<p>
unsigned long (*get<sub>unmapped</sub><sub>area</sub>)(struct file *, unsigned long, unsigned
</p>

<p>
long, unsigned long, unsigned long);
</p>
<p>
    The purpose of this method is to find a suitable location in the process's address space to map in a memory segment on the underlying device. This task is normally performed by the memory management code; this method exists to allow drivers to enforce any alignment requirements a particular device may have. Most drivers can leave this method NULL.
</p>
<p>
int (*check<sub>flags</sub>)(int)
</p>
<p>
    This method allows a module to check the flags passed to an fcntl(F<sub>SETFL&hellip</sub>;) call.
</p>
<p>
int (*dir<sub>notify</sub>)(struct file *, unsigned long);
</p>
<p>
    This method is invoked when an application uses fcntl to request directory change notifications. It is useful only to filesystems; drivers need not implement dir<sub>notify</sub>.
</p>
<p>
The scull device driver implements only the most important device methods. Its file<sub>operations</sub> structure is initialized as follows:
</p>
<p>
struct file<sub>operations</sub> scull<sub>fops</sub> = {
</p>
<p>
    .owner =    THIS<sub>MODULE</sub>,
</p>
<p>
    .llseek =   scull<sub>llseek</sub>,
</p>
<p>
    .read =     scull<sub>read</sub>,
</p>
<p>
    .write =    scull<sub>write</sub>,
</p>
<p>
    .ioctl =    scull<sub>ioctl</sub>,
</p>
<p>
    .open =     scull<sub>open</sub>,
</p>
<p>
    .release =  scull<sub>release</sub>,
</p>
<p>
};
</p>
</li>
</ul>
<ul>
<li id="sec-1-3-2">The file Structure<br/>
struct file, defined in &lt;linux/fs.h&gt;, is the second most important
data structure used in device drivers. Note that a file has nothing to
do with the FILE pointers of user-space programs. A FILE is defined in
the C library and never appears in kernel code. A struct file, on the
other hand, is a kernel structure that never appears in user programs.

<p>
mode<sub>t</sub> f<sub>mode</sub>;
</p>
<p>
    The file mode identifies the file as either readable or writable (or both), by means of the bits FMODE<sub>READ</sub> and FMODE<sub>WRITE</sub>. You might want to check this field for read/write permission in your open or ioctl function, but you don't need to check permissions for read and write, because the kernel checks before invoking your method. An attempt to read or write when the file has not been opened for that type of access is rejected without the driver even knowing about it.
</p>
<p>
loff<sub>t</sub> f<sub>pos</sub>;
</p>
<p>
    The current reading or writing position. loff<sub>t</sub> is a 64-bit value on all platforms (long long in gcc terminology). The driver can read this value if it needs to know the current position in the file but should not normally change it; read and write should update a position using the pointer they receive as the last argument instead of acting on filp-&gt;f<sub>pos</sub> directly. The one exception to this rule is in the llseek method, the purpose of which is to change the file position.
</p>
<p>
unsigned int f<sub>flags</sub>;
</p>
<p>
    These are the file flags, such as O<sub>RDONLY</sub>, O<sub>NONBLOCK</sub>, and O<sub>SYNC</sub>. A driver should check the O<sub>NONBLOCK</sub> flag to see if nonblocking operation has been requested (we discuss nonblocking I/O in Section 6.2.3); the other flags are seldom used. In particular, read/write permission should be checked using f<sub>mode</sub> rather than f<sub>flags</sub>. All the flags are defined in the header &lt;linux/fcntl.h&gt;.
</p>
<p>
struct file<sub>operations</sub> *f<sub>op</sub>;
</p>
<p>
    The operations associated with the file. The kernel assigns the pointer as part of its implementation of open and then reads it when it needs to dispatch any operations. The value in filp-&gt;f<sub>op</sub> is never saved by the kernel for later reference; this means that you can change the file operations associated with your file, and the new methods will be effective after you return to the caller. For example, the code for open associated with major number 1 (/dev/null, /dev/zero, and so on) substitutes the operations in filp-&gt;f<sub>op</sub> depending on the minor number being opened. This practice allows the implementation of several behaviors under the same major number without introducing overhead at each system call. The ability to replace the file operations is the kernel equivalent of "method overriding" in object-oriented programming.
</p>
<p>
void *private<sub>data</sub>;
</p>
<p>
    The open system call sets this pointer to NULL before calling the open method for the driver. You are free to make its own use of the field or to ignore it; you can use the field to point to allocated data, but then you must remember to free that memory in the release method before the file structure is destroyed by the kernel. private<sub>data</sub> is a useful resource for preserving state information across system calls and is used by most of our sample modules.
</p>
<p>
struct dentry *f<sub>dentry</sub>;
</p>
<p>
    The directory entry (dentry) structure associated with the file. Device driver writers normally need not concern themselves with dentry structures, other than to access the inode structure as filp-&gt;f<sub>dentry</sub>-&gt;d<sub>inode</sub>.
</p>
</li>
</ul>
<ul>
<li id="sec-1-3-3">The inode Structure<br/>
The inode structure is used by the kernel internally to represent files. Therefore, it is different from the file structure that represents an open file descriptor. There can be numerous file structures representing multiple open descriptors on a single file, but they all point to a single inode structure.

<p>
The inode structure contains a great deal of information about the file. As a general rule, only two fields of this structure are of interest for writing driver code:
</p>

<p>
dev<sub>t</sub> i<sub>rdev</sub>;
</p>
<p>
    For inodes that represent device files, this field contains the actual device number.
</p>
<p>
struct cdev *i<sub>cdev</sub>;
</p>
<p>
    struct cdev is the kernel's internal structure that represents char devices; this field contains a pointer to that structure when the inode refers to a char device file.
</p>
<p>
The type of i<sub>rdev</sub> changed over the course of the 2.5 development series, breaking a lot of drivers. As a way of encouraging more portable programming, the kernel developers have added two macros that can be used to obtain the major and minor number from an inode:
</p>
<p>
unsigned int iminor(struct inode *inode);
</p>
<p>
unsigned int imajor(struct inode *inode);
</p>
</li>
</ul>
<ul>
<li id="sec-1-3-4">The dentry Structure<br/>




<pre class="src src-c">&lt;linux/dcache.h&gt;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> {
        <span style="color: #98fb98;">atomic_t</span> <span style="color: #eedd82;">d_count</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d_flags</span>;           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">protected by d_lock </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">spinlock_t</span> <span style="color: #eedd82;">d_lock</span>;              <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">per dentry lock </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">d_mounted</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *<span style="color: #eedd82;">d_inode</span>;          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Where the name belongs to - NULL is</span>
<span style="color: #ff7f24;">                                         * negative </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * The next three fields are touched by __d_lookup.  Place them here</span>
<span style="color: #ff7f24;">         * so they all fit in a cache line.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">hlist_node</span> <span style="color: #eedd82;">d_hash</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">lookup hash list </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *<span style="color: #eedd82;">d_parent</span>;        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent directory </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">qstr</span> <span style="color: #eedd82;">d_name</span>;

        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">d_lru</span>;         <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">LRU list </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * d_child and d_rcu can share memory</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">union</span> {
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">d_child</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">child of parent list </span><span style="color: #ff7f24;">*/</span>
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rcu_head</span> <span style="color: #eedd82;">d_rcu</span>;
        } <span style="color: #eedd82;">d_u</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">d_subdirs</span>;     <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">our children </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">d_alias</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">inode alias list </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">d_time</span>;           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">used by d_revalidate </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry_operations</span> *<span style="color: #eedd82;">d_op</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">super_block</span> *<span style="color: #eedd82;">d_sb</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">The root of the dentry tree </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">d_fsdata</span>;                 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">fs-specific data </span><span style="color: #ff7f24;">*/</span>

        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">d_iname</span>[DNAME_INLINE_LEN_MIN];    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">small names </span><span style="color: #ff7f24;">*/</span>
};
</pre>



</li>
</ul>
<ul>
<li id="sec-1-3-5">The utsname structure<br/>



<pre class="src src-c">&lt;usr/include/sys/utsname.h&gt;

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Structure describing the system and machine.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">utsname</span>
  {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Name of the implementation of the operating system.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">sysname</span>[_UTSNAME_SYSNAME_LENGTH];

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Name of this node on the network.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">nodename</span>[_UTSNAME_NODENAME_LENGTH];

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Current release level of this implementation.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">release</span>[_UTSNAME_RELEASE_LENGTH];
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Current version level of this release.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">version</span>[_UTSNAME_VERSION_LENGTH];

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Name of the hardware type the system is running on.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">machine</span>[_UTSNAME_MACHINE_LENGTH];

<span style="color: #b0c4de;">#if</span> _UTSNAME_DOMAIN_LENGTH - 0
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Name of the domain of this node on the network.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># ifdef</span> __USE_GNU
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">domainname</span>[_UTSNAME_DOMAIN_LENGTH];
<span style="color: #b0c4de;"># else</span>
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__domainname</span>[_UTSNAME_DOMAIN_LENGTH];
<span style="color: #b0c4de;"># endif</span>
<span style="color: #b0c4de;">#endif</span>
  };

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Put information about the system in NAME.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">uname</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">utsname</span> *<span style="color: #eedd82;">__name</span>) __THROW;
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Files</h3>
<div class="outline-text-3" id="text-1-4">

<ul>
<li id="sec-1-4-1">/proc/moudles<br/>
/proc/moudles 是旧式的, 那种信息的单个文件版本. 其中的条目包含了模块名,
每个模块占用的内存数量, 以及使用计数. 另外的字串追加到每行的末尾来指定
标志, 对这个模块当前是活动的.



<pre class="src src-sh">binfmt_misc 6587 1 - Live 0xf82b0000
ppdev 5259 0 - Live 0xf8274000
vboxnetadp 6390 0 - Live 0xf82ac000
vboxnetflt 12740 0 - Live 0xf826e000
vboxdrv 169169 2 vboxnetadp,vboxnetflt, Live 0xf8626000
nfsd 238778 13 - Live 0xf870d000
exportfs 3437 1 nfsd, Live 0xf8308000
nfs 265631 0 - Live 0xf8683000
lockd 64881 2 nfsd,nfs, Live 0xf8614000
nfs_acl 2245 2 nfsd,nfs, Live 0xf82a9000
auth_rpcgss 33767 2 nfsd,nfs, Live 0xf8299000
sunrpc 193609 12 nfsd,nfs,lockd,nfs_acl,auth_rpcgss, Live 0xf85e2000
snd_hda_codec_realtek 203472 1 - Live 0xf9d34000
snd_usb_audio 75861 2 - Live 0xf9cce000
snd_usb_lib 15833 1 snd_usb_audio, Live 0xf9ca7000
snd_hda_intel 22165 4 - Live 0xf9c79000
snd_pcm_oss 35308 0 - Live 0xf9c5c000
snd_hda_codec 74297 2 snd_hda_codec_realtek,snd_hda_intel, Live 0xf9c2e000
snd_mixer_oss 13746 1 snd_pcm_oss, Live 0xf9c09000
snd_pcm 70918 5 snd_usb_audio,snd_hda_intel,snd_pcm_oss,snd_hda_codec, Live 0xf9be5000 
</pre>

</li>
</ul>
<ul>
<li id="sec-1-4-2">/proc/devices<br/>



<pre class="src src-sh">Character devices:
  1 mem
  4 /dev/vc/0
  4 tty
  4 ttyS
  5 /dev/tty
  5 /dev/console
  5 /dev/ptmx
  6 lp
  7 vcs
 10 misc
 13 input
 14 sound
 21 sg
 29 fb
 99 ppdev
108 ppp
116 alsa
Block devices:
  1 ramdisk
259 blkext
  7 loop
  8 sd
  9 md
 11 sr
 65 sd
</pre>

</li>
</ul>
<ul>
<li id="sec-1-4-3">/sys/module<br/>
 /sys/module 是一个 sysfs 目录层次, 包含当前加载模块的



<pre class="src src-sh">/sys/module
|-- 8250
|   <span style="color: #fa8072;">`-- parameters</span>
<span style="color: #fa8072;">|       |-- nr_uarts</span>
<span style="color: #fa8072;">|       |-- probe_rsa</span>
<span style="color: #fa8072;">|       |-- share_irqs</span>
<span style="color: #fa8072;">|       `</span>-- skip_txen_test
|-- acpi
|   <span style="color: #fa8072;">`-- parameters</span>
<span style="color: #fa8072;">|       |-- acpica_version</span>
<span style="color: #fa8072;">|       |-- bfs</span>
<span style="color: #fa8072;">|       |-- gts</span>
<span style="color: #fa8072;">|       `</span>-- immediate_undock
|-- acpi_cpufreq
|   <span style="color: #fa8072;">`-- parameters</span>
<span style="color: #fa8072;">|       `</span>-- acpi_pstate_strict
|-- agpgart
|   |-- holders
|   |   <span style="color: #fa8072;">`-- nvidia -&gt; ../../nvidia</span>
<span style="color: #fa8072;">|   |-- initstate</span>
<span style="color: #fa8072;">|   |-- notes</span>
<span style="color: #fa8072;">|   |-- refcnt</span>
<span style="color: #fa8072;">|   |-- sections</span>
<span style="color: #fa8072;">|   |   |-- __kcrctab</span>
<span style="color: #fa8072;">|   |   |-- __kcrctab_gpl</span>
<span style="color: #fa8072;">|   |   |-- __ksymtab</span>
<span style="color: #fa8072;">|   |   |-- __ksymtab_gpl</span>
<span style="color: #fa8072;">|   |   |-- __ksymtab_strings</span>
<span style="color: #fa8072;">|   |   `</span>-- __mcount_loc
|   <span style="color: #fa8072;">`-- srcversion</span>
<span style="color: #fa8072;">.....</span>
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Test</h3>
<div class="outline-text-3" id="text-1-5">




<pre class="src src-sh">sudo insmod xxx.ko   or sudo modprobe xxx.ko
sudo mknod -m og+rw /dev/XXX c MAJNUM 0
or sudo chmod NNN /dev/XXX
</pre>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">misc-modules</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><code>hello.c</code></h3>
<div class="outline-text-3" id="text-2-1">




<pre class="src src-c">1) MODULE_LICENSE(<span style="color: #ffa07a;">"Dual BSD/GPL"</span>);
2) printk(KERN_ALERT <span style="color: #ffa07a;">"Hello, world\n"</span>);
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/kernel.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printk</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">fmt</span>, ...);
    &#20869;&#26680;&#20195;&#30721;&#30340; <span style="color: #98fb98;">printf</span> <span style="color: #eedd82;">&#31867;&#20284;&#29289;</span>.

3) module_init(hello_init);
module_exit(hello_exit);
</pre>

<ul>
<li id="sec-2-1-1">Check the output message<br/>
dmesg | tail
</li>
</ul>
<ul>
<li id="sec-2-1-2">Ref<br/>
<ul>
<li id="sec-2-1-2-1"><code>module_init</code> and <code>module_exit</code><br/>
 <b>chapter 2</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/init.h&gt;</span>

<span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> MODULE
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">module_init()</span><span style="color: #ffa07a;"> - driver initialization entry point</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@x</span><span style="color: #ffa07a;">: function to be run at kernel boot time or module insertion</span>
<span style="color: #ffa07a;"> * </span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">module_init()</span><span style="color: #ffa07a;"> will either be called during </span><span style="color: #7fffd4;">do_initcalls()</span><span style="color: #ffa07a;"> (if</span>
<span style="color: #ffa07a;"> * builtin) or at module insertion time (if a module).  There can only</span>
<span style="color: #ffa07a;"> * be one per module.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_init</span>(<span style="color: #eedd82;">x</span>)  __initcall(x);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">module_exit()</span><span style="color: #ffa07a;"> - driver exit entry point</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@x</span><span style="color: #ffa07a;">: function to be run when driver is removed</span>
<span style="color: #ffa07a;"> * </span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">module_exit()</span><span style="color: #ffa07a;"> will wrap the driver clean-up code</span>
<span style="color: #ffa07a;"> * with </span><span style="color: #7fffd4;">cleanup_module()</span><span style="color: #ffa07a;"> when used with rmmod when</span>
<span style="color: #ffa07a;"> * the driver is a module.  If the driver is statically</span>
<span style="color: #ffa07a;"> * compiled into the kernel, </span><span style="color: #7fffd4;">module_exit()</span><span style="color: #ffa07a;"> has no effect.</span>
<span style="color: #ffa07a;"> * There can only be one per module.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_exit</span>(<span style="color: #eedd82;">x</span>)  __exitcall(x);

<span style="color: #b0c4de;">#else</span> <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">MODULE </span><span style="color: #ff7f24;">*/</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Each module must use one module_init(). </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_init</span>(<span style="color: #eedd82;">initfn</span>)                                     \
        <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">initcall_t</span> <span style="color: #87cefa;">__inittest</span>(<span style="color: #98fb98;">void</span>)               \
        { <span style="color: #00ffff;">return</span> initfn; }                                      \
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">init_module</span>(<span style="color: #98fb98;">void</span>) <span style="color: #00ffff;">__attribute__</span>((alias(#initfn)));

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">This is only required if you want to be unloadable. </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_exit</span>(<span style="color: #eedd82;">exitfn</span>)                                     \
        <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">exitcall_t</span> <span style="color: #87cefa;">__exittest</span>(<span style="color: #98fb98;">void</span>)               \
        { <span style="color: #00ffff;">return</span> exitfn; }                                      \
        <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cleanup_module</span>(<span style="color: #98fb98;">void</span>) <span style="color: #00ffff;">__attribute__</span>((alias(#exitfn)));
<span style="color: #b0c4de;">#endif</span>
</pre>


</li>
</ul>
<ul>
<li id="sec-2-1-2-2"><code>printk</code><br/>
 <b>chapter 2</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/printk.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_EMERG</span>      <span style="color: #ffa07a;">"&lt;0&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">system is unusable                   </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_ALERT</span>      <span style="color: #ffa07a;">"&lt;1&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">action must be taken immediately     </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_CRIT</span>       <span style="color: #ffa07a;">"&lt;2&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">critical conditions                  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_ERR</span>        <span style="color: #ffa07a;">"&lt;3&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">error conditions                     </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_WARNING</span>    <span style="color: #ffa07a;">"&lt;4&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">warning conditions                   </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_NOTICE</span>     <span style="color: #ffa07a;">"&lt;5&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">normal but significant condition     </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_INFO</span>       <span style="color: #ffa07a;">"&lt;6&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">informational                        </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">KERN_DEBUG</span>      <span style="color: #ffa07a;">"&lt;7&gt;"</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">debug-level messages                 </span><span style="color: #ff7f24;">*/</span>

<span style="color: #b0c4de;">#ifdef</span> CONFIG_PRINTK
asmlinkage <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printk</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">fmt</span>, ...)
        <span style="color: #00ffff;">__attribute__</span> ((format (printf, 1, 2))) <span style="color: #98fb98;">__cold</span>;
<span style="color: #b0c4de;">#else</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">printk</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span>, ...)
        <span style="color: #00ffff;">__attribute__</span> ((format (printf, 1, 2)));
<span style="color: #b0c4de;">#endif</span>
</pre>


</li>
</ul>
<ul>
<li id="sec-2-1-2-3"><code>MODULE_LICENSE("Dual BSD/GPL");</code><br/>
 <b>chapter 2</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/module.h&gt;</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Generic info of form tag = "info" </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MODULE_INFO</span>(<span style="color: #eedd82;">tag</span>, <span style="color: #eedd82;">info</span>) __MODULE_INFO(tag, tag, info)

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * The following license idents are currently accepted as indicating free</span>
<span style="color: #ff7f24;"> * software modules</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> *      "GPL"                           [GNU Public License v2 or later]</span>
<span style="color: #ff7f24;"> *      "GPL v2"                        [GNU Public License v2]</span>
<span style="color: #ff7f24;"> *      "GPL and additional rights"     [GNU Public License v2 rights and more]</span>
<span style="color: #ff7f24;"> *      "Dual BSD/GPL"                  [GNU Public License v2</span>
<span style="color: #ff7f24;"> *                                       or BSD license choice]</span>
<span style="color: #ff7f24;"> *      "Dual MIT/GPL"                  [GNU Public License v2</span>
<span style="color: #ff7f24;"> *                                       or MIT license choice]</span>
<span style="color: #ff7f24;"> *      "Dual MPL/GPL"                  [GNU Public License v2</span>
<span style="color: #ff7f24;"> *                                       or Mozilla license choice]</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * The following other idents are available</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> *      "Proprietary"                   [Non free products]</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * There are dual licensed components, but when running with Linux it is the</span>
<span style="color: #ff7f24;"> * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL</span>
<span style="color: #ff7f24;"> * is a GPL combined work.</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * This exists for several reasons</span>
<span style="color: #ff7f24;"> * 1.   So modinfo can show license info for users wanting to vet their setup </span>
<span style="color: #ff7f24;"> *      is free</span>
<span style="color: #ff7f24;"> * 2.   So the community can ignore bug reports including proprietary modules</span>
<span style="color: #ff7f24;"> * 3.   So vendors can do likewise based on their own policies</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MODULE_LICENSE</span>(<span style="color: #eedd82;">_license</span>) MODULE_INFO(license, _license)
</pre>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/moduleparam.h&gt;</span>

<span style="color: #b0c4de;">#ifdef</span> MODULE
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">___module_cat</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>) __mod_ ## a ## b
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__module_cat</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>) ___module_cat(a,b)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__MODULE_INFO</span>(<span style="color: #eedd82;">tag</span>, <span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">info</span>)                                    \
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #87cefa;">__module_cat</span>(name,__LINE__)[]                           \
  __used <span style="color: #00ffff;">__attribute__</span>((section(<span style="color: #ffa07a;">".modinfo"</span>), unused, aligned(1)))         \
  = __stringify(tag) <span style="color: #ffa07a;">"="</span> info
<span style="color: #b0c4de;">#else</span>  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">!MODULE </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__MODULE_INFO</span>(<span style="color: #eedd82;">tag</span>, <span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">info</span>)
<span style="color: #b0c4de;">#endif</span>
</pre>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><code>hellop.c</code></h3>
<div class="outline-text-3" id="text-2-2">

<ul>
<li id="sec-2-2-1">SRC<br/>



<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">whom</span> = <span style="color: #ffa07a;">"world"</span>;
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">howmany</span> = 1;
module_param(howmany, <span style="color: #98fb98;">int</span>, S_IRUGO);
module_param(whom, charp, S_IRUGO);
</pre>

</li>
</ul>
<ul>
<li id="sec-2-2-2"><code>module_param(name, type, perm)</code><br/>
 <b>chapter 2</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/moduleparam.h&gt;</span>

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * module_param - typesafe helper for a module/cmdline parameter</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@value</span><span style="color: #ffa07a;">: the variable to alter, and exposed parameter name.</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@type</span><span style="color: #ffa07a;">: the type of the parameter</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@perm</span><span style="color: #ffa07a;">: visibility in sysfs.</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@value</span><span style="color: #ffa07a;"> becomes the module parameter, or (prefixed by KBUILD_MODNAME and a</span>
<span style="color: #ffa07a;"> * ".") the kernel commandline parameter.  Note that - is changed to _, so</span>
<span style="color: #ffa07a;"> * the user can use "foo-bar=1" even for variable "foo_bar".</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@perm</span><span style="color: #ffa07a;"> is 0 if the the variable is not to appear in sysfs, or 0444</span>
<span style="color: #ffa07a;"> * for world-readable, 0644 for root-writable, etc.  Note that if it</span>
<span style="color: #ffa07a;"> * is writable, you may need to use </span><span style="color: #7fffd4;">kparam_block_sysfs_write()</span><span style="color: #ffa07a;"> around</span>
<span style="color: #ffa07a;"> * accesses (esp. charp, which can be kfreed when it changes).</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * The </span><span style="color: #7fffd4;">@type</span><span style="color: #ffa07a;"> is simply pasted to refer to a param_ops_#</span><span style="color: #7fffd4;">#type</span><span style="color: #ffa07a;"> and a</span>
<span style="color: #ffa07a;"> * param_check_#</span><span style="color: #7fffd4;">#type</span><span style="color: #ffa07a;">: for convenience many standard types are provided but</span>
<span style="color: #ffa07a;"> * you can create your own by defining those variables.</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * Standard types are:</span>
<span style="color: #ffa07a;"> *      byte, short, ushort, int, uint, long, ulong</span>
<span style="color: #ffa07a;"> *      charp: a character pointer</span>
<span style="color: #ffa07a;"> *      bool: a bool, values 0/1, y/n, Y/N.</span>
<span style="color: #ffa07a;"> *      invbool: the above, only sense-reversed (N = true).</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_param</span>(<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">type</span>, <span style="color: #eedd82;">perm</span>)                          \
        module_param_named(name, name, type, perm)

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * module_param_named - typesafe helper for a renamed module/cmdline parameter</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@name</span><span style="color: #ffa07a;">: a valid C identifier which is the parameter name.</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@value</span><span style="color: #ffa07a;">: the actual lvalue to alter.</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@type</span><span style="color: #ffa07a;">: the type of the parameter</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@perm</span><span style="color: #ffa07a;">: visibility in sysfs.</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * Usually it's a good idea to have variable names and user-exposed names the</span>
<span style="color: #ffa07a;"> * same, but that's harder if the variable must be non-static or is inside a</span>
<span style="color: #ffa07a;"> * structure.  This allows exposure under a different name.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_param_named</span>(<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">value</span>, <span style="color: #eedd82;">type</span>, <span style="color: #eedd82;">perm</span>)                        \
        param_check_##type(name, &amp;(value));                                \
        module_param_cb(name, &amp;param_ops_##type, &amp;value, perm);            \
        __MODULE_PARM_TYPE(name, #type)

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * module_param_cb - general callback for a module/cmdline parameter</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@name</span><span style="color: #ffa07a;">: a valid C identifier which is the parameter name.</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@ops</span><span style="color: #ffa07a;">: the set &amp; get operations for this parameter.</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@perm</span><span style="color: #ffa07a;">: visibility in sysfs.</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * The ops can have NULL set or get functions.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">module_param_cb</span>(<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">ops</span>, <span style="color: #eedd82;">arg</span>, <span style="color: #eedd82;">perm</span>)                                 \
        __module_param_call(MODULE_PARAM_PREFIX,                              \
                            name, ops, arg, __same_type((arg), <span style="color: #98fb98;">bool</span> *), perm)

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">This is the fundamental function for registering boot/module</span>
<span style="color: #ff7f24;">   parameters. </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__module_param_call</span>(<span style="color: #eedd82;">prefix</span>, <span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">ops</span>, <span style="color: #eedd82;">arg</span>, <span style="color: #eedd82;">isbool</span>, <span style="color: #eedd82;">perm</span>)       \
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Default value instead of permissions? </span><span style="color: #ff7f24;">*/</span>                     \
        <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">__param_perm_check_</span>##name <span style="color: #00ffff;">__attribute__</span>((unused)) =  \
        BUILD_BUG_ON_ZERO((perm) &lt; 0 || (perm) &gt; 0777 || ((perm) &amp; 2))  \
        + BUILD_BUG_ON_ZERO(<span style="color: #00ffff;">sizeof</span>(<span style="color: #ffa07a;">""</span>prefix) &gt; MAX_PARAM_PREFIX_LEN);   \
        <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__param_str_</span>##name[] = prefix #name;          \
        <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kernel_param</span> <span style="color: #98fb98;">__moduleparam_const</span> <span style="color: #87cefa;">__param_</span>##name   \
        __used                                                          \
    <span style="color: #00ffff;">__attribute__</span> ((unused,__section__ (<span style="color: #ffa07a;">"__param"</span>),aligned(<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">void</span> *)))) \
        = { __param_str_##name, ops, perm, isbool ? KPARAM_ISBOOL : 0,  \
            { arg } }
</pre>

</li>
</ul>
<ul>
<li id="sec-2-2-3"><code>S_IRUGO</code><br/>
  <b>chapter 2</b>



<pre class="src src-c">&lt;linux/stat.h&gt;

<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span>(__KERNEL__) || !<span style="color: #b0c4de;">defined</span>(__GLIBC__) || (__GLIBC__ &lt; 2)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRWXU</span> 00700
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRUSR</span> 00400
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IWUSR</span> 00200
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IXUSR</span> 00100

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRWXG</span> 00070
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRGRP</span> 00040
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IWGRP</span> 00020
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IXGRP</span> 00010

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRWXO</span> 00007
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IROTH</span> 00004
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IWOTH</span> 00002
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IXOTH</span> 00001

<span style="color: #b0c4de;">#endif</span>


<span style="color: #b0c4de;">#ifdef</span> __KERNEL__
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRWXUGO</span>       (S_IRWXU|S_IRWXG|S_IRWXO)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IALLUGO</span>       (S_ISUID|S_ISGID|S_ISVTX|S_IRWXUGO)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IRUGO</span>         (S_IRUSR|S_IRGRP|S_IROTH)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IWUGO</span>         (S_IWUSR|S_IWGRP|S_IWOTH)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">S_IXUGO</span>         (S_IXUSR|S_IXGRP|S_IXOTH)

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">UTIME_NOW</span>       ((1l &lt;&lt; 30) - 1l)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">UTIME_OMIT</span>      ((1l &lt;&lt; 30) - 2l)
<span style="color: #b0c4de;">#endif</span>
</pre>


</li>
</ul>
<ul>
<li id="sec-2-2-4">Run<br/>



<pre class="src src-sh">sudo insmod hellop.ko  <span style="color: #eedd82;">howmany</span>=10 <span style="color: #eedd82;">whom</span>=<span style="color: #ffa07a;">"what"</span>
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><code>complete.c</code></h3>
<div class="outline-text-3" id="text-2-3">

<ul>
<li id="sec-2-3-1"><code>struct task_struct *current;</code><br/>
 <b>chapter 2.3</b>
Kernel code can refer to the current process by accessing the global
item current, defined in <code>&lt;asm/current.h&gt;</code>, which yields a pointer to
struct <code>task_struct</code>, defined by <code>&lt;linux/sched.h&gt;</code>.

<ul>
<li>snippet
</li>
</ul>




<pre class="src src-c">current-&gt;pid
current-&gt;comm
&#36827;&#31243; ID &#21644; &#24403;&#21069;&#36827;&#31243;&#30340;&#21629;&#20196;&#21517;.
</pre>


<ul>
<li>files
</li>
</ul>




<pre class="src src-c">&lt;linux/sched.h&gt;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/current.h&gt;</span>
</pre>


<pre class="src src-c"> &lt;<span style="color: #00ffff;">asm</span>/current.h&gt;
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/thread_info.h&gt;</span>

 <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *get_current(<span style="color: #98fb98;">void</span>) __attribute_const__;
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *<span style="color: #87cefa;">get_current</span>(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #00ffff;">return</span> current_thread_info()-&gt;task;
}

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">current</span> (get_current())
</pre>


<pre class="src src-c">&lt;linux/thread_info.h&gt;
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">thread_info</span> *current_thread_info(<span style="color: #98fb98;">void</span>) __attribute_const__;

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">thread_info</span> *<span style="color: #87cefa;">current_thread_info</span>(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">sp</span> <span style="color: #00ffff;">asm</span> (<span style="color: #ffa07a;">"sp"</span>);
        <span style="color: #00ffff;">return</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">thread_info</span> *)(sp &amp; ~(THREAD_SIZE - 1));
}
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">THREAD_SIZE</span>             8192

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * low level task data that entry.S needs immediate access to.</span>
<span style="color: #ff7f24;"> * __switch_to() assumes cpu_context follows immediately after cpu_domain.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">thread_info</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">flags</span>;          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">low level flags </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">int</span>                     <span style="color: #eedd82;">preempt_count</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">0 =&gt; preemptable, &lt;0 =&gt; bug </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">mm_segment_t</span>            <span style="color: #eedd82;">addr_limit</span>;     <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">address limit </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span>      *<span style="color: #eedd82;">task</span>;          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">main task structure </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">exec_domain</span>      *<span style="color: #eedd82;">exec_domain</span>;   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">execution domain </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">__u32</span>                   <span style="color: #eedd82;">cpu</span>;            <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">cpu </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">__u32</span>                   <span style="color: #eedd82;">cpu_domain</span>;     <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">cpu domain </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cpu_context_save</span> <span style="color: #eedd82;">cpu_context</span>;    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">cpu context </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">__u32</span>                   <span style="color: #eedd82;">syscall</span>;        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">syscall number </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">__u8</span>                    <span style="color: #eedd82;">used_cp</span>[16];    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">thread used copro </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">tp_value</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">crunch_state</span>     <span style="color: #eedd82;">crunchstate</span>;
        <span style="color: #00ffff;">union</span> <span style="color: #98fb98;">fp_state</span>          <span style="color: #eedd82;">fpstate</span> <span style="color: #00ffff;">__attribute__</span>((aligned(8)));
        <span style="color: #00ffff;">union</span> <span style="color: #98fb98;">vfp_state</span>         <span style="color: #eedd82;">vfpstate</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_ARM_THUMBEE
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">thumbee_state</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ThumbEE Handler Base register </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">restart_block</span>    <span style="color: #eedd82;">restart_block</span>;
};
</pre>


</li>
</ul>
<ul>
<li id="sec-2-3-2"><code>dev_t</code><br/>
   <b>chapter 3</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/types.h&gt;</span>
<span style="color: #b0c4de;">#ifdef</span> __KERNEL__

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">__u32</span> <span style="color: #98fb98;">__kernel_dev_t</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">__kernel_dev_t</span>          <span style="color: #98fb98;">dev_t</span>;
</pre>


<ul>
<li>operation
</li>
</ul>




<pre class="src src-c"><span style="color: #b0c4de;">  #include</span> <span style="color: #ffa07a;">&lt;linux/kdev_t.h&gt;</span>
<span style="color: #b0c4de;">#ifdef</span> __KERNEL__
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MINORBITS</span>       20
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MINORMASK</span>       ((1U &lt;&lt; MINORBITS) - 1)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MAJOR</span>(<span style="color: #eedd82;">dev</span>)      ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>) ((dev) &gt;&gt; MINORBITS))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MINOR</span>(<span style="color: #eedd82;">dev</span>)      ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>) ((dev) &amp; MINORMASK))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MKDEV</span>(<span style="color: #eedd82;">ma</span>,<span style="color: #eedd82;">mi</span>)    (((ma) &lt;&lt; MINORBITS) | (mi))

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">print_dev_t</span>(<span style="color: #eedd82;">buffer</span>, <span style="color: #eedd82;">dev</span>)                                        \
        sprintf((buffer), <span style="color: #ffa07a;">"%u:%u\n"</span>, MAJOR(dev), MINOR(dev))

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">format_dev_t</span>(<span style="color: #eedd82;">buffer</span>, <span style="color: #eedd82;">dev</span>)                                       \
        ({                                                              \
                sprintf(buffer, <span style="color: #ffa07a;">"%u:%u"</span>, MAJOR(dev), MINOR(dev));       \
                buffer;                                                 \
        })
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">u32</span> <span style="color: #87cefa;">new_encode_dev</span>(<span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">dev</span>)
{
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">major</span> = MAJOR(dev);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">minor</span> = MINOR(dev);
        <span style="color: #00ffff;">return</span> (minor &amp; 0xff) | (major &lt;&lt; 8) | ((minor &amp; ~0xff) &lt;&lt; 12);
}

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">dev_t</span> <span style="color: #87cefa;">new_decode_dev</span>(<span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">dev</span>)
{
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">major</span> = (dev &amp; 0xfff00) &gt;&gt; 8;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">minor</span> = (dev &amp; 0xff) | ((dev &gt;&gt; 12) &amp; 0xfff00);
        <span style="color: #00ffff;">return</span> MKDEV(major, minor);
}

<span style="color: #b0c4de;">#else</span> <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">__KERNEL__ </span><span style="color: #ff7f24;">*/</span>
<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">Some programs want their definitions of MAJOR and MINOR and MKDEV</span>
<span style="color: #ff7f24;">from the kernel sources. These must be the externally visible ones.</span>
<span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MAJOR</span>(<span style="color: #eedd82;">dev</span>)      ((dev)&gt;&gt;8)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MINOR</span>(<span style="color: #eedd82;">dev</span>)      ((dev) &amp; 0xff)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MKDEV</span>(<span style="color: #eedd82;">ma</span>,<span style="color: #eedd82;">mi</span>)    ((ma)&lt;&lt;8 | (mi))
<span style="color: #b0c4de;">#endif</span> <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">__KERNEL__ </span><span style="color: #ff7f24;">*/</span>
</pre>

</li>
</ul>
<ul>
<li id="sec-2-3-3">Allocating and Freeing Device Numbers<br/>
 <b>chapter 3</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/fs.h&gt;</span>
The &#8220;filesystem&#8221; header is the header required <span style="color: #00ffff;">for</span> writing device drivers. Many
important functions and data structures are declared in here.

<span style="color: #98fb98;">int</span> register_chrdev_region(<span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">first</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>)
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">alloc_chrdev_region</span>(<span style="color: #98fb98;">dev_t</span> *<span style="color: #eedd82;">dev</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">firstminor</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>)
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">unregister_chrdev_region</span>(<span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">first</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>);
Functions that allow a driver to allocate and free ranges of <span style="color: #98fb98;">device</span> <span style="color: #eedd82;">numbers</span>.
register_chrdev_region should be used when the desired major number is known
in advance; <span style="color: #00ffff;">for</span> dynamic allocation, use <span style="color: #98fb98;">alloc_chrdev_region</span> <span style="color: #eedd82;">instead</span>.
</pre>


<ul>
<li id="sec-2-3-3-1">how<br/>
<code>int register_chrdev_region(dev_t first, unsigned int count, char *name);</code>

<p>
Here, first is the beginning device number of the range you would like to allocate.
The minor number portion of first is often 0, but there is no requirement to that
effect. count is the total number of contiguous device numbers you are requesting.
Note that, if count is large, the range you request could spill over to the next major
number; but everything will still work properly as long as the number range you
request is available. Finally, name is the name of the device that should be associated
with this number range; it will appear in /proc/devices and sysfs.
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-3-4">Char Device Registration<br/>
  <b>chapter 3</b>
<ul>
<li id="sec-2-3-4-1">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">  #include</span> <span style="color: #ffa07a;">&lt;linux/cdev.h&gt;</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kobject</span> <span style="color: #eedd82;">kobj</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">module</span> *<span style="color: #eedd82;">owner</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span> *<span style="color: #eedd82;">ops</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">list</span>;
        <span style="color: #98fb98;">dev_t</span> <span style="color: #eedd82;">dev</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cdev_init</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *, <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span> *);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *<span style="color: #87cefa;">cdev_alloc</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">cdev_add</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *, <span style="color: #98fb98;">dev_t</span>, <span style="color: #98fb98;">unsigned</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cdev_del</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cdev_put</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *<span style="color: #eedd82;">p</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">cdev_index</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *<span style="color: #eedd82;">inode</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">cd_forget</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *);
<span style="color: #00ffff;">extern</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">backing_dev_info</span> <span style="color: #eedd82;">directly_mappable_cdev_bdi</span>;
</pre>

</li>
</ul>
<ul>
<li id="sec-2-3-4-2">examples<br/>
<ol>
<li>There are two ways of allocating and initializing one of these
   structures. If you wish to obtain a standalone cdev structure at
   runtime, you may do so with code such as:
</li>
</ol>





<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span> *<span style="color: #eedd82;">my_cdev</span> = cdev_alloc( );
my_cdev-&gt;ops = &amp;my_fops;
</pre>


<ol>
<li>Chances are, however, that you will want to embed the cdev
   structure within a device-specific structure of your own; that is
   what scull does. In that case, you should initialize the structure
   that you have already allocated with:
</li>
</ol>




<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">scull_setup_cdev</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">scull_dev</span> *<span style="color: #eedd82;">dev</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">index</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">err</span>, <span style="color: #eedd82;">devno</span> = MKDEV(scull_major, scull_minor + index);
  cdev_init(&amp;dev-&gt;cdev, &amp;scull_fops);
  dev-&gt;cdev.owner = THIS_MODULE;
  dev-&gt;cdev.ops = &amp;scull_fops;
  err = cdev_add (&amp;dev-&gt;cdev, devno, 1);
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Fail gracefully if need be </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">if</span> (err)
    printk(KERN_NOTICE <span style="color: #ffa07a;">"Error %d adding scull%d"</span>, err, index);
}
</pre>


</li>
</ul>
<ul>
<li id="sec-2-3-4-3">how<br/>
<ul>
<li><code>int cdev_add(struct cdev *dev, dev_t num, unsigned int count);</code>
     Here, dev is the cdev structure, num is the first device number to which this device
     responds, and count is the number of device numbers that should be associated with
     the device. Often count is one, but there are situations where it makes sense to have
     more than one device number correspond to a specific device.

<p>
     There are a couple of important things to keep in mind when using cdev<sub>add</sub>. The
     first is that this call can fail. If it returns a negative error code, your device has not
     been added to the system.
</p></li>
</ul>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-3-5">Data Structures<br/>
<ul>
<li id="sec-2-3-5-1"><code>struct file_opertaions</code><br/>
The file<sub>operations</sub> structure holds a char driver’s methods; 




<pre class="src src-c"><span style="color: #b0c4de;">     #include</span> <span style="color: #ffa07a;">&lt;linux/fs.h&gt;</span>
<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * NOTE:</span>
<span style="color: #ff7f24;"> * all file operations except setlease can be called without</span>
<span style="color: #ff7f24;"> * the big kernel lock held in all filesystems.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">module</span> *<span style="color: #eedd82;">owner</span>;
        <span style="color: #98fb98;">loff_t</span> (*<span style="color: #87cefa;">llseek</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">loff_t</span>, <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">read</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__user</span> *, <span style="color: #98fb98;">size_t</span>, <span style="color: #98fb98;">loff_t</span> *);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">write</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__user</span> *, <span style="color: #98fb98;">size_t</span>, <span style="color: #98fb98;">loff_t</span> *);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">aio_read</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kiocb</span> *, <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">iovec</span> *, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, <span style="color: #98fb98;">loff_t</span>);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">aio_write</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kiocb</span> *, <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">iovec</span> *, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, <span style="color: #98fb98;">loff_t</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">readdir</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">filldir_t</span>);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">poll</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">poll_table_struct</span> *);
        <span style="color: #98fb98;">long</span> (*<span style="color: #87cefa;">unlocked_ioctl</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">long</span> (*<span style="color: #87cefa;">compat_ioctl</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">mmap</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">vm_area_struct</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">open</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">flush</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">fl_owner_t</span> <span style="color: #eedd82;">id</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">release</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">fsync</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">datasync</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">aio_fsync</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kiocb</span> *, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">datasync</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">fasync</span>) (<span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">lock</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_lock</span> *);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">sendpage</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">page</span> *, <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">size_t</span>, <span style="color: #98fb98;">loff_t</span> *, <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> (*<span style="color: #87cefa;">get_unmapped_area</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">check_flags</span>)(<span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">flock</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_lock</span> *);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">splice_write</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">pipe_inode_info</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">loff_t</span> *, <span style="color: #98fb98;">size_t</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">splice_read</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">loff_t</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">pipe_inode_info</span> *, <span style="color: #98fb98;">size_t</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">setlease</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *, <span style="color: #98fb98;">long</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_lock</span> **);
};
</pre>

</li>
</ul>
<ul>
<li id="sec-2-3-5-2"><code>struct file</code><br/>
struct file represents an open file



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> {
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * fu_list becomes invalid after file_free is called and queued via</span>
<span style="color: #ff7f24;">         * fu_rcuhead for RCU freeing</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">union</span> {
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">fu_list</span>;
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rcu_head</span>         <span style="color: #eedd82;">fu_rcuhead</span>;
        } <span style="color: #eedd82;">f_u</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">path</span>             <span style="color: #eedd82;">f_path</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">f_dentry</span>        f_path.dentry
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">f_vfsmnt</span>        f_path.mnt
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span>    *<span style="color: #eedd82;">f_op</span>;
        <span style="color: #98fb98;">spinlock_t</span>              <span style="color: #eedd82;">f_lock</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">f_ep_links, f_flags, no IRQ </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#ifdef</span> CONFIG_SMP
        <span style="color: #98fb98;">int</span>                     <span style="color: #eedd82;">f_sb_list_cpu</span>;
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #98fb98;">atomic_long_t</span>           <span style="color: #eedd82;">f_count</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>            <span style="color: #eedd82;">f_flags</span>;
        <span style="color: #98fb98;">fmode_t</span>                 <span style="color: #eedd82;">f_mode</span>;
        <span style="color: #98fb98;">loff_t</span>                  <span style="color: #eedd82;">f_pos</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">fown_struct</span>      <span style="color: #eedd82;">f_owner</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cred</span>       *<span style="color: #eedd82;">f_cred</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_ra_state</span>    <span style="color: #eedd82;">f_ra</span>;

        <span style="color: #98fb98;">u64</span>                     <span style="color: #eedd82;">f_version</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_SECURITY
        <span style="color: #98fb98;">void</span>                    *<span style="color: #eedd82;">f_security</span>;
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">needed for tty driver, and maybe others </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">void</span>                    *<span style="color: #eedd82;">private_data</span>;

<span style="color: #b0c4de;">#ifdef</span> CONFIG_EPOLL
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Used by fs/eventpoll.c to link all the hooks to this file </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">f_ep_links</span>;
<span style="color: #b0c4de;">#endif</span> <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">#ifdef CONFIG_EPOLL </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">address_space</span>    *<span style="color: #eedd82;">f_mapping</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_DEBUG_WRITECOUNT
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">f_mnt_write_state</span>;
<span style="color: #b0c4de;">#endif</span>
};
</pre>


</li>
</ul>
<ul>
<li id="sec-2-3-5-3"><code>struct inode</code><br/>
struct inode represents a file on disk.



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">hlist_node</span>       <span style="color: #eedd82;">i_hash</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">i_wb_list</span>;      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">backing dev IO list </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">i_lru</span>;          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">inode LRU list </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">i_sb_list</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">i_dentry</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">i_ino</span>;
        <span style="color: #98fb98;">atomic_t</span>                <span style="color: #eedd82;">i_count</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>            <span style="color: #eedd82;">i_nlink</span>;
        <span style="color: #98fb98;">uid_t</span>                   <span style="color: #eedd82;">i_uid</span>;
        <span style="color: #98fb98;">gid_t</span>                   <span style="color: #eedd82;">i_gid</span>;
        <span style="color: #98fb98;">dev_t</span>                   <span style="color: #eedd82;">i_rdev</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>            <span style="color: #eedd82;">i_blkbits</span>;
        <span style="color: #98fb98;">u64</span>                     <span style="color: #eedd82;">i_version</span>;
        <span style="color: #98fb98;">loff_t</span>                  <span style="color: #eedd82;">i_size</span>;
<span style="color: #b0c4de;">#ifdef</span> __NEED_I_SIZE_ORDERED
        <span style="color: #98fb98;">seqcount_t</span>              <span style="color: #eedd82;">i_size_seqcount</span>;
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span>         <span style="color: #eedd82;">i_atime</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span>         <span style="color: #eedd82;">i_mtime</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span>         <span style="color: #eedd82;">i_ctime</span>;
        <span style="color: #98fb98;">blkcnt_t</span>                <span style="color: #eedd82;">i_blocks</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span>          <span style="color: #eedd82;">i_bytes</span>;
        <span style="color: #98fb98;">umode_t</span>                 <span style="color: #eedd82;">i_mode</span>;
        <span style="color: #98fb98;">spinlock_t</span>              <span style="color: #eedd82;">i_lock</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">i_blocks, i_bytes, maybe i_size </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">mutex</span>            <span style="color: #eedd82;">i_mutex</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">rw_semaphore</span>     <span style="color: #eedd82;">i_alloc_sem</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode_operations</span>   *<span style="color: #eedd82;">i_op</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span>    *<span style="color: #eedd82;">i_fop</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">former -&gt;i_op-&gt;default_file_ops </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">super_block</span>      *<span style="color: #eedd82;">i_sb</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_lock</span>        *<span style="color: #eedd82;">i_flock</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">address_space</span>    *<span style="color: #eedd82;">i_mapping</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">address_space</span>    <span style="color: #eedd82;">i_data</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_QUOTA
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dquot</span>            *<span style="color: #eedd82;">i_dquot</span>[MAXQUOTAS];
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span>        <span style="color: #eedd82;">i_devices</span>;
        <span style="color: #00ffff;">union</span> {
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">pipe_inode_info</span>  *<span style="color: #eedd82;">i_pipe</span>;
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">block_device</span>     *<span style="color: #eedd82;">i_bdev</span>;
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">cdev</span>             *<span style="color: #eedd82;">i_cdev</span>;
        };

        <span style="color: #98fb98;">__u32</span>                   <span style="color: #eedd82;">i_generation</span>;

<span style="color: #b0c4de;">#ifdef</span> CONFIG_FSNOTIFY
        <span style="color: #98fb98;">__u32</span>                   <span style="color: #eedd82;">i_fsnotify_mask</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">all events this inode cares about </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">hlist_head</span>       <span style="color: #eedd82;">i_fsnotify_marks</span>;
<span style="color: #b0c4de;">#endif</span>

        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">i_state</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>           <span style="color: #eedd82;">dirtied_when</span>;   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">jiffies of first dirtying </span><span style="color: #ff7f24;">*/</span>

        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>            <span style="color: #eedd82;">i_flags</span>;

<span style="color: #b0c4de;">#ifdef</span> CONFIG_IMA
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">protected by i_lock </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span>            <span style="color: #eedd82;">i_readcount</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">struct files open RO </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #98fb98;">atomic_t</span>                <span style="color: #eedd82;">i_writecount</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_SECURITY
        <span style="color: #98fb98;">void</span>                    *<span style="color: #eedd82;">i_security</span>;
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#ifdef</span> CONFIG_FS_POSIX_ACL
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">posix_acl</span>        *<span style="color: #eedd82;">i_acl</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">posix_acl</span>        *<span style="color: #eedd82;">i_default_acl</span>;
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #98fb98;">void</span>                    *<span style="color: #eedd82;">i_private</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">fs or device private pointer </span><span style="color: #ff7f24;">*/</span>
};
</pre>

</li>
</ul>
<ul>
<li id="sec-2-3-5-4"><code>struct inode_operations</code><br/>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode_operations</span> {
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">create</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,<span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nameidata</span> *);
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> * (*<span style="color: #87cefa;">lookup</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nameidata</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">link</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">unlink</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">symlink</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">mkdir</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,<span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">rmdir</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">mknod</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *,<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,<span style="color: #98fb98;">int</span>,<span style="color: #98fb98;">dev_t</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">rename</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *,
                        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">readlink</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__user</span> *,<span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">void</span> * (*<span style="color: #87cefa;">follow_link</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nameidata</span> *);
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">put_link</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">nameidata</span> *, <span style="color: #98fb98;">void</span> *);
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">truncate</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">permission</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">check_acl</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">setattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">iattr</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">getattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">vfsmount</span> *<span style="color: #eedd82;">mnt</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kstat</span> *);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">setxattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *,<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *,<span style="color: #98fb98;">size_t</span>,<span style="color: #98fb98;">int</span>);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">getxattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">void</span> *, <span style="color: #98fb98;">size_t</span>);
        <span style="color: #98fb98;">ssize_t</span> (*<span style="color: #87cefa;">listxattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #98fb98;">char</span> *, <span style="color: #98fb98;">size_t</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">removexattr</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dentry</span> *, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *);
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">truncate_range</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #98fb98;">loff_t</span>, <span style="color: #98fb98;">loff_t</span>);
        <span style="color: #98fb98;">long</span> (*<span style="color: #87cefa;">fallocate</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *<span style="color: #eedd82;">inode</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mode</span>, <span style="color: #98fb98;">loff_t</span> <span style="color: #eedd82;">offset</span>,
                          <span style="color: #98fb98;">loff_t</span> <span style="color: #eedd82;">len</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">fiemap</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">fiemap_extent_info</span> *, <span style="color: #98fb98;">u64</span> <span style="color: #eedd82;">start</span>,
                      <span style="color: #98fb98;">u64</span> <span style="color: #eedd82;">len</span>);
};
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-3-6">Completions 机制<br/>
    <b>chapter 5</b>
<ul>
<li id="sec-2-3-6-1">how<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/completion.h&gt;</span>
    <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">Method 1</span>
  DECLARE_COMPLETION(comp);
  wait_for_completion(&amp;comp);
  complete(&amp;comp);
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">Method 2</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> <span style="color: #eedd82;">my_completion</span>;
init_completion(&amp;my_completion);
</pre>


</li>
</ul>
<ul>
<li id="sec-2-3-6-2">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/completion.h&gt;</span>

/ * Atomic wait-<span style="color: #00ffff;">for</span>-completion handler data structures.
 * See kernel/sched.c <span style="color: #00ffff;">for</span> details.
 */

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">done</span>;
        <span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">wait</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">COMPLETION_INITIALIZER</span>(<span style="color: #eedd82;">work</span>) \
        { 0, __WAIT_QUEUE_HEAD_INITIALIZER((work).wait) }

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">COMPLETION_INITIALIZER_ONSTACK</span>(<span style="color: #eedd82;">work</span>) \
        ({ init_completion(&amp;work); work; })

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * DECLARE_COMPLETION - declare and initialize a completion structure</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@work</span><span style="color: #ffa07a;">:  identifier for the completion structure</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * This macro declares and initializes a completion structure. Generally used</span>
<span style="color: #ffa07a;"> * for static declarations. You should use the _ONSTACK variant for automatic</span>
<span style="color: #ffa07a;"> * variables.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">DECLARE_COMPLETION</span>(<span style="color: #eedd82;">work</span>) \
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> <span style="color: #eedd82;">work</span> = COMPLETION_INITIALIZER(work)

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * init_completion - Initialize a dynamically allocated completion</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@x</span><span style="color: #ffa07a;">:  completion structure that is to be initialized</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * This inline function will initialize a dynamically created completion</span>
<span style="color: #ffa07a;"> * structure.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">init_completion</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>)
{
        x-&gt;done = 0;
        init_waitqueue_head(&amp;x-&gt;wait);
}

<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wait_for_completion</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">wait_for_completion_interruptible</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">wait_for_completion_killable</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">wait_for_completion_timeout</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>,
                                                   <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">wait_for_completion_interruptible_timeout</span>(
                        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">wait_for_completion_killable_timeout</span>(
                        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">timeout</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">try_wait_for_completion</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">completion_done</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">x</span>);

<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">complete</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">complete_all</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *);

<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> * INIT_COMPLETION - reinitialize a completion structure</span>
<span style="color: #ffa07a;"> * </span><span style="color: #7fffd4;">@x</span><span style="color: #ffa07a;">:  completion structure to be reinitialized</span>
<span style="color: #ffa07a;"> *</span>
<span style="color: #ffa07a;"> * This macro should be used to reinitialize a completion structure so it can</span>
<span style="color: #ffa07a;"> * be reused. This is especially important after </span><span style="color: #7fffd4;">complete_all()</span><span style="color: #ffa07a;"> is used.</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_COMPLETION</span>(<span style="color: #eedd82;">x</span>)      ((x).done = 0)

</pre>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><code>faulty.c</code></h3>
<div class="outline-text-3" id="text-2-4">

<p> <b>chapter 4</b>
</p><ul>
<li id="sec-2-4-1">缓存区溢出<br/>
这个方法拷贝一个字串到一个本地变量; 不幸的是, 字串长于目的数组. 当函数
返回时导致的缓存区溢出引起一次 oops . 因为返回指令使指令指针到不知何处,
这类的错误很难跟踪
<ul>
<li>SRC
</li>
</ul>




<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">stack_buf</span>[4];
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Let's try a buffer overflow </span><span style="color: #ff7f24;">*/</span>
    memset(stack_buf, 0xff, 20);
</pre>

<ul>
<li>Test
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">cat /dev/faulty</span>
[1]    22139 killed     cat /dev/faulty

[178823.762627] BUG: unable to handle kernel NULL pointer dereference at 0000000b
[178823.762631] IP: [&lt;c0214ea9&gt;] vfs_read+0xa9/0x1a0
[178823.762637] *<span style="color: #eedd82;">pdpt</span> = 000000002d2cf001 *<span style="color: #eedd82;">pde</span> = 0000000000000000 
[178823.762640] Oops: 0000 [#1] SMP 
[178823.762642] last sysfs file: /sys/devices/pci0000:00/0000:00:03.0/0000:01:00.1/local_cpus
[178823.762645] Modules linked<span style="color: #00ffff;"> in</span>: faulty complete binfmt_misc ppdev vboxnetadp vboxnetflt vboxdrv nfsd exportfs nfs lockd nfs_acl auth_rpcgss sunrpc snd_hda_codec_realtek snd_usb_audio snd_usb_lib snd_hda_intel snd_pcm_oss snd_hda_codec snd_mixer_oss snd_pcm snd_seq_dummy snd_hwdep snd_seq_oss snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq fbcon snd_timer tileblit snd_seq_device tpm_tis font snd tpm bitblit tpm_bios softcursor soundcore psmouse snd_page_alloc nvidia(P) serio_raw agpgart vga16fb vgastate lp parport usbhid hid usb_storage ahci e1000e
[178823.762681] 
[178823.762684] Pid: 12648, comm: more Tainted: P           (2.6.32-42-generic-pae <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">96-Ubuntu) 5498RF4</span>
[178823.762693] EIP: 0060:[&lt;c0214ea9&gt;] EFLAGS: 00010202 CPU: 5
[178823.762697] EIP is at vfs_read+0xa9/0x1a0
[178823.762703] EAX: 00000004 EBX: ffffffff ECX: 00000000 EDX: b7487000
[178823.762708] ESI: 00000004 EDI: ffffffff EBP: ffffffff ESP: f166df6c
[178823.762710]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
[178823.762712] Process more (pid: 12648, <span style="color: #eedd82;">ti</span>=f166c000 <span style="color: #eedd82;">task</span>=e251d940 task.ti=f166c000)
[178823.762714] Stack:
[178823.762715]  f166df98 f166df88 c0361b19 f82f80f0 ed0f8e80 ed0f8e80 fffffff7 00000002
[178823.762719] &lt;0&gt; f166dfac c0215052 f166df98 00000000 00000000 00000000 00000003 09ad9c68
[178823.762723] &lt;0&gt; f166c000 c01096e3 00000003 b7487000 00001000 09ad9c68 00000002 bfaa34c4
[178823.762728] Call Trace:
[178823.762732]  [&lt;c0361b19&gt;] ? copy_to_user+0x39/0x130
[178823.762735]  [&lt;f82f80f0&gt;] ? faulty_read+0x0/0x50 [faulty]
[178823.762738]  [&lt;c0215052&gt;] ? sys_read+0x42/0x70
[178823.762741]  [&lt;c01096e3&gt;] ? sysenter_do_call+0x12/0x28
[178823.762743] Code: a4 8b 43 10 8b 40 08 85 c0 89 45 ec 0f 84 e1 00 00 00 8b 45 08 89 f1 89 fa 89 04 24 89 d8 ff 55 ec 89 c6 85 f6 0f 8e 9a 00 00 00 &lt;8b&gt; 7b 0c 31 db 8b 47 10 89 45 f0 0f b7 40 72 c7 44 24 04 00 00 
[178823.762791] EIP: [&lt;c0214ea9&gt;] vfs_read+0xa9/0x1a0 SS:ESP 0068:f166df6c
[178823.762794] CR2: 000000000000000b
[178823.762803] ---[ end trace 9342d36e7d9d6b0e ]---
</pre>


</li>
</ul>
<ul>
<li id="sec-2-4-2">make a simple fault by dereferencing a NULL pointer<br/>
<ul>
<li>SRC
</li>
</ul>




<pre class="src src-c">*(<span style="color: #98fb98;">int</span> *)0 = 0;
</pre>

<ul>
<li>Test
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo "test" &gt;  /dev/faulty</span>

[179151.985610] BUG: unable to handle kernel NULL pointer dereference at (null)
[179151.985618] IP: [&lt;f82f800a&gt;] faulty_write+0xa/0x20 [faulty]
[179151.985627] *<span style="color: #eedd82;">pdpt</span> = 0000000021426001 *<span style="color: #eedd82;">pde</span> = 0000000000000000 
[179151.985633] Oops: 0002 [#2] SMP 
[179151.985638] last sysfs file: /sys/devices/pci0000:00/0000:00:03.0/0000:01:00.1/local_cpus
[179151.985642] Modules linked<span style="color: #00ffff;"> in</span>: faulty complete binfmt_misc ppdev vboxnetadp vboxnetflt vboxdrv nfsd exportfs nfs lockd nfs_acl auth_rpcgss sunrpc snd_hda_codec_realtek snd_usb_audio snd_usb_lib snd_hda_intel snd_pcm_oss snd_hda_codec snd_mixer_oss snd_pcm snd_seq_dummy snd_hwdep snd_seq_oss snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq fbcon snd_timer tileblit snd_seq_device tpm_tis font snd tpm bitblit tpm_bios softcursor soundcore psmouse snd_page_alloc nvidia(P) serio_raw agpgart vga16fb vgastate lp parport usbhid hid usb_storage ahci e1000e
[179151.985703] 
[179151.985708] Pid: 6614, comm: zsh Tainted: P      D    (2.6.32-42-generic-pae <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">96-Ubuntu) 5498RF4</span>
[179151.985713] EIP: 0060:[&lt;f82f800a&gt;] EFLAGS: 00010246 CPU: 4
[179151.985718] EIP is at faulty_write+0xa/0x20 [faulty]
[179151.985721] EAX: 00000000 EBX: edaf1600 ECX: 00000005 EDX: 080d5540
[179151.985725] ESI: 00000005 EDI: 080d5540 EBP: e19edf64 ESP: e19edf64
[179151.985729]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
[179151.985733] Process zsh (pid: 6614, <span style="color: #eedd82;">ti</span>=e19ec000 <span style="color: #eedd82;">task</span>=e8fda640 task.ti=e19ec000)
[179151.985736] Stack:
[179151.985738]  e19edf8c c02146f2 e19edf98 edaf1600 edba3b00 f82f8000 e19edf94 edaf1600
[179151.985747] &lt;0&gt; fffffff7 080d5540 e19edfac c0214fe2 e19edf98 00000000 00000000 00000000
[179151.985757] &lt;0&gt; 00000001 00000005 e19ec000 c01096e3 00000001 080d5540 00000005 00000005
[179151.985767] Call Trace:
[179151.985774]  [&lt;c02146f2&gt;] ? vfs_write+0xa2/0x1a0
[179151.985779]  [&lt;f82f8000&gt;] ? faulty_write+0x0/0x20 [faulty]
[179151.985785]  [&lt;c0214fe2&gt;] ? sys_write+0x42/0x70
[179151.985790]  [&lt;c01096e3&gt;] ? sysenter_do_call+0x12/0x28
[179151.985793] Code: &lt;c7&gt; 05 00 00 00 00 00 00 00 00 5d c3 8d 76 00 8d bc 27 00 00 00 00 
[179151.985816] EIP: [&lt;f82f800a&gt;] faulty_write+0xa/0x20 [faulty] SS:ESP 0068:e19edf64
[179151.985822] CR2: 0000000000000000
[179151.985826] ---[ end trace 9342d36e7d9d6b0f ]---
</pre>


</li>
</ul>
<ul>
<li id="sec-2-4-3"><code>copy_to_user</code> and <code>copy_from_user</code><br/>
  <b>chapter 3</b>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/uaccess.h&gt;</span>
This include file declares functions used by kernel code to move data to and
from <span style="color: #98fb98;">user</span> <span style="color: #87cefa;">space</span>.

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> __must_check copy_from_user(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">to</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *from, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>)
{
        <span style="color: #00ffff;">if</span> (access_ok(VERIFY_READ, from, n))
                n = __copy_from_user(to, from, n);
        <span style="color: #00ffff;">else</span> <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">security hole - plug it </span><span style="color: #ff7f24;">*/</span>
                memset(to, 0, n);
        <span style="color: #00ffff;">return</span> n;
}

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">copy_to_user</span>(<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *to, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">from</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>)
{
        <span style="color: #00ffff;">if</span> (access_ok(VERIFY_WRITE, to, n))
                n = __copy_to_user(to, from, n);
        <span style="color: #00ffff;">return</span> n;
}


<span style="color: #b0c4de;">#ifdef</span> CONFIG_MMU
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">__copy_from_user</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">to</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *from, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">__copy_to_user</span>(<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *to, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">from</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">__copy_to_user_std</span>(<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *to, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">from</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">__clear_user</span>(<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *addr, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>);
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">__must_check</span> <span style="color: #87cefa;">__clear_user_std</span>(<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__user</span> *addr, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">n</span>);
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__copy_from_user</span>(<span style="color: #eedd82;">to</span>,<span style="color: #eedd82;">from</span>,<span style="color: #eedd82;">n</span>)     (memcpy(to, (<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__force</span> *)from, n), 0)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__copy_to_user</span>(<span style="color: #eedd82;">to</span>,<span style="color: #eedd82;">from</span>,<span style="color: #eedd82;">n</span>)       (memcpy((<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__force</span> *)to, from, n), 0)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">__clear_user</span>(<span style="color: #eedd82;">addr</span>,<span style="color: #eedd82;">n</span>)            (memset((<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">__force</span> *)addr, 0, n), 0)
<span style="color: #b0c4de;">#endif</span>

</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><code>jiq.c</code></h3>
<div class="outline-text-3" id="text-2-5">

<ul>
<li id="sec-2-5-1">Error and fix<br/>
<ul>
<li>error
</li>
</ul>




<pre class="src src-sh">jiq.c:18:26: error: linux/config.h: No such file or directory
jiq.c:122: warning: passing argument 1 of &#8216;schedule_delayed_work&#8217; from incompatible pointer type
jiq.c:244:46: error: macro <span style="color: #ffa07a;">"INIT_WORK"</span> passed 3 arguments, but takes just 2
jiq.c:244: error: &#8216;INIT_WORK&#8217; undeclared (first use<span style="color: #00ffff;"> in</span> this <span style="color: #00ffff;">function</span>)
</pre>


<ul>
<li>Fix

</li>
<li>从2.6.20的内核开始,INIT<sub>WORK宏做了改变</sub>,原来是三个参数,后来改成了两
   个参数

<p>
   In the <code>struct work_struct</code>, the type of <code>work_func_t func</code> is
   <code>typedef void (*work_func_t)(struct work_struct *work);</code>, so the
   function should be <code>void XXX(struct work_struct *work)</code>
</p></li>
</ul>


<p>
the example:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/workqueue.h&gt;</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> <span style="color: #eedd82;">my_work</span>;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">my_workfunc</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">ptr</span>);
INIT_WORK(&amp;my_work, my_workfunc);
</pre>


<p>
the API:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/workqueue.h&gt;</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">void</span> (*<span style="color: #98fb98;">work_func_t</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> {
        <span style="color: #98fb98;">atomic_long_t</span> <span style="color: #eedd82;">data</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">entry</span>;
        <span style="color: #98fb98;">work_func_t</span> <span style="color: #eedd82;">func</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_LOCKDEP
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">lockdep_map</span> <span style="color: #eedd82;">lockdep_map</span>;
<span style="color: #b0c4de;">#endif</span>
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> <span style="color: #eedd82;">work</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> <span style="color: #eedd82;">timer</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_WORK</span>(<span style="color: #eedd82;">_work</span>, <span style="color: #eedd82;">_func</span>)                                 \
        <span style="color: #00ffff;">do</span> {                                                    \
                __INIT_WORK((_work), (_func), 0);               \
        } <span style="color: #00ffff;">while</span> (0)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_WORK_ONSTACK</span>(<span style="color: #eedd82;">_work</span>, <span style="color: #eedd82;">_func</span>)                         \
        <span style="color: #00ffff;">do</span> {                                                    \
                __INIT_WORK((_work), (_func), 1);               \
        } <span style="color: #00ffff;">while</span> (0)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_DELAYED_WORK</span>(<span style="color: #eedd82;">_work</span>, <span style="color: #eedd82;">_func</span>)                         \
        <span style="color: #00ffff;">do</span> {                                                    \
                INIT_WORK(&amp;(_work)-&gt;work, (_func));             \
                init_timer(&amp;(_work)-&gt;timer);                    \
        } <span style="color: #00ffff;">while</span> (0)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_DELAYED_WORK_ONSTACK</span>(<span style="color: #eedd82;">_work</span>, <span style="color: #eedd82;">_func</span>)                 \
        <span style="color: #00ffff;">do</span> {                                                    \
                INIT_WORK_ONSTACK(&amp;(_work)-&gt;work, (_func));     \
                init_timer_on_stack(&amp;(_work)-&gt;timer);           \
        } <span style="color: #00ffff;">while</span> (0)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">INIT_DELAYED_WORK_DEFERRABLE</span>(<span style="color: #eedd82;">_work</span>, <span style="color: #eedd82;">_func</span>)              \
        <span style="color: #00ffff;">do</span> {                                                    \
                INIT_WORK(&amp;(_work)-&gt;work, (_func));             \
                init_timer_deferrable(&amp;(_work)-&gt;timer);         \
        } <span style="color: #00ffff;">while</span> (0)
</pre>


<ol>
<li>the diff 
</li>
</ol>




<pre class="src src-sh">18c18
&lt; /*#include &lt;linux/config.h&gt;*/
---
&gt; <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">include &lt;linux/config.h&gt;</span>
56c56
&lt; static struct delayed_work jiq_work;
---
&gt; static struct work_struct jiq_work;
83c83
&lt;       struct clientdata *<span style="color: #eedd82;">data</span> = (struct clientdata *) ptr;
---
&gt;       struct clientdata *<span style="color: #eedd82;">data</span> = ptr;
114c114
&lt; static void jiq_print_wq(struct work_struct *ptr)
---
&gt; static void jiq_print_wq(void *ptr)
116,117c116
&lt;       /*struct clientdata *<span style="color: #eedd82;">data</span> = jiq_data;*/
&lt;       
---
&gt;       struct clientdata *<span style="color: #eedd82;">data</span> = (struct clientdata *) ptr;
119c118
&lt;       if (! jiq_print (&amp;jiq_data))
---
&gt;       if (! jiq_print (ptr))
122,123c121,122
&lt;       if (jiq_data.delay)
&lt;               schedule_delayed_work(&amp;jiq_work, jiq_data.delay);
---
&gt;       if (data-&gt;delay)
&gt;               schedule_delayed_work(&amp;jiq_work, data-&gt;delay);
125c124
&lt;               schedule_work(&amp;jiq_work.work);
---
&gt;               schedule_work(&amp;jiq_work);
141c140
&lt;       schedule_work(&amp;jiq_work.work);
---
&gt;       schedule_work(&amp;jiq_work);
154d152
&lt; 
246,247c244
&lt;       printk(KERN_ALERT <span style="color: #ffa07a;">"jiq init"</span>);
&lt;       INIT_DELAYED_WORK(&amp;jiq_work, jiq_print_wq);
---
&gt;       INIT_WORK(&amp;jiq_work, jiq_print_wq, &amp;jiq_data);
253d249
&lt;       
260d255
&lt;       printk(KERN_ALERT <span style="color: #ffa07a;">"jiq_cleanup"</span>);
</pre>


</li>
</ul>
<ul>
<li id="sec-2-5-2">Test<br/>



<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">cat /proc/jitimer </span>
    <span style="color: #b0c4de;">time</span>  delta preempt   pid cpu command
   221012     0       0  3276   4 cat
   221262   250     256     0   4 swapper

<span style="color: #87cefa;">jiq_print</span>(&amp;jiq_data);
<span style="color: #87cefa;">nit_timer</span>(&amp;jiq_timer);              /* init the timer structure */
        jiq_timer.function = jiq_timedout;
        jiq_timer.data = (unsigned long)&amp;jiq_data;
        jiq_timer.expires = jiffies + HZ; /* one second */
static void jiq_timedout(unsigned long ptr)
{
        jiq_print((void *)ptr);            /* print a line */
        wake_up_interruptible(&amp;jiq_wait);  /* awake the process */
}



<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">cat /proc/jiqtasklet </span>
    <span style="color: #b0c4de;">time</span>  delta preempt   pid cpu command
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7
   231361     0     256    25   7 ksoftirqd/7

        <span style="color: #00ffff;">if</span> (jiq_print ((void *) ptr))
                tasklet_schedule (&amp;jiq_tasklet);

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">cat /proc/jiqwq</span>
    <span style="color: #b0c4de;">time</span>  delta preempt   pid cpu command
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5
    69546     0       0    32   5 events/5

        <span style="color: #00ffff;">if</span> (jiq_data.delay)
                schedule_delayed_work(&amp;jiq_work, jiq_data.delay);
        <span style="color: #00ffff;">else</span>
                schedule_work(&amp;jiq_work.work);

<span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">cat /proc/jiqwqdelay </span>
    <span style="color: #b0c4de;">time</span>  delta preempt   pid cpu command
   117793     1       0    33   6 events/6
   117794     1       0    33   6 events/6
   117795     1       0    33   6 events/6
   117796     1       0    33   6 events/6
   117797     1       0    33   6 events/6
   117798     1       0    33   6 events/6
   117799     1       0    33   6 events/6
   117800     1       0    33   6 events/6
   117801     1       0    33   6 events/6
   117802     1       0    33   6 events/6



</pre>


</li>
</ul>
<ul>
<li id="sec-2-5-3">创建你的 /proc 文件<br/>
 <b>Chapter 4.3</b>
有使用 /proc 的模块应当包含 <code>&lt;linux/proc_fs.h&gt;</code> 来定义正确的函数.

<p>
当一个进程读你的 <code>/proc</code> 文件, 内核分配了一页内存(就是说, <code>PAGE_SIZE</code>
字节), 驱动可以写入数据来返回给用户空间. 那个缓存区传递给你的函数, 是
一个称为 read<sub>proc</sub> 的方法:
</p>
<p>
<code>int (*read_proc)(char *page, char **start, off_t offset, int count, int *eof, void *data);</code>
</p>
<p>
page 指针是你写你的数据的缓存区; start 是这个函数用来说有关的数据写在
页中哪里(下面更多关于这个); offset 和 count 对于 read 方法有同样的含义.
eof 参数指向一个整数, 必须由驱动设置来指示它不再有数据返回, data 是驱
动特定的数据指针, 你可以用做内部用途.
</p>
<p>
一旦你有一个定义好的 <code>read_proc</code> 函数, 你应当连接它到 <code>/proc</code> 层次中的
一个入口项. 使用一个 <code>creat_proc_read_entry</code> 调用:
</p>
<p>
<code>struct proc_dir_entry *create_proc_read_entry(const char *name,mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data);</code> 
</p>
<p>
这里, name 是要创建的文件名子, mod 是文件的保护掩码(缺省系统范围时可以
作为 0 传递), base 指出要创建的文件的目录( 如果 base 是 NULL, 文件在
/proc 根下创建 ), <code>read_proc</code> 是实现文件的 <code>read_proc</code> 函数, data 被内核忽
略( 但是传递给 <code>read_proc</code>). 这就是 scull 使用的调用, 来使它的 <code>/proc</code> 函
数可用做 <code>/proc/scullmem</code>:
</p>

<p>
<code>create_proc_read_entry("scullmem", 0 /* default mode */, NULL /* parent dir */, scull_read_procmem, NULL /* client data */);</code>
</p>
<p>
这里, 我们创建了一个名为 scullmem 的文件, 直接在 /proc 下, 带有缺省的,
全局可读的保护.
</p>
<p>
/proc 中的入口, 当然, 应当在模块卸载后去除. remove<sub>proc</sub><sub>entry</sub> 是恢复
create<sub>proc</sub><sub>read</sub><sub>entry</sub> 所做的事情的函数:
</p>
<p>
<code>remove_proc_entry("scullmem", NULL /* parent dir */);</code>
</p>
<p>
去除入口失败会导致在不希望的时间调用, 或者, 如果你的模块已被卸载, 内核
崩掉.
</p>

<ul>
<li id="sec-2-5-3-1">Ref<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/proc_fs.h&gt;</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> *<span style="color: #87cefa;">create_proc_read_entry</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>,
        <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">mode</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> *<span style="color: #eedd82;">base</span>, 
        <span style="color: #98fb98;">read_proc_t</span> *<span style="color: #eedd82;">read_proc</span>, <span style="color: #98fb98;">void</span> * <span style="color: #eedd82;">data</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> *<span style="color: #eedd82;">res</span>=create_proc_entry(name,mode,base);
        <span style="color: #00ffff;">if</span> (res) {
                res-&gt;read_proc=read_proc;
                res-&gt;data=data;
        }
        <span style="color: #00ffff;">return</span> res;
}

<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">remove_proc_entry</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> *<span style="color: #eedd82;">parent</span>);

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> (<span style="color: #98fb98;">read_proc_t</span>)(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">page</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">start</span>, <span style="color: #98fb98;">off_t</span> <span style="color: #eedd82;">off</span>,
                          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">eof</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>);
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> (<span style="color: #98fb98;">write_proc_t</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *<span style="color: #eedd82;">file</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">__user</span> *buffer,
                           <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">low_ino</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;
        <span style="color: #98fb98;">mode_t</span> <span style="color: #eedd82;">mode</span>;
        <span style="color: #98fb98;">nlink_t</span> <span style="color: #eedd82;">nlink</span>;
        <span style="color: #98fb98;">uid_t</span> <span style="color: #eedd82;">uid</span>;
        <span style="color: #98fb98;">gid_t</span> <span style="color: #eedd82;">gid</span>;
        <span style="color: #98fb98;">loff_t</span> <span style="color: #eedd82;">size</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode_operations</span> *<span style="color: #eedd82;">proc_iops</span>;
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * NULL -&gt;proc_fops means "PDE is going away RSN" or</span>
<span style="color: #ff7f24;">         * "PDE is just created". In either case, e.g. -&gt;read_proc won't be</span>
<span style="color: #ff7f24;">         * called because it's too late or too early, respectively.</span>
<span style="color: #ff7f24;">         *</span>
<span style="color: #ff7f24;">         * If you're allocating -&gt;proc_fops dynamically, save a pointer</span>
<span style="color: #ff7f24;">         * somewhere.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span> *<span style="color: #eedd82;">proc_fops</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">proc_dir_entry</span> *<span style="color: #eedd82;">next</span>, *<span style="color: #eedd82;">parent</span>, *<span style="color: #eedd82;">subdir</span>;
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>;
        <span style="color: #98fb98;">read_proc_t</span> *<span style="color: #eedd82;">read_proc</span>;
        <span style="color: #98fb98;">write_proc_t</span> *<span style="color: #eedd82;">write_proc</span>;
        <span style="color: #98fb98;">atomic_t</span> <span style="color: #eedd82;">count</span>;         <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">use count </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pde_users</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">number of callers into module in progress </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">spinlock_t</span> <span style="color: #eedd82;">pde_unload_lock</span>; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">proc_fops checks and pde_users bumps </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">completion</span> *<span style="color: #eedd82;">pde_unload_completion</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">pde_openers</span>;   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">who did -&gt;open, but not -&gt;release </span><span style="color: #ff7f24;">*/</span>
};
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-5-4">Using the jiffies Counter<br/>
 <b>chapter 7.1</b>
Timer interrupts are generated by the system's timing hardware at
regular intervals; this interval is programmed at boot time by the
kernel according to the value of <b>HZ</b>, which is an
architecture-dependent value defined in <code>&lt;linux/param.h&gt;</code> or a
subplatform file included by it. Default values in the distributed
kernel source range from 50 to 1200 ticks per second on real hardware,
down to 24 for software simulators

<p>
Every time a timer interrupt occurs, the value of an internal kernel
counter is incremented. The counter is initialized to 0 at system
boot, so it represents the number of clock ticks since last boot. The
counter is a 64-bit variable (even on 32-bit architectures) and is
called jiffies<sub>64</sub>. However, driver writers normally access the jiffies
variable, an unsigned long that is the same as either jiffies<sub>64</sub> or
its least significant bits. Using jiffies is usually preferred because
it is faster, and accesses to the 64-bit jiffies<sub>64</sub> value are not
necessarily atomic on all architectures.
</p>
<p>
The counter and the utility functions to read it live in
&lt;linux/jiffies.h&gt;, although you'll usually just include
&lt;linux/sched.h&gt;, that automatically pulls jiffies.h in.
</p>
<p>
 <b>example</b>
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/jiffies.h&gt;</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">j</span>, <span style="color: #eedd82;">stamp_1</span>, <span style="color: #eedd82;">stamp_half</span>, <span style="color: #eedd82;">stamp_n</span>;

j = jiffies;                      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">read the current value </span><span style="color: #ff7f24;">*/</span>
stamp_1    = j + HZ;              <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">1 second in the future </span><span style="color: #ff7f24;">*/</span>
stamp_half = j + HZ/2;            <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">half a second </span><span style="color: #ff7f24;">*/</span>
stamp_n    = j + n * HZ / 1000;   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">n milliseconds </span><span style="color: #ff7f24;">*/</span>
</pre>


<p>
To compare your cached value and the current value, you should use one
of the following macros:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/jiffies.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">time_after</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">b</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">time_before</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">b</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">time_after_eq</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">b</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">time_before_eq</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">a</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">b</span>);

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">time_after(a,b) returns true if the time a is after time b. </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">time_after</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>)         \
        (typecheck(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, a) &amp;&amp; \
         typecheck(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, b) &amp;&amp; \
         ((<span style="color: #98fb98;">long</span>)(b) - (<span style="color: #98fb98;">long</span>)(a) &lt; 0))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">time_before</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>)        time_after(b,a)

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">time_after_eq</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>)      \
        (typecheck(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, a) &amp;&amp; \
         typecheck(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>, b) &amp;&amp; \
         ((<span style="color: #98fb98;">long</span>)(a) - (<span style="color: #98fb98;">long</span>)(b) &gt;= 0))
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">time_before_eq</span>(<span style="color: #eedd82;">a</span>,<span style="color: #eedd82;">b</span>)     time_after_eq(b,a)
</pre>


<p>
Sometimes, however, you need to exchange time representations with
user space programs that tend to represent time values with struct
timeval and struct timespec. The two structures represent a precise
time quantity with two numbers: seconds and microseconds are used in
the older and popular struct timeval, and seconds and nanoseconds are
used in the newer struct timespec. The kernel exports four helper
functions to convert time values expressed as jiffies to and from
those structures:
</p>


<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/time.h&gt;</span>


<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">timespec_to_jiffies</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> *<span style="color: #eedd82;">value</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">jiffies_to_timespec</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">jiffies</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> *<span style="color: #eedd82;">value</span>);
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #87cefa;">timeval_to_jiffies</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> *<span style="color: #eedd82;">value</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">jiffies_to_timeval</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">jiffies</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> *<span style="color: #eedd82;">value</span>);

&lt;linux/time.h&gt;
 <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> {
         <span style="color: #98fb98;">__kernel_time_t</span>         <span style="color: #eedd82;">tv_sec</span>;         <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">seconds </span><span style="color: #ff7f24;">*/</span>
         <span style="color: #98fb98;">__kernel_suseconds_t</span>    <span style="color: #eedd82;">tv_usec</span>;        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">microseconds </span><span style="color: #ff7f24;">*/</span>
 };

 <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> {
         <span style="color: #98fb98;">__kernel_time_t</span> <span style="color: #eedd82;">tv_sec</span>;                 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">seconds </span><span style="color: #ff7f24;">*/</span>
         <span style="color: #98fb98;">long</span>            <span style="color: #eedd82;">tv_nsec</span>;                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">nanoseconds </span><span style="color: #ff7f24;">*/</span>
 };

&lt;kernel/time.c&gt;
<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * The TICK_NSEC - 1 rounds up the value to the next resolution.  Note</span>
<span style="color: #ff7f24;"> * that a remainder subtract here would not do the right thing as the</span>
<span style="color: #ff7f24;"> * resolution values don't fall on second boundries.  I.e. the line:</span>
<span style="color: #ff7f24;"> * nsec -= nsec % TICK_NSEC; is NOT a correct resolution rounding.</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * Rather, we just shift the bits off the right.</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * The &gt;&gt; (NSEC_JIFFIE_SC - SEC_JIFFIE_SC) converts the scaled nsec</span>
<span style="color: #ff7f24;"> * value to a scaled second value.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>
timespec_to_jiffies(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> *<span style="color: #eedd82;">value</span>)
{
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">sec</span> = value-&gt;tv_sec;
        <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">nsec</span> = value-&gt;tv_nsec + TICK_NSEC - 1;

        <span style="color: #00ffff;">if</span> (sec &gt;= MAX_SEC_IN_JIFFIES){
                sec = MAX_SEC_IN_JIFFIES;
                nsec = 0;
        }
        <span style="color: #00ffff;">return</span> (((<span style="color: #98fb98;">u64</span>)sec * SEC_CONVERSION) +
                (((<span style="color: #98fb98;">u64</span>)nsec * NSEC_CONVERSION) &gt;&gt;
                 (NSEC_JIFFIE_SC - SEC_JIFFIE_SC))) &gt;&gt; SEC_JIFFIE_SC;

}
EXPORT_SYMBOL(timespec_to_jiffies);

<span style="color: #98fb98;">void</span>
<span style="color: #87cefa;">jiffies_to_timespec</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">jiffies</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> *<span style="color: #eedd82;">value</span>)
{
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * Convert jiffies to nanoseconds and separate with</span>
<span style="color: #ff7f24;">         * one divide.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">rem</span>;
        value-&gt;tv_sec = div_u64_rem((<span style="color: #98fb98;">u64</span>)<span style="color: #98fb98;">jiffies</span> * <span style="color: #eedd82;">TICK_NSEC</span>,
                                    <span style="color: #eedd82;">NSEC_PER_SEC</span>, &amp;rem);
        value-&gt;tv_nsec = rem;
}
EXPORT_SYMBOL(jiffies_to_timespec);

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Same for "timeval"</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * Well, almost.  The problem here is that the real system resolution is</span>
<span style="color: #ff7f24;"> * in nanoseconds and the value being converted is in micro seconds.</span>
<span style="color: #ff7f24;"> * Also for some machines (those that use HZ = 1024, in-particular),</span>
<span style="color: #ff7f24;"> * there is a LARGE error in the tick size in microseconds.</span>

<span style="color: #ff7f24;"> * The solution we use is to do the rounding AFTER we convert the</span>
<span style="color: #ff7f24;"> * microsecond part.  Thus the USEC_ROUND, the bits to be shifted off.</span>
<span style="color: #ff7f24;"> * Instruction wise, this should cost only an additional add with carry</span>
<span style="color: #ff7f24;"> * instruction above the way it was done above.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>
<span style="color: #87cefa;">timeval_to_jiffies</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> *<span style="color: #eedd82;">value</span>)
{
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">sec</span> = value-&gt;tv_sec;
        <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">usec</span> = value-&gt;tv_usec;

        <span style="color: #00ffff;">if</span> (sec &gt;= MAX_SEC_IN_JIFFIES){
                sec = MAX_SEC_IN_JIFFIES;
                usec = 0;
        }
        <span style="color: #00ffff;">return</span> (((<span style="color: #98fb98;">u64</span>)sec * SEC_CONVERSION) +
                (((<span style="color: #98fb98;">u64</span>)usec * USEC_CONVERSION + USEC_ROUND) &gt;&gt;
                 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) &gt;&gt; SEC_JIFFIE_SC;
}
EXPORT_SYMBOL(timeval_to_jiffies);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">jiffies_to_timeval</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">jiffies</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> *<span style="color: #eedd82;">value</span>)
{
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * Convert jiffies to nanoseconds and separate with</span>
<span style="color: #ff7f24;">         * one divide.</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">rem</span>;

        value-&gt;tv_sec = div_u64_rem((<span style="color: #98fb98;">u64</span>)<span style="color: #98fb98;">jiffies</span> * <span style="color: #eedd82;">TICK_NSEC</span>,
                                    <span style="color: #eedd82;">NSEC_PER_SEC</span>, &amp;rem);
        value-&gt;tv_usec = rem / NSEC_PER_USEC;
}
EXPORT_SYMBOL(jiffies_to_timeval);


&lt;linux/jiffies.h&gt;

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * We want to do realistic conversions of time so we need to use the same</span>
<span style="color: #ff7f24;"> * values the update wall clock code uses as the jiffies size.  This value</span>
<span style="color: #ff7f24;"> * is: TICK_NSEC (which is defined in timex.h).  This</span>
<span style="color: #ff7f24;"> * is a constant and is in nanoseconds.  We will use scaled math</span>
<span style="color: #ff7f24;"> * with a set of scales defined here as SEC_JIFFIE_SC,  USEC_JIFFIE_SC and</span>
<span style="color: #ff7f24;"> * NSEC_JIFFIE_SC.  Note that these defines contain nothing but</span>
<span style="color: #ff7f24;"> * constants and so are computed at compile time.  SHIFT_HZ (computed in</span>
<span style="color: #ff7f24;"> * timex.h) adjusts the scaling for different HZ values.</span>

<span style="color: #ff7f24;"> * Scaled math???  What is that?</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * Scaled math is a way to do integer math on values that would,</span>
<span style="color: #ff7f24;"> * otherwise, either overflow, underflow, or cause undesired div</span>
<span style="color: #ff7f24;"> * instructions to appear in the execution path.  In short, we "scale"</span>
<span style="color: #ff7f24;"> * up the operands so they take more bits (more precision, less</span>
<span style="color: #ff7f24;"> * underflow), do the desired operation and then "scale" the result back</span>
<span style="color: #ff7f24;"> * by the same amount.  If we do the scaling by shifting we avoid the</span>
<span style="color: #ff7f24;"> * costly mpy and the dastardly div instructions.</span>

<span style="color: #ff7f24;"> * Suppose, for example, we want to convert from seconds to jiffies</span>
<span style="color: #ff7f24;"> * where jiffies is defined in nanoseconds as NSEC_PER_JIFFIE.  The</span>
<span style="color: #ff7f24;"> * simple math is: jiff = (sec * NSEC_PER_SEC) / NSEC_PER_JIFFIE; We</span>
<span style="color: #ff7f24;"> * observe that (NSEC_PER_SEC / NSEC_PER_JIFFIE) is a constant which we</span>
<span style="color: #ff7f24;"> * might calculate at compile time, however, the result will only have</span>
<span style="color: #ff7f24;"> * about 3-4 bits of precision (less for smaller values of HZ).</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * So, we scale as follows:</span>
<span style="color: #ff7f24;"> * jiff = (sec) * (NSEC_PER_SEC / NSEC_PER_JIFFIE);</span>
<span style="color: #ff7f24;"> * jiff = ((sec) * ((NSEC_PER_SEC * SCALE)/ NSEC_PER_JIFFIE)) / SCALE;</span>
<span style="color: #ff7f24;"> * Then we make SCALE a power of two so:</span>
<span style="color: #ff7f24;"> * jiff = ((sec) * ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE)) &gt;&gt; SCALE;</span>
<span style="color: #ff7f24;"> * Now we define:</span>
<span style="color: #ff7f24;"> * #define SEC_CONV = ((NSEC_PER_SEC &lt;&lt; SCALE)/ NSEC_PER_JIFFIE))</span>
<span style="color: #ff7f24;"> * jiff = (sec * SEC_CONV) &gt;&gt; SCALE;</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * Often the math we use will expand beyond 32-bits so we tell C how to</span>
<span style="color: #ff7f24;"> * do this and pass the 64-bit result of the mpy through the "&gt;&gt; SCALE"</span>
<span style="color: #ff7f24;"> * which should take the result back to 32-bits.  We want this expansion</span>
<span style="color: #ff7f24;"> * to capture as much precision as possible.  At the same time we don't</span>
<span style="color: #ff7f24;"> * want to overflow so we pick the SCALE to avoid this.  In this file,</span>
<span style="color: #ff7f24;"> * that means using a different scale for each range of HZ values (as</span>
<span style="color: #ff7f24;"> * defined in timex.h).</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * For those who want to know, gcc will give a 64-bit result from a "*"</span>
<span style="color: #ff7f24;"> * operator if the result is a long long AND at least one of the</span>
<span style="color: #ff7f24;"> * operands is cast to long long (usually just prior to the "*" so as</span>
<span style="color: #ff7f24;"> * not to confuse it into thinking it really has a 64-bit operand,</span>
<span style="color: #ff7f24;"> * which, buy the way, it can do, but it takes more code and at least 2</span>
<span style="color: #ff7f24;"> * mpys).</span>

<span style="color: #ff7f24;"> * We also need to be aware that one second in nanoseconds is only a</span>
<span style="color: #ff7f24;"> * couple of bits away from overflowing a 32-bit word, so we MUST use</span>
<span style="color: #ff7f24;"> * 64-bits to get the full range time in nanoseconds.</span>

<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * Here are the scales we will use.  One for seconds, nanoseconds and</span>
<span style="color: #ff7f24;"> * microseconds.</span>
<span style="color: #ff7f24;"> *</span>
<span style="color: #ff7f24;"> * Within the limits of cpp we do a rough cut at the SEC_JIFFIE_SC and</span>
<span style="color: #ff7f24;"> * check if the sign bit is set.  If not, we bump the shift count by 1.</span>
<span style="color: #ff7f24;"> * (Gets an extra bit of precision where we can use it.)</span>
<span style="color: #ff7f24;"> * We know it is set for HZ = 1024 and HZ = 100 not for 1000.</span>
<span style="color: #ff7f24;"> * Haven't tested others.</span>

<span style="color: #ff7f24;"> * Limits of cpp (for #if expressions) only long (no long long), but</span>
<span style="color: #ff7f24;"> * then we only need the most signicant bit.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SEC_JIFFIE_SC</span> (31 - SHIFT_HZ)
<span style="color: #b0c4de;">#if</span> !((((NSEC_PER_SEC &lt;&lt; 2) / TICK_NSEC) &lt;&lt; (SEC_JIFFIE_SC - 2)) &amp; 0x80000000)
<span style="color: #b0c4de;">#undef</span> SEC_JIFFIE_SC
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SEC_JIFFIE_SC</span> (32 - SHIFT_HZ)
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NSEC_JIFFIE_SC</span> (SEC_JIFFIE_SC + 29)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">USEC_JIFFIE_SC</span> (SEC_JIFFIE_SC + 19)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SEC_CONVERSION</span> ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)((((<span style="color: #98fb98;">u64</span>)NSEC_PER_SEC &lt;&lt; SEC_JIFFIE_SC) +\
                                TICK_NSEC -1) / (<span style="color: #98fb98;">u64</span>)TICK_NSEC))

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NSEC_CONVERSION</span> ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)((((<span style="color: #98fb98;">u64</span>)1 &lt;&lt; NSEC_JIFFIE_SC) +\
                                        TICK_NSEC -1) / (<span style="color: #98fb98;">u64</span>)TICK_NSEC))
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">USEC_CONVERSION</span>  \
                    ((<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)((((<span style="color: #98fb98;">u64</span>)NSEC_PER_USEC &lt;&lt; USEC_JIFFIE_SC) +\
                                        TICK_NSEC -1) / (<span style="color: #98fb98;">u64</span>)TICK_NSEC))
<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * USEC_ROUND is used in the timeval to jiffie conversion.  See there</span>
<span style="color: #ff7f24;"> * for more details.  It is the scaled resolution rounding value.  Note</span>
<span style="color: #ff7f24;"> * that it is a 64-bit value.  Since, when it is applied, we are already</span>
<span style="color: #ff7f24;"> * in jiffies (albit scaled), it is nothing but the bits we will shift</span>
<span style="color: #ff7f24;"> * off.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">USEC_ROUND</span> (u64)(((<span style="color: #98fb98;">u64</span>)1 &lt;&lt; USEC_JIFFIE_SC) - 1)
<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * The maximum jiffie value is (MAX_INT &gt;&gt; 1).  Here we translate that</span>
<span style="color: #ff7f24;"> * into seconds.  The 64-bit case will overflow if we are not careful,</span>
<span style="color: #ff7f24;"> * so use the messy SH_DIV macro to do it.  Still all constants.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#if</span> BITS_PER_LONG &lt; 64
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">MAX_SEC_IN_JIFFIES</span> \
        (<span style="color: #98fb98;">long</span>)((<span style="color: #98fb98;">u64</span>)((<span style="color: #98fb98;">u64</span>)MAX_JIFFY_OFFSET * TICK_NSEC) / NSEC_PER_SEC)
<span style="color: #b0c4de;">#else</span>   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">take care of overflow on 64 bits machines </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">MAX_SEC_IN_JIFFIES</span> \
        (SH_DIV((MAX_JIFFY_OFFSET &gt;&gt; SEC_JIFFIE_SC) * TICK_NSEC, NSEC_PER_SEC, 1) - 1)

<span style="color: #b0c4de;">#endif</span>

&lt;linux/time.h&gt;
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Parameters used to convert the timespec values: </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MSEC_PER_SEC</span>    1000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">USEC_PER_MSEC</span>   1000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NSEC_PER_USEC</span>   1000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NSEC_PER_MSEC</span>   1000000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">USEC_PER_SEC</span>    1000000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">NSEC_PER_SEC</span>    1000000000L
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">FSEC_PER_SEC</span>    1000000000000000LL
</pre>



<ul>
<li id="sec-2-5-4-1">Ref<br/>



<pre class="src src-c">&lt;linux/jiffies.h&gt;
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">some arch's have a small-data section that can be accessed register-relative</span>
<span style="color: #ff7f24;"> * but that can only take up to, say, 4-byte variables. jiffies being part of</span>
<span style="color: #ff7f24;"> * an 8-byte variable may not be correctly accessed unless we force the issue</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">__jiffy_data</span>  <span style="color: #00ffff;">__attribute__</span>((section(<span style="color: #ffa07a;">".data"</span>)))

<span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * The 64-bit value is not atomic - you MUST NOT read it</span>
<span style="color: #ff7f24;"> * without sampling the sequence number in xtime_lock.</span>
<span style="color: #ff7f24;"> * get_jiffies_64() will do this for you as appropriate.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> u64 __jiffy_data jiffies_64;
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">__jiffy_data</span> <span style="color: #eedd82;">jiffies</span>;

<span style="color: #b0c4de;">#if</span> (BITS_PER_LONG &lt; 64)
<span style="color: #98fb98;">u64</span> <span style="color: #87cefa;">get_jiffies_64</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #b0c4de;">#else</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">u64</span> <span style="color: #87cefa;">get_jiffies_64</span>(<span style="color: #98fb98;">void</span>)
{
        <span style="color: #00ffff;">return</span> (<span style="color: #98fb98;">u64</span>)jiffies;
}
<span style="color: #b0c4de;">#endif</span>
</pre>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/param.h&gt;</span>                  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">for HZ </span><span style="color: #ff7f24;">*/</span>

<span style="color: #b0c4de;">#ifdef</span> __KERNEL__
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">HZ</span>             CONFIG_HZ       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Internal kernel timer frequency </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">USER_HZ</span>        100             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">User interfaces are in "ticks" </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">CLOCKS_PER_SEC</span> (USER_HZ)       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">like times() </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">HZ</span>             100
<span style="color: #b0c4de;">#endif</span>
</pre>


<p>
In <code>dm816x_defconfig</code>
</p>


<pre class="src src-sh"><span style="color: #eedd82;">CONFIG_HZ</span>=100
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-5-5">Sleeping<br/>
    <b>chapter 6.2</b>
<ol>
<li>The first of these rules is: never sleep when you are running in an
   atomic context. An atomic context is simply a state where multiple
   steps must be performed without any sort of concurrent access. What
   that means, with regard to sleeping, is that your driver cannot
   sleep while holding a spinlock, seqlock, or RCU lock. You also
   cannot sleep if you have disabled interrupts. It is legal to sleep
   while holding a semaphore, but you should look very carefully at
   any code that does so.
</li>
<li>Another thing to remember with sleeping is that, when you wake up,
   you never know how long your process may have been out of the CPU
   or what may have changed in the mean time. You also do not usually
   know if another process may have been sleeping for the same event;
   that process may wake before you and grab whatever resource you
   were waiting for. 
</li>
<li>One other relevant point, of course, is that your process cannot
   sleep unless it is assured that somebody else, somewhere, will wake
   it up. 
</li>
</ol>


<p>
In Linux, a wait queue is managed by means of a "wait queue head," a
structure of type <code>wait_queue_head_t</code>, which is defined in
&lt;linux/wait.h&gt;. A wait queue head can be defined and initialized
statically with:
</p>


<pre class="src src-c">DECLARE_WAIT_QUEUE_HEAD(name);
</pre>


<p>
or dynamicly as follows:
</p>


<pre class="src src-c"><span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">my_queue</span>;
init_waitqueue_head(&amp;my_queue);
</pre>



<ul>
<li id="sec-2-5-5-1">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/wait.h&gt;</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">... </span><span style="color: #ff7f24;">*/</span> } <span style="color: #98fb98;">wait_queue_head_t</span>;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">init_waitqueue_head</span>(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>);

DECLARE_WAIT_QUEUE_HEAD(queue);
    The <span style="color: #98fb98;">defined</span> <span style="color: #87cefa;">type</span> <span style="color: #00ffff;">for</span> Linux wait queues. A wait_queue_head_t must
    be explicitly initialized with either init_waitqueue_head at
    runtime or DECLARE_WAIT_QUEUE_HEAD at compile time.

<span style="color: #98fb98;">void</span> wait_event(<span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">condition</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">wait_event_interruptible</span>(<span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">condition</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">wait_event_timeout</span>(<span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">condition</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">wait_event_interruptible_timeout</span>(<span style="color: #98fb98;">wait_queue_head_t</span> <span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">condition</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">time</span>);
    Cause the process to sleep on the given queue until the given condition evaluates <span style="color: #98fb98;">to</span> <span style="color: #87cefa;">a</span> <span style="color: #7fffd4;">true</span> value.

<span style="color: #98fb98;">void</span> wake_up(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_interruptible</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_nr</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nr</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_interruptible_nr</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nr</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_all</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_interruptible_all</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">wake_up_interruptible_sync</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">wait_queue_head_t</span> **<span style="color: #eedd82;">q</span>);
    Wake processes that are sleeping on the <span style="color: #98fb98;">queue</span> <span style="color: #eedd82;">q</span>. The _interruptible form wakes only interruptible processes. Normally, <span style="color: #eedd82;">only</span> one exclusive waiter is awakened, <span style="color: #87cefa;">but</span> that behavior can be changed with the _nr or _all forms. The _sync version does not reschedule the CPU before returning.

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/sched.h&gt;</span>
set_current_state(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state</span>);
    Sets the execution state of the <span style="color: #98fb98;">current</span> <span style="color: #eedd82;">process</span>. TASK_RUNNING means it is ready to run, <span style="color: #00ffff;">while</span> the sleep states are TASK_INTERRUPTIBLE and TASK_UNINTERRUPTIBLE.

<span style="color: #98fb98;">void</span> schedule(<span style="color: #98fb98;">void</span>);
    Selects a runnable process from the <span style="color: #98fb98;">run</span> <span style="color: #eedd82;">queue</span>. The chosen process can be current or a different one.

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">... </span><span style="color: #ff7f24;">*/</span> } wait_queue_t;
init_waitqueue_entry(<span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">entry</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">task_struct</span> *<span style="color: #eedd82;">task</span>);
    The wait_queue_t type is used <span style="color: #98fb98;">to</span> place a process onto a <span style="color: #98fb98;">wait</span> <span style="color: #87cefa;">queue</span>.

<span style="color: #98fb98;">void</span> prepare_to_wait(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">wait</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">prepare_to_wait_exclusive</span>(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">wait</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">finish_wait</span>(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">wait</span>);
    Helper functions that can be used <span style="color: #98fb98;">to</span> code a <span style="color: #98fb98;">manual</span> <span style="color: #87cefa;">sleep</span>.

<span style="color: #98fb98;">void</span> sleep_on(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">interruptible_sleep_on</span>(<span style="color: #98fb98;">wait_queue_head_t</span> *<span style="color: #eedd82;">queue</span>);
    Obsolete and deprecated functions that unconditionally put the <span style="color: #98fb98;">current</span> process <span style="color: #98fb98;">to</span> <span style="color: #eedd82;">sleep</span>.
</pre>

</li>
</ul>
<ul>
<li id="sec-2-5-5-2">Ref<br/>



<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">__wait_queue</span> <span style="color: #98fb98;">wait_queue_t</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> (*<span style="color: #98fb98;">wait_queue_func_t</span>)(<span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">wait</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">mode</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">key</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">default_wake_function</span>(<span style="color: #98fb98;">wait_queue_t</span> *<span style="color: #eedd82;">wait</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">mode</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">key</span>);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">__wait_queue</span> {
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">flags</span>;
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">WQ_FLAG_EXCLUSIVE</span>       0x01
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">private</span>;
        <span style="color: #98fb98;">wait_queue_func_t</span> <span style="color: #eedd82;">func</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">task_list</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">__wait_queue_head</span> {
        <span style="color: #98fb98;">spinlock_t</span> <span style="color: #eedd82;">lock</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">task_list</span>;
};
<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">__wait_queue_head</span> <span style="color: #98fb98;">wait_queue_head_t</span>;
</pre>

</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-5-6">Tasklets<br/>
 <b>chapter 7.5</b>
A tasklet exists as a data structure that must be initialized before
use. Initialization can be performed by calling a specific function or
by declaring the structure using certain macros:



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/interrupt.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> {
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">... </span><span style="color: #ff7f24;">*/</span>
      <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">func</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
      <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>;
};

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">tasklet_init</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">func</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>), <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>);
DECLARE_TASKLET(name, func, data);
DECLARE_TASKLET_DISABLED(name, func, data);
</pre>


<p>
Tasklets offer a number of interesting features:
</p><ul>
<li>A tasklet can be disabled and re-enabled later; it won't be executed until it is enabled as many times as it has been disabled.
</li>
<li>Just like timers, a tasklet can reregister itself.
</li>
<li>A tasklet can be scheduled to execute at normal priority or high priority. The latter group is always executed first.
</li>
<li>Tasklets may be run immediately if the system is not under heavy load but never later than the next timer tick.
</li>
<li>A tasklets can be concurrent with other tasklets but is strictly
  serialized with respect to itself—the same tasklet never runs
     simultaneously on more than one processor. Also, as already
     noted, a tasklet always runs on the same CPU that schedules it.
</li>
</ul>



<ul>
<li id="sec-2-5-6-1">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/interrupt.h&gt;</span>
DECLARE_TASKLET(name, func, data);
DECLARE_TASKLET_DISABLED(name, func, data);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">tasklet_init</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">func</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>), <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>);
    The first two macros declare a <span style="color: #98fb98;">tasklet</span> <span style="color: #eedd82;">structure</span>, <span style="color: #00ffff;">while</span> the
tasklet_init function initializes a tasklet structure that has been
obtained by allocation or other means. The second DECLARE macro marks
the tasklet as disabled.

<span style="color: #98fb98;">void</span> tasklet_disable(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">tasklet_disable_nosync</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">tasklet_enable</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
    Disables and reenables <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">tasklet</span>. Each disable must be matched
with an enable (you can disable the <span style="color: #98fb98;">tasklet</span> <span style="color: #eedd82;">even</span> <span style="color: #00ffff;">if</span> it<span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s already</span>
<span style="color: #ffa07a;">disabled). The function tasklet_disable waits for the tasklet to</span>
<span style="color: #ffa07a;">terminate if it is running on another CPU. The nosync version doesn'</span>t
take this extra step.

<span style="color: #98fb98;">void</span> tasklet_schedule(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">tasklet_hi_schedule</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
    Schedules <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">tasklet</span> <span style="color: #98fb98;">to</span> <span style="color: #eedd82;">run</span>, <span style="color: #eedd82;">either</span> as a <span style="color: #ffa07a;">"normal"</span> tasklet or a
high-priority one. When soft interrupts are executed, <span style="color: #eedd82;">high</span>-priority
tasklets are dealt with first, <span style="color: #00ffff;">while</span> normal tasklets run last.

<span style="color: #98fb98;">void</span> tasklet_kill(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);
    Removes the <span style="color: #98fb98;">tasklet</span> from the list of <span style="color: #98fb98;">active</span> <span style="color: #eedd82;">ones</span>, <span style="color: #00ffff;">if</span> it<span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s</span>
<span style="color: #ffa07a;">    scheduled to run. Like tasklet_disable, the function may block on</span>
<span style="color: #ffa07a;">    SMP systems waiting for the tasklet to terminate if it'</span>s currently
    running on another CPU.
</pre>


</li>
</ul>
<ul>
<li id="sec-2-5-6-2">Ref<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/interrupt.h&gt;</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Tasklets --- multithreaded analogue of BHs.</span>

<span style="color: #ff7f24;">   Main feature differing them of generic softirqs: tasklet</span>
<span style="color: #ff7f24;">   is running only on one CPU simultaneously.</span>

<span style="color: #ff7f24;">   Main feature differing them of BHs: different tasklets</span>
<span style="color: #ff7f24;">   may be run simultaneously on different CPUs.</span>

<span style="color: #ff7f24;">   Properties:</span>
<span style="color: #ff7f24;">   * If tasklet_schedule() is called, then tasklet is guaranteed</span>
<span style="color: #ff7f24;">     to be executed on some cpu at least once after this.</span>
<span style="color: #ff7f24;">   * If the tasklet is already scheduled, but its excecution is still not</span>
<span style="color: #ff7f24;">     started, it will be executed only once.</span>
<span style="color: #ff7f24;">   * If this tasklet is already running on another CPU (or schedule is called</span>
<span style="color: #ff7f24;">     from tasklet itself), it is rescheduled for later.</span>
<span style="color: #ff7f24;">   * Tasklet is strictly serialized wrt itself, but not</span>
<span style="color: #ff7f24;">     wrt another tasklets. If client needs some intertask synchronization,</span>
<span style="color: #ff7f24;">     he makes it with spinlocks.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span>
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">next</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">state</span>;
        <span style="color: #98fb98;">atomic_t</span> <span style="color: #eedd82;">count</span>;
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">func</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">DECLARE_TASKLET</span>(<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">func</span>, <span style="color: #eedd82;">data</span>) \
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> <span style="color: #eedd82;">name</span> = { <span style="color: #7fffd4;">NULL</span>, 0, ATOMIC_INIT(0), func, data }

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">DECLARE_TASKLET_DISABLED</span>(<span style="color: #eedd82;">name</span>, <span style="color: #eedd82;">func</span>, <span style="color: #eedd82;">data</span>) \
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> <span style="color: #eedd82;">name</span> = { <span style="color: #7fffd4;">NULL</span>, 0, ATOMIC_INIT(1), func, data }
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-5-7">Workqueues<br/>
 <b>chapter 7.6</b>
 The key difference between the two is that tasklets execute quickly,
 for a short period of time, and in atomic mode, while workqueue
 functions may have higher latency but need not be atomic. Each
 mechanism has situations where it is appropriate.
<ul>
<li id="sec-2-5-7-1">Normal queue<br/>
<ol>
<li>create a workqueue
 Workqueues have a type of struct workqueue<sub>struct</sub>, which is defined in
 <code>&lt;linux/workqueue.h&gt;</code>. A workqueue must be explicitly created before
 use, using one of the following two functions:
</li>
</ol>




<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #87cefa;">create_workqueue</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #87cefa;">create_singlethread_workqueue</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>);
</pre>


<ol>
<li>submit a task to a workqueue
<ul>
<li>To submit a task to a workqueue, you need to fill in a work<sub>struct</sub>
    structure. This can be done at compile time as follows:
</li>
</ul>

</li>
</ol>




<pre class="src src-c">DECLARE_WORK(name, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>);
</pre>

<ul>
<li>If you need to set up the work<sub>struct</sub> structure at runtime, use the following two macros:
</li>
</ul>




<pre class="src src-c">INIT_WORK(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>);
PREPARE_WORK(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *), <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">data</span>);
</pre>

<ul>
<li>There are two functions for submitting work to a workqueue:
</li>
</ul>




<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">queue_work</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">queue_delayed_work</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">delay</span>);
</pre>


<ol>
<li>cancel a pending workqueue entry
</li>
</ol>




<pre class="src src-c">Should you need to cancel a pending <span style="color: #98fb98;">workqueue</span> <span style="color: #eedd82;">entry</span>, <span style="color: #87cefa;">you</span> may call:
<span style="color: #98fb98;">int</span> cancel_delayed_work(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);

To be absolutely sure that the work function is not running anywhere in the system after <span style="color: #98fb98;">cancel_delayed_work</span> <span style="color: #eedd82;">returns</span> 0, <span style="color: #87cefa;">you</span> must follow that call with a call to:
<span style="color: #98fb98;">void</span> flush_workqueue(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>);
</pre>


<ol>
<li>destroy a workqueue
</li>
</ol>




<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">destroy_workqueue</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>);
</pre>

</li>
</ul>
<ul>
<li id="sec-2-5-7-2">Shared Queue<br/>
If you only submit tasks to the queue occasionally, it may be more
efficient to simply use the shared, default workqueue that is provided
by the kernel. If you use this queue, however, you must be aware that
you will be sharing it with others. 




<pre class="src src-c">prepare_to_wait(&amp;jiq_wait, &amp;wait, TASK_INTERRUPTIBLE);
schedule_work(&amp;jiq_work);
schedule(  );
finish_wait(&amp;jiq_wait, &amp;wait);
</pre>

</li>
</ul>
<ul>
<li id="sec-2-5-7-3">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/workqueue.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span>;
    The structures representing a workqueue and a <span style="color: #98fb98;">work</span> <span style="color: #eedd82;">entry</span>, <span style="color: #87cefa;">respectively</span>.

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *create_workqueue(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #87cefa;">create_singlethread_workqueue</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">destroy_workqueue</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>);
    Functions <span style="color: #00ffff;">for</span> creating and destroying workqueues. A call to create_workqueue creates a queue with a worker thread on each processor in the system; instead, create_singlethread_workqueue creates a workqueue with a single <span style="color: #98fb98;">worker</span> <span style="color: #87cefa;">process</span>.

DECLARE_WORK(name, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *));
INIT_WORK(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *);
PREPARE_WORK(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">function</span>)(<span style="color: #98fb98;">void</span> *));
    Macros that declare and initialize <span style="color: #98fb98;">workqueue</span> <span style="color: #eedd82;">entries</span>.

<span style="color: #98fb98;">int</span> queue_work(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">queue_delayed_work</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">delay</span>);
    Functions that <span style="color: #98fb98;">queue</span> <span style="color: #eedd82;">work</span> <span style="color: #00ffff;">for</span> execution from a workqueue.

bool cancel_delayed_work_sync(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> *<span style="color: #eedd82;">dwork</span>);
<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">flush_workqueue</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">queue</span>);
    Use cancel_delayed_work to remove an entry from <span style="color: #98fb98;">a</span> <span style="color: #eedd82;">workqueue</span>; flush_workqueue ensures that no <span style="color: #98fb98;">workqueue</span> entries are running anywhere in <span style="color: #98fb98;">the</span> <span style="color: #eedd82;">system</span>.

<span style="color: #98fb98;">int</span> schedule_work(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">schedule_delayed_work</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> *<span style="color: #eedd82;">work</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">delay</span>);
<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">flush_scheduled_work</span>(<span style="color: #98fb98;">void</span>);
    Functions <span style="color: #00ffff;">for</span> working with the shared workqueue.
</pre>


</li>
</ul>
<ul>
<li id="sec-2-5-7-4">Ref<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/workqueue.h&gt;</span>

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">void</span> (*<span style="color: #98fb98;">work_func_t</span>)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> *<span style="color: #eedd82;">work</span>);

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> {
        <span style="color: #98fb98;">atomic_long_t</span> <span style="color: #eedd82;">data</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">entry</span>;
        <span style="color: #98fb98;">work_func_t</span> <span style="color: #eedd82;">func</span>;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_LOCKDEP
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">lockdep_map</span> <span style="color: #eedd82;">lockdep_map</span>;
<span style="color: #b0c4de;">#endif</span>
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">delayed_work</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">work_struct</span> <span style="color: #eedd82;">work</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> <span style="color: #eedd82;">timer</span>;
};

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">create_workqueue</span>(<span style="color: #eedd82;">name</span>)                                  \
        alloc_workqueue((name), WQ_MEM_RECLAIM, 1)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">create_freezeable_workqueue</span>(<span style="color: #eedd82;">name</span>)                       \
        alloc_workqueue((name), WQ_FREEZEABLE | WQ_UNBOUND | WQ_MEM_RECLAIM, 1)
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">create_singlethread_workqueue</span>(<span style="color: #eedd82;">name</span>)                     \
        alloc_workqueue((name), WQ_UNBOUND | WQ_MEM_RECLAIM, 1)

<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">destroy_workqueue</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">workqueue_struct</span> *<span style="color: #eedd82;">wq</span>);



</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-5-8">Kernel Timers<br/>
 <b>Chapter 7.4</b>
A kernel timer is a data structure that instructs the kernel to
execute a user-defined function with a user-defined argument at a
user-defined time. The implementation resides in <code>&lt;linux/timer.h&gt;</code> and
<code>kernel/timer.c</code>.

<p>
In fact, kernel timers are run as the result of a "software
interrupt." When running in this sort of atomic context, your code is
subject to a number of constraints. Timer functions must be atomic in
all the ways
</p>
<p>
A number of actions require the context of a process in order to be
executed. When you are outside of process context (i.e., in interrupt
context), you must observe the following rules:
</p>
<ul>
<li>No access to user space is allowed. Because there is no process context, there is no path to the user space associated with any particular process.
</li>
<li>The current pointer is not meaningful in atomic mode and cannot be used since the relevant code has no connection with the process that has been interrupted.
</li>
<li>No sleeping or scheduling may be performed. Atomic code may not
     call schedule or a form of wait<sub>event</sub>, nor may it call any other
     function that could sleep. For example, calling kmalloc(&hellip;,
     GFP<sub>KERNEL</sub>) is against the rules. Semaphores also must not be
     used since they can sleep
</li>
</ul>


<p>
Kernel code can tell if it is running in interrupt context by calling
the function <code>in_interrupt( )</code>, which takes no parameters and returns
nonzero if the processor is currently running in interrupt context,
either hardware interrupt or software interrupt.
</p>
<ul>
<li id="sec-2-5-8-1">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/hardirq.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">in_interrupt</span>(<span style="color: #98fb98;">void</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">in_atomic</span>(<span style="color: #98fb98;">void</span>);
    Returns a Boolean value telling whether the calling code is executing in interrupt context or <span style="color: #98fb98;">atomic</span> <span style="color: #eedd82;">context</span>. Interrupt context is outside of a process context, <span style="color: #eedd82;">either</span> during hardware or software interrupt processing. Atomic context is when you can<span style="color: #ffa07a;">'t schedule either an interrupt context or a process'</span>s context with a spinlock held.

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/timer.h&gt;</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> {
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">... </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">expires</span>;
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">function</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>;
};
The expires field represents the jiffies value when the timer is
        expected <span style="color: #98fb98;">to</span> <span style="color: #eedd82;">run</span>; at <span style="color: #98fb98;">that</span> <span style="color: #eedd82;">time</span>, <span style="color: #87cefa;">the</span> function function is called
        with data as an argument.


<span style="color: #98fb98;">void</span> init_timer(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> * <span style="color: #eedd82;">timer</span>);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> <span style="color: #87cefa;">TIMER_INITIALIZER</span>(_function, _expires, _data);
    This function and the <span style="color: #00ffff;">static</span> declaration of the timer structure are the two ways <span style="color: #98fb98;">to</span> initialize a <span style="color: #98fb98;">timer_list</span> <span style="color: #98fb98;">data</span> <span style="color: #87cefa;">structure</span>.

<span style="color: #98fb98;">void</span> add_timer(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> * <span style="color: #eedd82;">timer</span>);
    Registers the timer structure <span style="color: #98fb98;">to</span> run on the <span style="color: #98fb98;">current</span> <span style="color: #87cefa;">CPU</span>.

<span style="color: #98fb98;">int</span> mod_timer(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> *<span style="color: #eedd82;">timer</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">expires</span>);
    Changes the expiration time of an already scheduled <span style="color: #98fb98;">timer</span> <span style="color: #87cefa;">structure</span>. It can also act as an alternative to add_timer.

<span style="color: #98fb98;">int</span> timer_pending(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> * <span style="color: #eedd82;">timer</span>);
Macro <span style="color: #98fb98;">that</span> returns a Boolean value stating whether the <span style="color: #98fb98;">timer</span> structure is already registered <span style="color: #98fb98;">to</span> <span style="color: #87cefa;">run</span>.

<span style="color: #98fb98;">void</span> del_timer(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> * <span style="color: #eedd82;">timer</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">del_timer_sync</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> * <span style="color: #eedd82;">timer</span>);
    Removes a <span style="color: #98fb98;">timer</span> from the list of <span style="color: #98fb98;">active</span> <span style="color: #eedd82;">timers</span>. The latter function ensures that the timer is not currently running on another CPU.
</pre>

</li>
</ul>
<ul>
<li id="sec-2-5-8-2">Ref<br/>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timer_list</span> {
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * All fields that change during normal runtime grouped to the</span>
<span style="color: #ff7f24;">         * same cacheline</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">list_head</span> <span style="color: #eedd82;">entry</span>;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">expires</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tvec_base</span> *<span style="color: #eedd82;">base</span>;

        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">function</span>)(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>);
        <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">data</span>;

        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">slack</span>;

<span style="color: #b0c4de;">#ifdef</span> CONFIG_TIMER_STATS
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">start_site</span>;
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">start_comm</span>[16];
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">start_pid</span>;
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#ifdef</span> CONFIG_LOCKDEP
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">lockdep_map</span> <span style="color: #eedd82;">lockdep_map</span>;
<span style="color: #b0c4de;">#endif</span>
};
</pre>



</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><code>kdataalign.c</code></h3>
<div class="outline-text-3" id="text-2-6">

<ul>
<li id="sec-2-6-1">error and fix<br/>
<ul>
<li>error
</li>
</ul>




<pre class="src src-sh">error: &#8216;system_utsname&#8217; undeclared (first use<span style="color: #00ffff;"> in</span> this <span style="color: #00ffff;">function</span>)
</pre>

<ul>
<li>fix
</li>
</ul>




<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">system_utsname</span> init_uts_ns.name
</pre>

<p>
 Ref:
</p>


<pre class="src src-c">&lt;linux/utsname.h&gt;
<span style="color: #00ffff;">extern</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uts_namespace</span> init_uts_ns;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">uts_namespace</span> {
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kref</span> <span style="color: #eedd82;">kref</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">new_utsname</span> <span style="color: #eedd82;">name</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">new_utsname</span> {
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">sysname</span>[__NEW_UTS_LEN + 1];
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">nodename</span>[__NEW_UTS_LEN + 1];
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">release</span>[__NEW_UTS_LEN + 1];
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">version</span>[__NEW_UTS_LEN + 1];
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">machine</span>[__NEW_UTS_LEN + 1];
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">domainname</span>[__NEW_UTS_LEN + 1];
};
</pre>


</li>
</ul>
<ul>
<li id="sec-2-6-2">Test<br/>
<ul>
<li id="sec-2-6-2-1">align of char<br/>
<ul>
<li>SRC
</li>
</ul>




<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">c</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">c</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">short</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">s</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">i</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">int</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">i</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">long</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">l</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ll</span>  {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">ll</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">p</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">void</span> *    <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">p</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u1b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u8</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u1b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u2b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u16</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u2b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u4b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u32</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u4b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u8b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u64</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u8b</span>;

(<span style="color: #98fb98;">int</span>)((<span style="color: #98fb98;">void</span> *)(&amp;c.t)   - (<span style="color: #98fb98;">void</span> *)&amp;c),
</pre>

<ul>
<li>Result
</li>
</ul>




<pre class="src src-sh">[19232.053968] arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
[19232.053972] i686            1     2     4     4     4     4        1   2   4   4
</pre>


</li>
</ul>
<ul>
<li id="sec-2-6-2-2">align of other type<br/>
<ul>
<li>SRC
</li>
</ul>




<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">c2</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">c2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s2</span>   {<span style="color: #98fb98;">short</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">s2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">i2</span>   {<span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">i2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l2</span>   {<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">l2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ll2</span>  {<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>  <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">ll2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">p2</span>   {<span style="color: #98fb98;">void</span> * <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>  <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">p2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u1b2</span> {<span style="color: #98fb98;">__u8</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u1b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u2b2</span> {<span style="color: #98fb98;">__u16</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u2b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u4b2</span> {<span style="color: #98fb98;">__u32</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u4b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u8b2</span> {<span style="color: #98fb98;">__u64</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u8b2</span>;
        (<span style="color: #98fb98;">int</span>)((<span style="color: #98fb98;">void</span> *)(&amp;c2.t)   - (<span style="color: #98fb98;">void</span> *)&amp;c2),
</pre>

<ul>
<li>Result
</li>
</ul>




<pre class="src src-sh">[20443.346930] arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
[20443.346933] i686            1     2     4     4     4     8        1   2   4   8
</pre>

</li>
</ul>
<ul>
<li id="sec-2-6-2-3">compare<br/>



<pre class="src src-sh">[20443.346924] arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
[20443.346929] i686  char      1     2     4     4     4     4        1   2   4   4
[20443.346930] arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
[20443.346933] i686  Other     1     2     4     4     4     8        1   2   4   8
</pre>

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><code>kdatasize.c</code></h3>
<div class="outline-text-3" id="text-2-7">




<pre class="src src-c">(<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">short</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>),
                (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span>),
                (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">void</span> *), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u8),
                (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u16), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u32), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u64));
</pre>


<pre class="src src-sh">[19790.346939] arch   Size:  char  short  int  long   ptr long-long  u8 u16 u32 u64
[19790.346946] i686            1     2     4     4     4     8        1   2   4   8
</pre>


</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><code>sleepy.c</code></h3>
<div class="outline-text-3" id="text-2-8">

<ul>
<li>SRC
</li>
</ul>




<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #98fb98;">DECLARE_WAIT_QUEUE_HEAD</span>(<span style="color: #eedd82;">wq</span>);

wait_event_interruptible(wq, flag != 0);

wake_up_interruptible(&amp;wq);
</pre>


<ul>
<li>Test
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sudo insmod sleepy.ko</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">sudo mknod -m og+rw  /dev/sleepy c  XXX 0</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /dev/sleepy</span>
<span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">echo "X" &gt; /dev/sleepy</span>

[11010.693929] process 4770 (cat) going to sleep
[11063.180845] process 4772 (zsh) awakening the readers...
[11063.180861] awoken 4770 (cat)
</pre>


</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9"><code>jit.c</code></h3>
<div class="outline-text-3" id="text-2-9">

<ul>
<li id="sec-2-9-1">Error and Fix<br/>



<pre class="src src-sh">jit.c: In <span style="color: #00ffff;">function</span> &#8216;jit_fn&#8217;:
jit.c:73: error: implicit declaration of <span style="color: #00ffff;">function</span> &#8216;schedule&#8217;
jit.c:77: error: &#8216;TASK_INTERRUPTIBLE&#8217; undeclared (first use<span style="color: #00ffff;"> in</span> this <span style="color: #00ffff;">function</span>)
jit.c:77: error: (Each undeclared identifier is reported only once
jit.c:77: error: for each <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">it</span> appears in.)
jit.c:77: error: implicit declaration of <span style="color: #00ffff;">function</span> &#8216;signal_pending&#8217;
jit.c:77: error: implicit declaration of <span style="color: #00ffff;">function</span> &#8216;schedule_timeout&#8217;
jit.c:80: error: implicit declaration of <span style="color: #00ffff;">function</span> &#8216;set_current_state&#8217;
</pre>

<ul>
<li>Fix
</li>
</ul>




<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;linux/sched.h&gt;</span>
</pre>




</li>
</ul>
<ul>
<li id="sec-2-9-2"><code>tasklet_hi_schedule</code><br/>
 <b>chapter 7.5</b>
<ul>
<li id="sec-2-9-2-1">API<br/>



<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">tasklet_hi_schedule</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tasklet_struct</span> *<span style="color: #eedd82;">t</span>);

Schedule <span style="color: #98fb98;">the</span> <span style="color: #eedd82;">tasklet</span> <span style="color: #00ffff;">for</span> execution with higher priority. When the soft interrupt
handler runs, <span style="color: #eedd82;">it</span> deals with high-priority tasklets before other soft interrupt tasks,
<span style="color: #eedd82;">including</span> &#8220;normal&#8221; tasklets. Ideally, <span style="color: #87cefa;">only</span> tasks with low-latency requirements
(such as filling <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">audio</span> <span style="color: #eedd82;">buffer</span>) should use <span style="color: #98fb98;">this</span> <span style="color: #eedd82;">function</span>, <span style="color: #eedd82;">to</span> avoid the additional
latencies introduced by other soft interrupt handlers. Actually, /proc/
jitasklethi shows no human-visible difference from /proc/jitasklet.
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-9-3">Test<br/>
<ul>
<li><code>/proc/currentime</code>
</li>
</ul>




<pre class="src src-sh">0x00a7d291 0x0000000100a7d291 1350830993.423880
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423881
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423882
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423883
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423885
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423886
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423887
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423888
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423890
                              1350830993.423499790
0x00a7d291 0x0000000100a7d291 1350830993.423891
                              1350830993.423499790
</pre>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timeval</span> <span style="color: #eedd82;">tv1</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> <span style="color: #eedd82;">tv2</span>;
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">j1</span>;
<span style="color: #98fb98;">u64</span> <span style="color: #eedd82;">j2</span>;

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">get them four </span><span style="color: #ff7f24;">*/</span>
j1 = jiffies;
j2 = get_jiffies_64();
do_gettimeofday(&amp;tv1);
tv2 = current_kernel_time();

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">print </span><span style="color: #ff7f24;">*/</span>
len=0;
len += sprintf(buf,<span style="color: #ffa07a;">"0x%08lx 0x%016Lx %10i.%06i\n"</span>
               <span style="color: #ffa07a;">"%40i.%09i\n"</span>,
               j1, j2,
               (<span style="color: #98fb98;">int</span>) tv1.tv_sec, (<span style="color: #98fb98;">int</span>) tv1.tv_usec,
               (<span style="color: #98fb98;">int</span>) tv2.tv_sec, (<span style="color: #98fb98;">int</span>) tv2.tv_nsec);
</pre>

<ul>
<li><code>/proc/jitbusy</code>
 <b>chapter 7.3</b>
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">dd bs=20 count=5 &lt; /proc/jitbusy</span>
 11160469  11160719
 11160719  11160969
 11160969  11161219
 11161219  11161469
 11161469  11161719
</pre>



<pre class="src src-c">j0 = jiffies;
j1 = j0 + delay;

<span style="color: #00ffff;">while</span> (time_before(jiffies, j1))
  cpu_relax();
</pre>

<ul>
<li><code>/proc/jitsched</code>
</li>
</ul>




<pre class="src src-sh">dd <span style="color: #eedd82;">bs</span>=20 <span style="color: #eedd82;">count</span>=5 &lt; /proc/jitsched
 20901444  20901694
 20901694  20901944
 20901944  20902194
 20902194  20902444
 20902444  20902694
</pre>



<pre class="src src-c">  j0 = jiffies;
  j1 = j0 + delay;

<span style="color: #00ffff;">while</span> (time_before(jiffies, j1)) {
  schedule();
 }
</pre>


<ul>
<li><code>/proc/jitqueue</code>
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">dd bs=20 count=5 &lt; /proc/jitqueue </span>
 20928572  20928822
 20928822  20929072
 20929072  20929322
 20929322  20929572
 20929572  20929822
</pre>



<pre class="src src-c">wait_event_interruptible_timeout(wait, 0, delay);
</pre>


<ul>
<li><code>/proc/jitschedto</code>
</li>
</ul>




<pre class="src src-sh">dd <span style="color: #eedd82;">bs</span>=20 <span style="color: #eedd82;">count</span>=5 &lt; /proc/jitschedto 
20955019  20955269
20955269  20955519
20955519  20955769
20955769  20956019
20956019  20956269
</pre>



<pre class="src src-c">set_current_state(TASK_INTERRUPTIBLE);
schedule_timeout (delay);
</pre>


<ul>
<li><code>/proc/jitimer</code>
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/jitimer </span>
   <span style="color: #b0c4de;">time</span>   delta  inirq    pid   cpu command
 20978101    0     0     19300   5   cat
 20978111   10     1         0   5   swapper
 20978121   10     1         0   5   swapper
 20978131   10     1         0   5   swapper
 20978141   10     1         0   5   swapper
 20978151   10     1         0   5   swapper
</pre>



<pre class="src src-c">init_timer(&amp;data-&gt;timer);
init_waitqueue_head (&amp;data-&gt;wait);
data-&gt;loops = JIT_ASYNC_LOOPS;

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">register the timer </span><span style="color: #ff7f24;">*/</span>
data-&gt;timer.data = (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)data;
data-&gt;timer.function = jit_timer_fn;
data-&gt;timer.expires = j + tdelay; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parameter </span><span style="color: #ff7f24;">*/</span>
add_timer(&amp;data-&gt;timer);

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">wait for the buffer to fill </span><span style="color: #ff7f24;">*/</span>
wait_event_interruptible(data-&gt;wait, !data-&gt;loops);
</pre>


<ul>
<li><code>/proc/jitasklet</code>
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/jitasklet</span>
   <span style="color: #b0c4de;">time</span>   delta  inirq    pid   cpu command
 21042512    0     0     19332   6   cat
 21042512    0     1        22   6   ksoftirqd/6
 21042512    0     1        22   6   ksoftirqd/6
 21042512    0     1        22   6   ksoftirqd/6
 21042512    0     1        22   6   ksoftirqd/6
 21042512    0     1        22   6   ksoftirqd/6
</pre>



<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">register the tasklet </span><span style="color: #ff7f24;">*/</span>
tasklet_init(&amp;data-&gt;tlet, jit_tasklet_fn, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)data);
data-&gt;hi = hi;
<span style="color: #00ffff;">if</span> (hi)
  tasklet_hi_schedule(&amp;data-&gt;tlet);
 <span style="color: #00ffff;">else</span>
   tasklet_schedule(&amp;data-&gt;tlet);

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">wait for the buffer to fill </span><span style="color: #ff7f24;">*/</span>
wait_event_interruptible(data-&gt;wait, !data-&gt;loops);
</pre>


<ul>
<li><code>/proc/jitasklethi</code>
</li>
</ul>




<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/jitasklethi </span>
   <span style="color: #b0c4de;">time</span>   delta  inirq    pid   cpu command
 21047810    0     0     19340   6   cat
 21047810    0     1        22   6   ksoftirqd/6
 21047810    0     1        22   6   ksoftirqd/6
 21047810    0     1        22   6   ksoftirqd/6
 21047810    0     1        22   6   ksoftirqd/6
 21047810    0     1        22   6   ksoftirqd/6
</pre>



<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">register the tasklet </span><span style="color: #ff7f24;">*/</span>
tasklet_init(&amp;data-&gt;tlet, jit_tasklet_fn, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)data);
data-&gt;hi = hi;
<span style="color: #00ffff;">if</span> (hi)
  tasklet_hi_schedule(&amp;data-&gt;tlet);
 <span style="color: #00ffff;">else</span>
   tasklet_schedule(&amp;data-&gt;tlet);

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">wait for the buffer to fill </span><span style="color: #ff7f24;">*/</span>
wait_event_interruptible(data-&gt;wait, !data-&gt;loops);
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-2-10" class="outline-3">
<h3 id="sec-2-10"><code>seq.c</code></h3>
<div class="outline-text-3" id="text-2-10">

<ul>
<li id="sec-2-10-1"><code>seq_file</code><br/>
 <b>chapter 4.3</b>
The <code>seq_file</code> interface assumes that you are creating a virtual file
that steps through a sequence of items that must be returned to user
space. To use seq<sub>file</sub>, you must create a simple "iterator" object
that can establish a position within the sequence, step forward, and
output one item in the sequence. It may sound complicated, but, in
fact, the process is quite simple. 

<p>
The first step, inevitably, is the inclusion of <code>&lt;linux/seq_file.h&gt;</code>.
Then you must create four iterator methods, called start, next, stop,
and show.
</p>
<p>
<code>void *start(struct seq_file *sfile, loff_t *pos);</code>
The sfile argument can almost always be ignored. pos is an integer
position indicating where the reading should start. The interpretation
of the position is entirely up to the implementation; it need not be a
byte position in the resulting file. 
</p>
<p>
The next function should move the iterator to the next position,
returning NULL if there is nothing left in the sequence. This method's
prototype is:
<code>void *next(struct seq_file *sfile, void *v, loff_t *pos);</code>
Here, v is the iterator as returned from the previous call to start or
next, and pos is the current position in the file. next should
increment the value pointed to by pos; depending on how your iterator
works, you might (though probably won't) want to increment pos by more
than one.
</p>
<p>
When the kernel is done with the iterator, it calls stop to clean up:
<code>void stop(struct seq_file *sfile, void *v);</code>
</p>

<p>
In between these calls, the kernel calls the show method to actually
output something interesting to the user space. This method's
prototype is:
<code>int show(struct seq_file *sfile, void *v);</code>
</p>
<p>
Now that it has a full set of iterator operations, seq must package
them up and connect them to a file in <code>/proc</code>. The first step is done by
filling in a <code>seq_operations</code> structure:
</p>


<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_operations</span> <span style="color: #eedd82;">ct_seq_ops</span> = {
        .start = ct_seq_start,
        .next  = ct_seq_next,
        .stop  = ct_seq_stop,
        .show  = ct_seq_show
};
</pre>


<p>
With that structure in place, we must create a file implementation
that the kernel understands. We do not use the <code>read_proc</code> method
described previously; when using <code>seq_file</code>, it is best to connect in to
/proc at a slightly lower level. That means creating a file<sub>operations</sub>
structure (yes, the same structure used for char drivers) implementing
all of the operations needed by the kernel to handle reads and seeks
on the file. Fortunately, this task is straightforward. The first step
is to create an open method that connects the file to the <code>seq_file</code>
operations:
</p>



<pre class="src src-c"><span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;"> * Time to set up the file operations for our /proc file.  In this case,</span>
<span style="color: #ff7f24;"> * all we need is an open function which sets up the sequence ops.</span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ct_open</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">inode</span> *<span style="color: #eedd82;">inode</span>, <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file</span> *<span style="color: #eedd82;">file</span>)
{
        <span style="color: #00ffff;">return</span> seq_open(file, &amp;ct_seq_ops);
};
</pre>


<p>
The call to <code>seq_open</code> connects the file structure with our sequence
operations defined above. As it turns out, open is the only file
operation we must implement ourselves, so we can now set up our
<code>file_operations</code> structure:
</p>



<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">file_operations</span> <span style="color: #eedd82;">ct_file_ops</span> = {
        .owner   = THIS_MODULE,
        .open    = ct_open,
        .read    = seq_read,
        .llseek  = seq_lseek,
        .release = seq_release
};
</pre>


<p>
The final step is to create the actual file in /proc:
</p>


<pre class="src src-c">entry = create_proc_entry(<span style="color: #ffa07a;">"scullseq"</span>, 0, <span style="color: #7fffd4;">NULL</span>);
<span style="color: #00ffff;">if</span> (entry)
    entry-&gt;proc_fops = &amp;scull_proc_ops;
</pre>


<ul>
<li id="sec-2-10-1-1">API<br/>



<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">start</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">sfile</span>, <span style="color: #98fb98;">loff_t</span> *<span style="color: #eedd82;">pos</span>);
<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">next</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">sfile</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">loff_t</span> *<span style="color: #eedd82;">pos</span>)
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">stop</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">sfile</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>);
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">show</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">sfile</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>)

In between <span style="color: #98fb98;">these</span> <span style="color: #eedd82;">calls</span>, the kernel calls the show method to actually output something interesting to the <span style="color: #98fb98;">user</span> space. This method<span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s prototype is:</span>

<span style="color: #ffa07a;">int show(struct seq_file *sfile, void *v);</span>

<span style="color: #ffa07a;">This method should create output for the item in the sequence indicated by the iterator v. It should not use printk, however; instead, there is a special set of functions for seq_file output:</span>

<span style="color: #ffa07a;">int seq_printf(struct seq_file *sfile, const char *fmt, ...);</span>
<span style="color: #ffa07a;">    This is the printf equivalent for seq_file implementations; it takes the usual format string and additional value arguments. You must also pass it the seq_file structure given to the show function, however. If seq_printf returns a nonzero value, it means that the buffer has filled, and output is being discarded. Most implementations ignore the return value, however.</span>

<span style="color: #ffa07a;">int seq_putc(struct seq_file *sfile, char c);</span>

<span style="color: #ffa07a;">int seq_puts(struct seq_file *sfile, const char *s);</span>
<span style="color: #ffa07a;">    These are the equivalents of the user-space putc and puts functions.</span>

<span style="color: #ffa07a;">int seq_escape(struct seq_file *m, const char *s, const char *esc);</span>
<span style="color: #ffa07a;">    This function is equivalent to seq_puts with the exception that any character in s that is also found in esc is printed in octal format. A common value for esc is " \t\n\\", which keeps embedded white space from messing up the output and possibly confusing shell scripts.</span>

<span style="color: #ffa07a;">int seq_path(struct seq_file *sfile, struct vfsmount *m, struct dentry</span>
<span style="color: #ffa07a;">    *dentry, char *esc);</span>
<span style="color: #ffa07a;">    This function can be used for outputting the file name associated with a given directory entry. It is unlikely to be useful in device drivers; we have included it here for completeness.</span>
</pre>


</li>
</ul>
<ul>
<li id="sec-2-10-1-2">Ref<br/>



<pre class="src src-c">&lt;linux/seq_file.h&gt;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> {
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">buf</span>;
        <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>;
        <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">from</span>;
        <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">count</span>;
        <span style="color: #98fb98;">loff_t</span> <span style="color: #eedd82;">index</span>;
        <span style="color: #98fb98;">loff_t</span> <span style="color: #eedd82;">read_pos</span>;
        <span style="color: #98fb98;">u64</span> <span style="color: #eedd82;">version</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">mutex</span> <span style="color: #eedd82;">lock</span>;
        <span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_operations</span> *<span style="color: #eedd82;">op</span>;
        <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">private</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_operations</span> {
        <span style="color: #98fb98;">void</span> * (*<span style="color: #87cefa;">start</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">loff_t</span> *<span style="color: #eedd82;">pos</span>);
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">stop</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>);
        <span style="color: #98fb98;">void</span> * (*<span style="color: #87cefa;">next</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>, <span style="color: #98fb98;">loff_t</span> *<span style="color: #eedd82;">pos</span>);
        <span style="color: #98fb98;">int</span> (*<span style="color: #87cefa;">show</span>) (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">seq_file</span> *<span style="color: #eedd82;">m</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">v</span>);
};
</pre>


</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-2-10-2">test<br/>



<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">cat /proc/sequence</span>
0
1
2
3
4
5
6
7
8
9
10
11
12
13
.........
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-2-11" class="outline-3">
<h3 id="sec-2-11"><code>silly.c</code></h3>
<div class="outline-text-3" id="text-2-11">

<p> <b>chapter 9.4</b>
</p><ul>
<li id="sec-2-11-1">I/O Ports and I/O Memory<br/>

<ul>
<li id="sec-2-11-1-1">API<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/io.h&gt;</span>
<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ioremap</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">phys_addr</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>);
<span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">ioremap_nocache</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">phys_addr</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">size</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iounmap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">virt_addr</span>);
   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ioremap remaps a physical address range into the processor's</span>
<span style="color: #ff7f24;">virtual address space, making it available to the kernel. iounmap</span>
<span style="color: #ff7f24;">frees the mapping when it is no longer needed.</span><span style="color: #ff7f24;">*/</span>

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;asm/io.h&gt;</span>
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ioread8</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ioread16</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">ioread32</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite8</span>(<span style="color: #98fb98;">u8</span> <span style="color: #eedd82;">value</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite16</span>(<span style="color: #98fb98;">u16</span> <span style="color: #eedd82;">value</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite32</span>(<span style="color: #98fb98;">u32</span> <span style="color: #eedd82;">value</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
    Accessor functions that are used to work <span style="color: #98fb98;">with</span> <span style="color: #87cefa;">I</span>/O memory.

<span style="color: #98fb98;">void</span> ioread8_rep(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ioread16_rep</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ioread32_rep</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite8_rep</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite16_rep</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">iowrite32_rep</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">buf</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">count</span>);
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">"Repeating" versions of the I/O memory primitives.</span><span style="color: #ff7f24;">*/</span>

<span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">readb</span>(address);
<span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">readw</span>(address);
<span style="color: #98fb98;">unsigned</span> <span style="color: #87cefa;">readl</span>(address);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writeb</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">value</span>, address);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writew</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">value</span>, address);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">writel</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">value</span>, address);

memset_io(address, value, count);
memcpy_fromio(dest, source, nbytes);
memcpy_toio(dest, source, nbytes);
    Older, type-unsafe functions <span style="color: #00ffff;">for</span> accessing I/O memory.

<span style="color: #98fb98;">void</span> *ioport_map(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">port</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">ioport_unmap</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">addr</span>);
    A driver author that wants to <span style="color: #98fb98;">treat</span> <span style="color: #87cefa;">I</span>/O ports as <span style="color: #00ffff;">if</span> they were I/O memory may pass those ports to ioport_map. The mapping should be done (<span style="color: #98fb98;">with</span> <span style="color: #eedd82;">ioport_unmap</span>) when no <span style="color: #98fb98;">longer</span> <span style="color: #eedd82;">needed</span>.
</pre>


</li>
</ul>
<ul>
<li id="sec-2-11-1-2">Ref<br/>



<pre class="src src-c"></pre>


</li>
</ul>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">misc-progs</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">dataalign.c</h3>
<div class="outline-text-3" id="text-3-1">

<ul>
<li id="sec-3-1-1">SRC<br/>



<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/utsname.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">utsname</span> <span style="color: #eedd82;">name</span>;
uname(&amp;name);  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">=&gt; name.machine</span>
</pre>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">c</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">c</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">short</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">s</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">i</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">int</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">i</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">long</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">l</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ll</span>  {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">ll</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">p</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">void</span> *    <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">p</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u1b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u8</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u1b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u2b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u16</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u2b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u4b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u32</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u4b</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u8b</span> {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">__u64</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u8b</span>;
(<span style="color: #98fb98;">int</span>)((<span style="color: #98fb98;">void</span> *)(&amp;c.t)   - (<span style="color: #98fb98;">void</span> *)&amp;c),

  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">c2</span>   {<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>      <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">c2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">s2</span>   {<span style="color: #98fb98;">short</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>     <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">s2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">i2</span>   {<span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">i2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">l2</span>   {<span style="color: #98fb98;">long</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>       <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">l2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">ll2</span>  {<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>  <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">ll2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">p2</span>   {<span style="color: #98fb98;">void</span> * <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>  <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">p2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u1b2</span> {<span style="color: #98fb98;">__u8</span> <span style="color: #eedd82;">c</span>;  <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u1b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u2b2</span> {<span style="color: #98fb98;">__u16</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u2b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u4b2</span> {<span style="color: #98fb98;">__u32</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u4b2</span>;
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">u8b2</span> {<span style="color: #98fb98;">__u64</span> <span style="color: #eedd82;">c</span>; <span style="color: #98fb98;">char</span>   <span style="color: #eedd82;">t</span>;} <span style="color: #eedd82;">u8b2</span>;
(<span style="color: #98fb98;">int</span>)((<span style="color: #98fb98;">void</span> *)(&amp;c2.t)   - (<span style="color: #98fb98;">void</span> *)&amp;c2)
</pre>

</li>
</ul>
<ul>
<li id="sec-3-1-2">Test<br/>



<pre class="src src-sh">arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
i686            1     2     4     4     4     4        1   2   4   4

arch  Align:  char  short  int  long   ptr long-long  u8 u16 u32 u64
i686            1     2     4     4     4     8        1   2   4   8
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">datasize.c</h3>
<div class="outline-text-3" id="text-3-2">




<pre class="src src-c">(<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">short</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>),
           (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span>),
           (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">void</span> *), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u8),
           (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u16), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u32), (<span style="color: #98fb98;">int</span>)<span style="color: #00ffff;">sizeof</span>(__u64));
</pre>



<pre class="src src-sh">arch   Size:  char  short  int  long   ptr long-long  u8 u16 u32 u64
i686            1     2     4     4     4     8        1   2   4   8
</pre>




</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">asynctest.c</h3>
<div class="outline-text-3" id="text-3-3">

<ul>
<li id="sec-3-3-1">Asynchronous Notification<br/>
 <b>chapter 6.4</b>
<ul>
<li id="sec-3-3-1-1">SRC<br/>



<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sigaction</span> <span style="color: #eedd82;">action</span>;

memset(&amp;action, 0, <span style="color: #00ffff;">sizeof</span>(action));
action.sa_handler = sighandler;
action.sa_flags = 0;

sigaction(<span style="color: #eedd82;">SIGIO</span>, &amp;action, <span style="color: #7fffd4;">NULL</span>);

fcntl(STDIN_FILENO, F_SETOWN, getpid());
fcntl(STDIN_FILENO, F_SETFL, fcntl(STDIN_FILENO, F_GETFL) | FASYNC);

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">sighandler</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">signo</span>){}
</pre>

</li>
</ul>
<ul>
<li id="sec-3-3-1-2">Overview<br/>




</li>
</ul>
<ul>
<li id="sec-3-3-1-3">Ref<br/>
<ul>
<li><code>struct sigaction</code>
</li>
</ul>




<pre class="src src-c">&lt;usr/include/signal.h&gt;
<span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;bits/sigaction.h&gt;</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Structure describing the action to be taken when a signal arrives.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sigaction</span>
  {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Signal handler.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#ifdef</span> __USE_POSIX199309
    <span style="color: #00ffff;">union</span>
      {
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Used if SA_SIGINFO is not set.  </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">__sighandler_t</span> <span style="color: #eedd82;">sa_handler</span>;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Used if SA_SIGINFO is set.  </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">sa_sigaction</span>) (<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">siginfo_t</span> *, <span style="color: #98fb98;">void</span> *);
      }
    <span style="color: #eedd82;">__sigaction_handler</span>;
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">sa_handler</span>     __sigaction_handler.sa_handler
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">sa_sigaction</span>   __sigaction_handler.sa_sigaction
<span style="color: #b0c4de;">#else</span>
    <span style="color: #98fb98;">__sighandler_t</span> <span style="color: #eedd82;">sa_handler</span>;
<span style="color: #b0c4de;">#endif</span>

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Additional set of signals to be blocked.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">__sigset_t</span> <span style="color: #eedd82;">sa_mask</span>;

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Special flags.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sa_flags</span>;

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Restore handler.  </span><span style="color: #ff7f24;">*/</span>
    <span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">sa_restorer</span>) (<span style="color: #98fb98;">void</span>);
  };

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Bits in `sa_flags'.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SA_NOCLDSTOP</span>  1          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Don't send SIGCHLD when children stop.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SA_NOCLDWAIT</span>  2          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Don't create zombie on child death.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">SA_SIGINFO</span>    4          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Invoke signal-catching function with</span>
<span style="color: #ff7f24;">                                    three arguments instead of one.  </span><span style="color: #ff7f24;">*/</span>
</pre>


<ul>
<li><code>sigaction()</code>
</li>
</ul>




<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get and/or set the action for signal SIG.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">sigaction</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">__sig</span>, __const <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sigaction</span> *<span style="color: #eedd82;">__restrict</span> __act,
                      <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sigaction</span> *<span style="color: #eedd82;">__restrict</span> __oact) __THROW;
</pre>


<ul>
<li><code>fcntl</code>
</li>
</ul>




<pre class="src src-c">&lt;fcntl.h&gt;
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Do the file control operation described by CMD on FD.</span>
<span style="color: #ff7f24;">   The remaining arguments are interpreted depending on CMD.</span>

<span style="color: #ff7f24;">   This function is a cancellation point and therefore not marked with</span>
<span style="color: #ff7f24;">   __THROW.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> fcntl (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">__fd</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">__cmd</span>, ...);

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;bits/fcntl.h&gt;</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Values for the second argument to `fcntl'.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">F_DUPFD</span>         0       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Duplicate file descriptor.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">F_GETFD</span>         1       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get file descriptor flags.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">F_SETFD</span>         2       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set file descriptor flags.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">F_GETFL</span>         3       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get file status flags.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">F_SETFL</span>         4       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set file status flags.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#if</span> __WORDSIZE == 64
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETLK</span>        5       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get record locking info.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLK</span>        6       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (non-blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLKW</span>       7       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Not necessary, we always have 64-bit offsets.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETLK64</span>      5       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get record locking info.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLK64</span>      6       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (non-blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLKW64</span>     7       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;"># if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> __USE_FILE_OFFSET64
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_GETLK</span>       5       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get record locking info.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_SETLK</span>       6       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (non-blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_SETLKW</span>      7       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># else</span>
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_GETLK</span>       F_GETLK64  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get record locking info.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_SETLK</span>       F_SETLK64  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (non-blocking).</span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#  define</span> <span style="color: #eedd82;">F_SETLKW</span>      F_SETLKW64 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># endif</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETLK64</span>      12      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get record locking info.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLK64</span>      13      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (non-blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLKW64</span>     14      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set record locking info (blocking).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>

<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span> __USE_BSD || <span style="color: #b0c4de;">defined</span> __USE_UNIX98
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETOWN</span>       8       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get owner (process receiving SIGIO).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETOWN</span>       9       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set owner (process receiving SIGIO).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>

<span style="color: #b0c4de;">#ifdef</span> __USE_GNU
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETSIG</span>       10      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set number of signal to be sent.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETSIG</span>       11      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get number of signal to be sent.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETOWN_EX</span>    15      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get owner (thread receiving SIGIO).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETOWN_EX</span>    16      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set owner (thread receiving SIGIO).  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>

<span style="color: #b0c4de;">#ifdef</span> __USE_GNU
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_SETLEASE</span>     1024    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set a lease.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_GETLEASE</span>     1025    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Enquire what lease is active.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_NOTIFY</span>       1026    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Request notfications on a directory.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;"># define</span> <span style="color: #eedd82;">F_DUPFD_CLOEXEC</span> 1030   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Duplicate file descriptor with</span>
<span style="color: #ff7f24;">                                   close-on-exit set.  </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>
</pre>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4">gdbline</h3>
<div class="outline-text-3" id="text-3-4">


</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5">inp.c</h3>
<div class="outline-text-3" id="text-3-5">


</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6">load50.c</h3>
<div class="outline-text-3" id="text-3-6">

<p> <b>chapter 7.3</b>
This program forks a number of processes that do nothing, but do it in
a CPU-intensive way. The program is part of the sample files accompanying this
book, and forks 50 processes by default, although the number can be specified on
the command line.
</p>

</div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7">mapcmp.c</h3>
<div class="outline-text-3" id="text-3-7">


</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8">mapper.c</h3>
<div class="outline-text-3" id="text-3-8">


</div>

</div>

<div id="outline-container-3-9" class="outline-3">
<h3 id="sec-3-9">nbtest.c</h3>
<div class="outline-text-3" id="text-3-9">


</div>

</div>

<div id="outline-container-3-10" class="outline-3">
<h3 id="sec-3-10">netifdebug.c</h3>
<div class="outline-text-3" id="text-3-10">


</div>

</div>

<div id="outline-container-3-11" class="outline-3">
<h3 id="sec-3-11">outp.c</h3>
<div class="outline-text-3" id="text-3-11">


</div>

</div>

<div id="outline-container-3-12" class="outline-3">
<h3 id="sec-3-12">polltest.c</h3>
<div class="outline-text-3" id="text-3-12">


</div>

</div>

<div id="outline-container-3-13" class="outline-3">
<h3 id="sec-3-13">setconsole.c</h3>
<div class="outline-text-3" id="text-3-13">


</div>

</div>

<div id="outline-container-3-14" class="outline-3">
<h3 id="sec-3-14">setlevel.c</h3>
<div class="outline-text-3" id="text-3-14">



</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">skull</h2>
<div class="outline-text-2" id="text-4">

<ul>
<li id="sec-4-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-4-2">Ref<br/>



<pre class="src src-c">#+end_src

* scull
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">scull</h2>
<div class="outline-text-2" id="text-5">

<ul>
<li id="sec-5-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-5-2">Ref<br/>



<pre class="src src-c">#+end_src

* <span style="color: #98fb98;">short</span>
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">short</h2>
<div class="outline-text-2" id="text-6">

<ul>
<li id="sec-6-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-6-2">Ref<br/>



<pre class="src src-c">#+end_src

* scullc
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">scullc</h2>
<div class="outline-text-2" id="text-7">

<ul>
<li id="sec-7-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-7-2">Ref<br/>



<pre class="src src-c">#+end_src

* sculld
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">sculld</h2>
<div class="outline-text-2" id="text-8">

<ul>
<li id="sec-8-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-8-2">Ref<br/>



<pre class="src src-c">#+end_src

* scullp
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">scullp</h2>
<div class="outline-text-2" id="text-9">

<ul>
<li id="sec-9-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-9-2">Ref<br/>



<pre class="src src-c">#+end_src

* scullv
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">scullv</h2>
<div class="outline-text-2" id="text-10">

<ul>
<li id="sec-10-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-10-2">Ref<br/>



<pre class="src src-c">#+end_src

* simple
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11">simple</h2>
<div class="outline-text-2" id="text-11">

<ul>
<li id="sec-11-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-11-2">Ref<br/>



<pre class="src src-c">#+end_src

* shortprint
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12">shortprint</h2>
<div class="outline-text-2" id="text-12">

<ul>
<li id="sec-12-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-12-2">Ref<br/>



<pre class="src src-c">#+end_src

* pci
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13">pci</h2>
<div class="outline-text-2" id="text-13">

<ul>
<li id="sec-13-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-13-2">Ref<br/>



<pre class="src src-c">#+end_src

* usb
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14">usb</h2>
<div class="outline-text-2" id="text-14">

<ul>
<li id="sec-14-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-14-2">Ref<br/>



<pre class="src src-c">#+end_src

* lddbus
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15">lddbus</h2>
<div class="outline-text-2" id="text-15">

<ul>
<li id="sec-15-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-15-2">Ref<br/>



<pre class="src src-c">#+end_src

* sbull
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16">sbull</h2>
<div class="outline-text-2" id="text-16">

<ul>
<li id="sec-16-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-16-2">Ref<br/>



<pre class="src src-c">#+end_src

* snull
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17">snull</h2>
<div class="outline-text-2" id="text-17">

<ul>
<li id="sec-17-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-17-2">Ref<br/>



<pre class="src src-c">#+end_src

* tty
**** API
#+begin_src c
</pre>


</li>
</ul>
</div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18">tty</h2>
<div class="outline-text-2" id="text-18">

<ul>
<li id="sec-18-1">API<br/>



<pre class="src src-c">#+end_src
**** Ref
#+begin_src c
</pre>

</li>
</ul>
<ul>
<li id="sec-18-2">Ref<br/>


</li>
</ul>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2013-05-10T22:38+0800</p>
<p class="author">Author: Shi Shougang</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
