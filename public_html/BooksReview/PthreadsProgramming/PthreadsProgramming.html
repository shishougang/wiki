<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Pthreads Programming</title>
<!-- 2017-01-26 Thu 21:27 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Pthreads Programming</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Reference</a></li>
<li><a href="#sec-2">Chapter 1: Why Threads?</a>
<ul>
<li><a href="#sec-2-1">Overview</a></li>
<li><a href="#sec-2-2">Specifying Potential Parallelism in a Concurrent Programming Environment</a></li>
<li><a href="#sec-2-3">Parallel vs. Concurrent Programming</a></li>
<li><a href="#sec-2-4">Synchronization</a></li>
<li><a href="#sec-2-5">Who Am I? Who Are You?</a></li>
<li><a href="#sec-2-6">Terminating Thread Execution</a></li>
<li><a href="#sec-2-7">Why Use Threads Over Processes?</a></li>
<li><a href="#sec-2-8">A Structured Programming Environment</a></li>
<li><a href="#sec-2-9">Choosing Which Applications to Thread</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 2 - Designing Threaded Programs</a>
<ul>
<li><a href="#sec-3-1">Some Common Problems</a></li>
<li><a href="#sec-3-2">Performance</a></li>
<li><a href="#sec-3-3">Example: An ATM Server</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 3 - Synchronizing Pthreads</a>
<ul>
<li><a href="#sec-4-1">Overview</a></li>
<li><a href="#sec-4-2">Selecting the Right Synchronization Tool</a></li>
<li><a href="#sec-4-3">Mutex Variables</a></li>
<li><a href="#sec-4-4">Condition Variables</a></li>
<li><a href="#sec-4-5">Reader/Writer Locks</a></li>
<li><a href="#sec-4-6">Synchronization in the ATM Server</a></li>
<li><a href="#sec-4-7">Thread Pools</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 4 - Managing Pthreads</a>
<ul>
<li><a href="#sec-5-1">Setting Thread Attributes</a></li>
<li><a href="#sec-5-2">The <code>pthread_once</code> Mechanism</a></li>
<li><a href="#sec-5-3">Keys: Using Thread-Specific Data</a></li>
<li><a href="#sec-5-4">Cancellation</a></li>
<li><a href="#sec-5-5">Scheduling Pthreads</a></li>
<li><a href="#sec-5-6">Mutex Scheduling Attributes</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 5 - Pthreads and UNIX</a>
<ul>
<li><a href="#sec-6-1">Overview</a></li>
<li><a href="#sec-6-2">Threads and Signals</a></li>
<li><a href="#sec-6-3">Threadsafe Library Functions and System Calls</a></li>
<li><a href="#sec-6-4">Cancellation-Safe Library Functions and System Calls</a></li>
<li><a href="#sec-6-5">Thread-Blocking Library Functions and System Calls</a></li>
<li><a href="#sec-6-6">Threads and Process Management</a></li>
<li><a href="#sec-6-7">Multiprocessor Memory Synchronization</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 6: Practical Considerations</a>
<ul>
<li><a href="#sec-7-1">Understanding Pthreads Implementation</a></li>
<li><a href="#sec-7-2">Debugging</a></li>
<li><a href="#sec-7-3">Performance</a></li>
</ul>
</li>
<li><a href="#sec-8">Appendix C: Pthreads Quick Reference</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Reference</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>book POSIX.4: Programming for the Real World by Bill O. Gallmeister,
from O'Reilly &amp; Associates, for in-depth discussion of the POSIX
real-time extensions.
</li>
</ul>

<p>
POSIX Threads Programming
<a href="https://computing.llnl.gov/tutorials/pthreads/">https://computing.llnl.gov/tutorials/pthreads/</a>
</p>

<p>
Multithreaded Programming (POSIX pthreads Tutorial)
<a href="http://randu.org/tutorials/threads/">http://randu.org/tutorials/threads/</a>
</p>

<p>
Thread programming examples
<a href="http://www.cs.cf.ac.uk/Dave/C/node32.html">http://www.cs.cf.ac.uk/Dave/C/node32.html</a>
</p>

<p>
POSIX thread (pthread) libraries
<a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html">http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html</a>
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 1: Why Threads?</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Overview</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The threads model takes a process and divides it into two parts:        
</p>

<ul class="org-ul">
<li>One contains resources used across the whole program (the
processwide information),such as program instructions and global
data. This part is still referred to as the process.        
</li>

<li>The other contains information related to the execution state, such
as a program counter and a stack. This part is referred to as a
<i>thread</i>.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Specifying Potential Parallelism in a Concurrent Programming Environment</h3>
<div class="outline-text-3" id="text-2-2">
<p>
If the fork call returns to both the parent and child, why
don't the parent and child execute the same instructions following
the fork? UNIX programmers specify different code paths for parent
and child by examining the return value of the fork call. The fork
call always returns a value of 0 to the child and the child's PID to
the parent.
</p>

<p>
<b>A fork Call</b>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> ((pid = fork()) &lt; 0 ) {      
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Fork system call failed </span><span style="color: #ff7f24;">*/</span>        
           .    
           perror(<span style="color: #ffa07a;">"fork"</span>), exit(1);     
}<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (pid == 0) {   
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Child only, pid is 0 </span><span style="color: #ff7f24;">*/</span>   
           .    
           <span style="color: #00ffff;">return</span> 0;    
}<span style="color: #00ffff;">else</span> { 
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Parent only , pid is child's process ID </span><span style="color: #ff7f24;">*/</span>        
           .    
}
</pre>
</div>


<p>
When looking for concurrency, then, why choose multiple threads over
multiple processes? The overwhelming reason lies in the single largest
benefit of multithreaded programming: threads require less program and
system overhead to run than processes do. The operating system
performs less work on behalf of a multithreaded program than it does
for a multiprocess program. This translates into a performance gain
for the multithreaded program.
</p>
</div>

<ul class="org-ul"><li><a id="sec-2-2-1" name="sec-2-2-1"></a>Creating a new thread: <code>pthread_create</code><br  /><div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span>       <span style="color: #eedd82;">thread1</span>;

pthread_create(&amp;thread1,        
          <span style="color: #7fffd4;">NULL</span>, 
          (<span style="color: #98fb98;">void</span> *) do_one_thing,        
          (<span style="color: #98fb98;">void</span> *) &amp;r1);
</pre>
</div>

<ul class="org-ul">
<li>A pointer to a buffer to which pthread<sub>create</sub> returns a value
that identifies the newly created thread. This value, or
handle, is of type <code>pthread_t</code>.
</li>
<li>A pointer to a structure known as a thread attribute object.
</li>
<li>A pointer to the routine at which the new thread will start
executing.
</li>
<li>A pointer to a parameter to be passed to the routine at which
the new thread starts.
</li>
</ul>
</div>
</li>

<li><a id="sec-2-2-2" name="sec-2-2-2"></a>Threads are peers<br  /></li></ul>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Parallel vs. Concurrent Programming</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We'll use concurrent programming in a general sense to refer to
environments in which the tasks we define can occur in any order. One
task can occur before or after another, and some or all tasks can be
performed at the same time. We'll use parallel programming to
specifically refer to the simultaneous execution of concurrent tasks
on different processors. Thus, all parallel programming is concurrent,
but not all concurrent programming is parallel.
</p>

<p>
Whether the threads actually run in parallel is a function of the
operating system and hardware on which they run. Because Pthreads was
designed in this way, a Pthreads program can run without modification
on uniprocessor as well as multiprocessor systems.
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Synchronization</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The <code>pthread_join</code> call provides synchronization for threads similar to
that which waitpid provides for processes, suspending its caller until
another thread exits. Unlike waitpid, which is specifically intended
for parent and child processes, you can use <code>pthread_join</code> between any
two threads in a program.
</p>

<p>
For this, we'll define a mutex variable (of type <code>pthread_mutex_t</code>) and
initialize it. (Just as a thread can have a thread attribute object, a
mutex can have a mutex attribute object that indicates its special
characteristics. Here, too, we'll pass a value of NULL for this
argument, indicating that we accept the default characteristics for
the new mutex.)
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">r3_mutex</span>=PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&amp;r3_mutex);
pthread_mutex_unlock(&amp;r3_mutex);
</pre>
</div>
</div>

<ul class="org-ul"><li><a id="sec-2-4-1" name="sec-2-4-1"></a>Sharing Process Resources<br  /><div class="outline-text-4" id="text-2-4-1">
<p>
Independent processes share nothing. Threads share such process
resources as global variables and file descriptors. If one thread
changes the value of any such resource, the change will be evident to
any other thread in the process, if anyone cares to look. The sharing
of process resources among threads is one of the multithreaded
programming model's major performance advantages, as well as one of
its most difficult programming aspects. Having all of this context
available to all threads in the same memory facilitates communication
between threads. However, at the same time, it makes it easy to
introduce errors of the sort in which one thread affects the value of
a variable used by another thread in ways the other thread did not
expect.
</p>
</div>
</li>

<li><a id="sec-2-4-2" name="sec-2-4-2"></a>Communication<br  /><div class="outline-text-4" id="text-2-4-2">
<p>
Multiple processes can use any of the many other UNIX Interprocess
Communication (IPC) mechanisms: sockets, shared memory, and messages,
to name a few. The multiprocess version of our program uses shared
memory, but the other methods are equally valid. Even the waitpid call
in our program could be used to exchange information, if the program
checked its return value. However, in the multiprocess world, all
types of IPC involve a call into the operating system—to initialize
shared memory or a message structure, for instance. This makes
communication between processes more expensive than communication
between threads.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Who Am I? Who Are You?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
You can save this handle and use it to determine a thread's identity
using the <code>pthread_self</code> and <code>pthread_equal</code> function calls. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">io_thread</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
  pthread_create(&amp;io_thread, ...);
}
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">routine_x</span>(<span style="color: #98fb98;">void</span>)
{
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;
  thread = pthread_self();
  <span style="color: #00ffff;">if</span>(phtread_equal(io_thread, thread)){
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Terminating Thread Execution</h3>
<div class="outline-text-3" id="text-2-6">
<p>
A thread can also explicitly exit with a call to <code>pthread_exit</code>. You can
terminate another thread by calling <code>pthread_cancel</code>. In any of these
cases, the Pthreads library runs any routines in its cleanup stack
and any destructors in keys in which it has store values. 
</p>
</div>
<ul class="org-ul"><li><a id="sec-2-6-1" name="sec-2-6-1"></a>Exit Status and Return Values<br  /><div class="outline-text-4" id="text-2-6-1">
<p>
The Pthreads library may or may not save the exit status of a thread
when the thread exits, depending upon whether the thread is joinable
or detached. A joinable thread, the default state of a thread at its
creation, does have its exit status saved; a detached thread does not.
Detaching a thread gives the library a break and lets it immediately
reclaim the resources associated with the thread. Because the library
will not have an exit status for a detached thread, you cannot use a
<code>pthread_join</code> to join it.
</p>

<p>
What is the exit status of a thread? You can associate an exit status
with a thread in either of two ways:        
</p>
<ul class="org-ul">
<li>If the thread terminates explicitly with a call to <code>pthread_exit</code>, the
argument to the call becomes its exit status.        
</li>
<li>If the thread does not call <code>pthread_exit</code>, the return value of the
routine in which it started becomes its exit status.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>    
<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;       
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arg</span>; 
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">internal_error</span> = -12;  
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">normal_error</span> = -10;    
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">success</span> = 1;   
<span style="color: #98fb98;">void</span> * <span style="color: #87cefa;">routine_x</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg_in</span>)  
{       
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">arg</span> = (<span style="color: #98fb98;">int</span> *)arg_in;     
  .     
  <span style="color: #00ffff;">if</span> ( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">something that shouldn't have happened </span><span style="color: #ff7f24;">*/</span>) {  
    pthread_exit((<span style="color: #98fb98;">void</span> *) &amp;real_bad_error);     
  }<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">normal failure </span><span style="color: #ff7f24;">*/</span> ) {   
    <span style="color: #00ffff;">return</span> ((<span style="color: #98fb98;">void</span> *) &amp;normal_error);    
  }<span style="color: #00ffff;">else</span> {       
    <span style="color: #00ffff;">return</span> ((<span style="color: #98fb98;">void</span> *) &amp;success); 
  }     
}       
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">argc</span>, <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">argv</span>)     
{       
  <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>;     
  <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">statusp</span>;        
  .     
  pthread_create(&amp;thread, <span style="color: #7fffd4;">NULL</span>, routine_x, &amp;arg);       
  pthread_join(thread, &amp;statusp);       
  <span style="color: #00ffff;">if</span> (*statusp == PTHREAD_CANCELED) {   
    printf(<span style="color: #ffa07a;">"Thread was canceled.\n"</span>);   
  }<span style="color: #00ffff;">else</span> {       
    printf(<span style="color: #ffa07a;">"Thread completed and exit status is %ld.\n"</span>, *(<span style="color: #98fb98;">int</span> *)statusp);      
  }     
<span style="color: #00ffff;">return</span> 0;       
}
</pre>
</div>

<p>
A final note on <code>pthread_join</code> is in order. Its purpose is to allow a
single thread to wait on another's termination. The result of having
multiple threads concurrently call <code>pthread_join</code> is undefined in the
Pthreads standard.
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Why Use Threads Over Processes?</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Creating a new process can be expensive. It takes time. (A call into
the operating system is needed, and if the process creation triggers
process rescheduling activity, the operating system's
context-switching mechanism will become involved.) It takes memory.
(The entire process must be replicated.) Add to this the cost of
interprocess communication and synchronization of shared data, which
also may involve calls into the operating system kernel, and threads
provide an attractive alternative.
</p>

<p>
Threads can be created without replicating an entire process.
Furthermore, some, if not all, of the work of creating a thread is
done in user space rather than kernel space. When processes
synchronize, they usually have to issue system calls, a relatively
expensive operation that involves trapping into the kernel. But
threads can synchronize by simply monitoring a variable—in other
words, staying within the user address space of the program.
</p>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">A Structured Programming Environment</h3>
</div>
<div id="outline-container-sec-2-9" class="outline-3">
<h3 id="sec-2-9">Choosing Which Applications to Thread</h3>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 2 - Designing Threaded Programs</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Some Common Problems</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The basic rule for managing shared resources is simple and twofold:        
</p>
<ul class="org-ul">
<li>Obtain a lock before accessing the resource.        
</li>
<li>Release the lock when you are finished with the resource.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Performance</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>The memory and CPU cycles required to manage each thread, including
the structures the operating system uses to manage them, plus the
overhead for the Pthreads library and any special code in the
operating system that supports the library.
</li>
<li>The CPU cycles spent for synchronization calls that enforce orderly
access to shared data. These calls cost in CPU cycles to execute the
calls.
</li>
<li>The time during which the application is inactive while one thread
is waiting on another thread. This cost results from too many
dependencies among threads and can be allayed by improved program
design.
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Example: An ATM Server</h3>
<div class="outline-text-3" id="text-3-3">
</div><ul class="org-ul"><li><a id="sec-3-3-1" name="sec-3-3-1"></a>Dynamically detaching a thread<br  /><div class="outline-text-4" id="text-3-3-1">
<p>
The pthread<sub>detach</sub> function notifies the Pthreads library that we
don't want to join our worker threads: that is, we will never request
their exit status. If we don't explicitly tell the Pthreads library
that we don't care about a thread's exit status, it'll keep the shadow
of the thread alive indefinitely after the thread terminates (in the
same way that UNIX keeps the status of zombie processes around).
Detaching our worker threads frees the Pthreads library from storing
this information, thus saving space and time. We are still responsible
for freeing any space we dynamically allocated to hold the pthread<sub>t</sub>
itself.
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 3 - Synchronizing Pthreads</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Overview</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Similarly, to make threads share data safely, we must ensure that
threads that would otherwise behave independently access shared data
in an orderly and controlled way. This concept is called
synchronization.
</p>

<p>
In a race condition, two or more threads access the same resource at
the same time.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Selecting the Right Synchronization Tool</h3>
<div class="outline-text-3" id="text-4-2">
</div><ul class="org-ul"><li><a id="sec-4-2-1" name="sec-4-2-1"></a><code>pthread_join</code> functions<br  /><div class="outline-text-4" id="text-4-2-1">
<p>
<code>pthread_join</code> allows one thread to suspend execution until another has
terminated.
</p>
</div>
</li>

<li><a id="sec-4-2-2" name="sec-4-2-2"></a>Mutex variable functions<br  /><div class="outline-text-4" id="text-4-2-2">
<p>
A mutex variable acts as a mutually exclusive lock, allowing threads
to control access to data. The threads agree that only one thread at a
time can hold the lock and access the data it protects. 
</p>
</div>
</li>
<li><a id="sec-4-2-3" name="sec-4-2-3"></a>Condition variable functions<br  /><div class="outline-text-4" id="text-4-2-3">
<p>
A condition variable provides a way of naming an event in which
threads have a general interest. An event can be something as simple
as a counter's reaching a particular value or a flag being set or
cleared; it may be something more complex, involving a specific
coincidence of multiple events. Threads are interested in these
events, because such events signify that some condition has been met
that allows them to proceed with some particular phase of their
execution. The Pthreads library provides ways for threads both to
express their interest in a condition and to signal that an awaited
condition has been met. 
</p>
</div>
</li>
<li><a id="sec-4-2-4" name="sec-4-2-4"></a><code>pthread_once</code> function<br  /><div class="outline-text-4" id="text-4-2-4">
<p>
<code>pthread_once</code> is a specialized synchronization tool that ensures that
initialization routines get executed once and only once when called by
multiple threads.
</p>
</div>
</li>
<li><a id="sec-4-2-5" name="sec-4-2-5"></a>Some of the common synchronization mechanisms are:<br  /><div class="outline-text-4" id="text-4-2-5">
<ul class="org-ul">
<li>Reader/writer exclusion Reader/writer locks allow multiple threads
to read data concurrently but ensure that any thread writing to the data has exclusive access.
</li>
<li>hreadsafe data structures        You may find it useful to build
synchronization primitives into a complex data structure so that
each time you access it you don't need to make a separate call to
synchronize concurrent access. 
</li>
<li>Semaphores        If your platform supports POSIX real-time extensions
(POSIX.1b), you can take advantage of yet another common
synchronization primitive for concurrent environments—semaphores. A
counting semaphore is like a mutex but is associated with a counter.
</li>
</ul>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Mutex Variables</h3>
<div class="outline-text-3" id="text-4-3">
<p>
To protect a shared resource from a race condition, we use a type of
synchronization called mutual exclusion, or mutex for short.
</p>

<p>
However, we could take a different perspective and provide exclusive
access to the code paths or routines that access data. We call that
piece of code that must be executed atomically a critical section.
</p>

<p>
Using mutex variables in Pthreads is quite simple. Here's what you do:        
</p>
<ol class="org-ol">
<li>Create and initialize a mutex for each resource you want to
protect, like a record in a database.        
</li>
<li>When a thread must access the resource, use <code>pthread_mutex_lock</code> to
lock the resource's mutex. The Pthreads library makes sure that
only one thread at a time can lock the mutex; all other calls to
the <code>pthread_mutex_lock</code> function for the same mutex must wait until
the thread currently holding the mutex releases it.        
</li>
<li>When the thread is finished with the resource, unlock the mutex by
calling <code>pthread_mutex_unlock</code>.
</li>
</ol>
</div>

<ul class="org-ul"><li><a id="sec-4-3-1" name="sec-4-3-1"></a>Using Mutexes<br  /><div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>static 
</li>
</ul>
<p>
<code>pthread_mutex_t global_data_mutex = PTHREAD_MUTEX_INITIALIZER;</code>
</p>
<ul class="org-ul">
<li>dynamic
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutexp</span>;        
  .     
mutexp=(<span style="color: #98fb98;">pthread_mutex_t</span> *)malloc(<span style="color: #00ffff;">sizeof</span>(pthread_mutex_t));    
pthread_mutex_init(mutexp, <span style="color: #7fffd4;">NULL</span>);
</pre>
</div>
</div>
</li>

<li><a id="sec-4-3-2" name="sec-4-3-2"></a>Using <code>pthread_mutex_trylock</code><br  /><div class="outline-text-4" id="text-4-3-2">
<p>
Somewhat more acceptable is the specialized use of
<code>pthread_mutex_trylock</code> by real-time programmers to poll for state
changes. This practice may be inefficient, but it does allow real-time
programs to respond quickly to a condition that warrants speed.
</p>

<p>
Another situation in which a <code>pthread_mutex_trylock</code> is often used is in
detecting and avoiding deadlock in locking hierarchies and priority
inversion situations.
</p>
</div>
</li>
<li><a id="sec-4-3-3" name="sec-4-3-3"></a>Some Shortcomings of Mutexes<br  /><div class="outline-text-4" id="text-4-3-3">
<p>
read and write lock
</p>

<p>
In some circumstances, it would be useful if we could define a
recursivelock: that is a lock that can be relocked any number of times
by its current holder. It would be nice if we could specify this
ability in a mutex attribute object. We can imagine the Pthreads
library associating an internal counter with a recursive mutex to
count the number of times its current holder has called
<code>pthread_mutex_lock</code>. Each time the current holder calls
<code>pthread_mutex_unlock</code>, the library would decrement this counter. The
lock would not be released until the call that brings the count down
to zero is issued.
</p>

<p>
A recursive mutex is useful for a thread that makes a number of nested
calls to a routine that locks and manipulates a resource. You lock the
mutex recursively each time the thread enters the routine and unlock
it at all exit points. If the thread already holds the lock, the calls
merely increase and decrease the recursive count and don't deadlock
the thread. If you did not use a recursive mutex, you'd need to
distinguish somehow between the times when the thread already holds
the lock when it calls the routine and those when it needs to make a
prior mutex lock call.
</p>
</div>
</li>

<li><a id="sec-4-3-4" name="sec-4-3-4"></a>Contention for a Mutex<br  /><div class="outline-text-4" id="text-4-3-4">
<p>
If more than one thread is waiting for a locked mutex, which thread is
the first to be granted the lock once it's released? The choice is
made according to the scheduling priorities of the individual threads.
</p>

<p>
The use of priorities in a multithreaded program can lead to a classic
multiprocessing problem: priority inversion. Priority inversion
involves a low priority thread that holds a lock that a higher
priority thread wants. Because the higher priority thread cannot
continue until the lower priority thread releases the lock, each
thread is actually treated as if it had the inverse of its intended
priority.
</p>
</div>
</li>
<li><a id="sec-4-3-5" name="sec-4-3-5"></a>Sharing a Mutex Among Processes<br  /><div class="outline-text-4" id="text-4-3-5">
<p>
If your platform allows you to set the process-shared attribute, the
compile-time constant <code>_POSIX_THREAD_PROCESS_SHARED</code> will be TRUE.
</p>

<p>
To set the process-shared attribute, supply the <code>PTHREAD_PROCESS_SHARED</code>
constant in a <code>pthread_mutexattr_setshared</code> call. To revert to a
process-private mutex, specify the <code>PTHREAD_PROCESS_PRIVATE</code> constant.
Processes that share a mutex must be able to access it in shared
memory (created through System V shared memory mechanisms or through
mmap calls). 
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">        #include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;unistd.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>     
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/types.h&gt;</span>  
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/ipc.h&gt;</span>    
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/shm.h&gt;</span>    
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;sys/wait.h&gt;</span>   
<span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> _POSIX_THREAD_PROCESS_SHARED    
<span style="color: #b0c4de;">#error</span> <span style="color: #ffa07a;">"This platform does not support process shared mutex"    </span>
<span style="color: #b0c4de;">#endif</span>  
<span style="color: #98fb98;">int</span>   <span style="color: #eedd82;">shared_mem_id</span>;    
<span style="color: #98fb98;">int</span>   *<span style="color: #eedd82;">shared_mem_ptr</span>;  
<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mptr</span>;  
<span style="color: #98fb98;">pthread_mutex_attr_t</span> <span style="color: #eedd82;">mutex_shared_attr</span>; 
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
  <span style="color: #98fb98;">pid_t</span>  <span style="color: #eedd82;">child_pid</span>;     
  <span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">status</span>;  
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">initialize shared memory segment </span><span style="color: #ff7f24;">*/</span>        
  shared_mem_id = shmget(IPC_PRIVATE, 1*<span style="color: #00ffff;">sizeof</span>(pthread_mutex_t), 0660); 
  shared_mem_ptr = (<span style="color: #98fb98;">int</span> *)shmat(shared_mem_id, (<span style="color: #98fb98;">void</span> *)0, 0);   
  mptr = shared_mem_ptr;        
  pthread_mutexattr_init(&amp;mutex_shared_attr);   
  pthread_mutexattr_setshared(&amp;mutex_shared_attr, PTHREAD_PROCESS_SHARED);      
  pthread_mutex_init(mptr, &amp;mutex_shared_attr); 
  <span style="color: #00ffff;">if</span> ((child_pid = fork()) == 0) {      
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">child </span><span style="color: #ff7f24;">*/</span>   
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">create more threads </span><span style="color: #ff7f24;">*/</span>    
           pthread_mutex_lock(mptr);    
           .    
  } <span style="color: #00ffff;">else</span> {      
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">parent </span><span style="color: #ff7f24;">*/</span>  
           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">create more threads </span><span style="color: #ff7f24;">*/</span>    
           pthread_mutex_lock(mptr);    
           .    
}
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Condition Variables</h3>
<div class="outline-text-3" id="text-4-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;pthread.h&gt;</span>    
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">TCOUNT</span> 10       
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">WATCH_COUNT</span> 12  
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 0;  
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">count_mutex</span> = PTHREAD_MUTEX_INITIALIZER;        
<span style="color: #98fb98;">pthread_cond_t</span> <span style="color: #eedd82;">count_threshold_cv</span> = PTHREAD_COND_INITIALIZER;   
<span style="color: #98fb98;">int</span>  <span style="color: #eedd82;">thread_ids</span>[3] = {0,1,2};   
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
     <span style="color: #98fb98;">int</span>      <span style="color: #eedd82;">i</span>;        
     <span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">threads</span>[3];      
     pthread_create(&amp;threads[0],<span style="color: #7fffd4;">NULL</span>,inc_count, &amp;thread_ids[0]);        
     pthread_create(&amp;threads[1],<span style="color: #7fffd4;">NULL</span>,inc_count, &amp;thread_ids[1]);        
     pthread_create(&amp;threads[2],<span style="color: #7fffd4;">NULL</span>,watch_count, &amp;thread_ids[2]);      
     <span style="color: #00ffff;">for</span> (i = 0; i &lt; 3; i++) {  
              pthread_join(threads[i], <span style="color: #7fffd4;">NULL</span>);   
     }  
     <span style="color: #00ffff;">return</span> 0;  
}       
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">watch_count</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">idp</span>)      
{       
     pthread_mutex_lock(&amp;count_mutex)   
     <span style="color: #00ffff;">while</span> (count &lt;= WATCH_COUNT) {     
              pthread_cond_wait(&amp;count_threshold_cv,    
                               &amp;count_mutex);   
              printf(<span style="color: #ffa07a;">"watch_count(): Thread %d,Count is %d\n"</span>,  
                   *idp, count);        
     }  
     pthread_mutex_unlock(&amp;count_mutex);        
}       
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">inc_count</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">idp</span>)        
{       
     <span style="color: #00ffff;">for</span> (i =0; i &lt; TCOUNT; i++) {      
              pthread_mutex_lock(&amp;count_mutex); 
              count++;  
              printf(<span style="color: #ffc0cb; font-weight: bold;">"</span><span style="color: #ffa07a;">inc_count(): Thread %d, old count %d,\    </span>
<span style="color: #ffa07a;">                   new count %d\n"</span>, *idp, count - 1, count );   
              <span style="color: #00ffff;">if</span> (count == WATCH_COUNT) 
                   pthread_cond_signal(&amp;count_threshold_cv);    
              pthread_mutex_unlock(&amp;count_mutex);       
     }  
}
</pre>
</div>

<p>
A condition variable has a data type of <code>pthread_cond_t</code>. You can
initialize it statically as we do in Example 3-7, or you can
initialize it dynamically by calling pthread<sub>cond</sub><sub>init</sub>, as
follows:        
</p>

<p>
<code>pthread_cond_init(&amp;count_threshold_cv, NULL);</code>
</p>

<p>
If count is not the desired value, the thread calls <code>pthread_cond_wait</code>
to put itself into a wait on the <code>count_threshold_cv</code> condition
variable. The <code>pthread_cond_wait</code> function releases the count mutex
while the thread is waiting so other threads have the opportunity to
modify count.
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-4-1" name="sec-4-4-1"></a>The thread can wait on the condition variable.<br  /><div class="outline-text-4" id="text-4-4-1">
<p>
To wait on a condition variable, a thread calls pthread<sub>cond</sub><sub>wait</sub> or
pthread<sub>cond</sub><sub>timedwait</sub>. 
</p>
</div>
</li>
<li><a id="sec-4-4-2" name="sec-4-4-2"></a>it can signal other threads waiting on the condition variable.<br  /><div class="outline-text-4" id="text-4-4-2">
<p>
To release threads that are waiting on a condition variable, a thread
calls pthread<sub>cond</sub><sub>signal</sub> or pthread<sub>cond</sub><sub>broadcast</sub>.
</p>
</div>
</li>

<li><a id="sec-4-4-3" name="sec-4-4-3"></a>Using a Mutex with a Condition Variable<br  /><div class="outline-text-4" id="text-4-4-3">
<p>
It is important to use condition variables and mutexes together
properly.
</p>

<p>
A call to <code>pthread_cond_wait</code> requires that a locked mutex be passed in
along with the condition variable. The system releases the mutex on
the caller's behalf when the wait for the condition begins. In concert
with the actions of the waiting thread, the thread that issues the
<code>pthread_cond_signal</code> or <code>pthread_cond_broadcast</code> call holds the mutex at
the time of the call but must release it after the call. Then, when
the system wakes it up, a waiting thread can regain control of the
mutex. It too must release the mutex when it's finished with
it.        
</p>
</div>
</li>

<li><a id="sec-4-4-4" name="sec-4-4-4"></a>When Many Threads Are Waiting<br  /><div class="outline-text-4" id="text-4-4-4">
<p>
If all waiting threads are of the same priority, they are released in
a first-in first-out order for each <code>pthread_cond_signal</code> call that's
issued
</p>

<p>
The <code>pthread_cond_broadcast</code> function releases all threads at once from
their waits on the condition variable, but there is a hitch.
</p>

<p>
It does so by applying the same criterion it uses when selecting the
thread it wakes when a <code>phread_cond_signal</code> call signals a
condition—scheduling order.The other threads are moved to the queue
of threads that are waiting to acquire the mutex.
</p>
</div>
</li>
<li><a id="sec-4-4-5" name="sec-4-4-5"></a>Checking the Condition on Wake Up: Spurious Wake Ups<br  /><div class="outline-text-4" id="text-4-4-5">
<p>
Well, we check the event one more time primarily to ensure
correctness: if multiple threads were waiting on the same condition
variable, another thread could have already been awakened, perhaps
decrementing the count, before our thread was able to run. Second, we
want to guard against a condition known as a spurious wake up. 
</p>
</div>
</li>
<li><a id="sec-4-4-6" name="sec-4-4-6"></a>Condition Variable Attributes<br  /><div class="outline-text-4" id="text-4-4-6">
<p>
A Pthreads condition variable attribute object is of data type
<code>pthread_condattr_t</code>.You initialize and deinitialize the condition
variable attribute object by calling <code>pthread_condattr_init</code> and
<code>pthread_condattr_destroy</code>, respectively.
</p>
</div>
</li></ul>
</div>






<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Reader/Writer Locks</h3>
<div class="outline-text-3" id="text-4-5">
<p>
We'll start by defining a reader/writer variable of type
<code>pthread_rdwr_t</code> and by creating the functions that operate on it
</p>
</div>
<ul class="org-ul"><li><a id="sec-4-5-1" name="sec-4-5-1"></a>Reader/Writer Lock Functions<br  /><div class="outline-text-4" id="text-4-5-1">
<div class="org-src-container">

<pre class="src src-sh">pthread_rdwr_init_np    Initialize reader/writer lock   
pthread_rdwr_rlock_np   Obtain read lock        
pthread_rdwr_wlock_np   Obtain write lock       
pthread_rdwr_runlock_np Release read lock       
pthread_rdwr_wunlock_np Release write lock
</pre>
</div>
</div>
</li>
<li><a id="sec-4-5-2" name="sec-4-5-2"></a>implement<br  /><div class="outline-text-4" id="text-4-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">initialize</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_init_np</span>(<span style="color: #98fb98;">pthread_rdwr_t</span> *<span style="color: #eedd82;">rdwrp</span>, <span style="color: #98fb98;">pthread_rdwrattr_t</span>  *<span style="color: #eedd82;">attrp</span> )    
{       
          rdwrp-&gt;readers_reading = 0;   
          rdwrp-&gt;writer_writing = 0;    
          pthread_mutex_init(&amp;(rdwrp-&gt;mutex), <span style="color: #7fffd4;">NULL</span>);    
          pthread_cond_init(&amp;(rdwrp-&gt;lock_free), <span style="color: #7fffd4;">NULL</span>); 
          <span style="color: #00ffff;">return</span> 0;     
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">read locking a read/write lock</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_rlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>)     
{       
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">while</span>(rdwrp-&gt;writer_writing) {        
                  pthread_cond_wait(&amp;(rdwrp-&gt;lock_free), &amp;(rdwrp-&gt;mutex));      
          }     
          rdwrp-&gt;readers_reading++;     
          pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));        
          <span style="color: #00ffff;">return</span> 0;     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">write locking a read/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_wlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>)     
{       
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">while</span> (rdwrp-&gt;writer_writing || rdwrp-&gt;readers_reading) {     
                   pthread_cond_wait(&amp;(rdwrp-&gt;lock_free), &amp;(rdwrp-&gt;mutex));     
          }     
          rdwrp-&gt;writer_writing++;      
          pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));        
          <span style="color: #00ffff;">return</span> 0;     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">read unlocking a read/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_runlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>) { 
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">if</span> (rdwrp-&gt;readers_reading == 0) {    
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> -1;  
          } <span style="color: #00ffff;">else</span> {      
                    rdwrp-&gt;readers_reading--;   
                    <span style="color: #00ffff;">if</span> (rdwrp-&gt;readers_reading == 0)    
                              pthread_cond_signal(&amp;(rdwrp-&gt;lock_free)); 
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> 0;   
          }     
}
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">write unlocking a reader/write lock</span>
        <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_rdwr_wunlock_np</span>(<span style="color: #98fb98;">pthread_rdwr_t_np</span> *<span style="color: #eedd82;">rdwrp</span>) { 
          pthread_mutex_lock(&amp;(rdwrp-&gt;mutex));  
          <span style="color: #00ffff;">if</span> (rdwrp-&gt;writer_writing == 0) {     
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> -1;  
          } <span style="color: #00ffff;">else</span> {      
                    rdwrp-&gt;writer_writing = 0;  
                    pthread_cond_broadcast(&amp;(rdwrp-&gt;lock_free));        
                    pthread_mutex_unlock(&amp;(rdwrp-&gt;mutex));      
                    <span style="color: #00ffff;">return</span> 0;   
          }     
}
</pre>
</div>
</div>
</li>



<li><a id="sec-4-5-3" name="sec-4-5-3"></a>issue<br  /><div class="outline-text-4" id="text-4-5-3">
<p>
If the lock is currently held by a reader and a writer is already
waiting, any reader that comes along next will get the lock before
the waiting writer. As long as one or more readers are waiting for
the lock, regardless of when they made their requests or where in the
waiting lists they're queued relative to any potential writers, the
lock will continue to be held for reading.
</p>

<p>
The decision of how to handle incoming reads versus pending writes
depends on the priorities of a given system.        
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Synchronization in the ATM Server</h3>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Thread Pools</h3>
<div class="outline-text-3" id="text-4-7">
<p>
but it can slow our server in a couple of different ways:        
</p>
<ul class="org-ul">
<li>We don't reuse idle threads to handle new requests. Rather, we
create—and destroy—a thread for each request we receive.
Consequently, our server spends a lot of time in the Pthreads
library.
</li>
<li>We've added to each request's processing time (a request's latency,
to use a term from an engineering design spec) the time it takes to
create a thread. No wonder our ATM customers keep tapping the Enter
button and scowling at the camera!
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 4 - Managing Pthreads</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Setting Thread Attributes</h3>
<div class="outline-text-3" id="text-5-1">
<p>
we'd perform the following steps:        
</p>
<ol class="org-ol">
<li>Define an attribute object of type <code>pthread_attr_t</code>.        
</li>
<li>Call <code>pthread_attr_init</code> to declare and initialize the attribute object.        
</li>
<li>Make calls to specific Pthreads functions to set individual
attributes in the object.
</li>
<li>Specify the fully initialized attribute object to the
<code>pthread_create</code> call that creates the thread.
</li>
</ol>
</div>

<ul class="org-ul"><li><a id="sec-5-1-1" name="sec-5-1-1"></a>Setting a Thread's Stack Size<br  /><div class="outline-text-4" id="text-5-1-1">
<p>
a process stack normally starts in high memory and works its way down
in memory without anything in its way until it reaches 0. For a
process with individual threads, one thread's stack is bounded by the
start of the next thread's stack, even if the next thread isn't using
all of its stack space.
</p>

<p>
To set a thread's stack size, we call <code>pthread_attr_init</code> to declare and
initialize a custom thread attribute object (<code>pthread_attr_t</code>)
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">  #define</span> <span style="color: #eedd82;">MIN_REQ_SSIZE</span> 81920     
  <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">default_stack_size</span>;      
  <span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">stack_size_custom_attr</span>;

  pthread_attr_init(&amp;stack_size_custom_attr);

<span style="color: #b0c4de;">  #ifdef</span> _POSIX_THREAD_ATTR_STACKSIZE     
  pthread_attr_getstacksize(&amp;stack_size_custom_attr,      
                 &amp;default_stack_size);    
  <span style="color: #00ffff;">if</span> (default_stack_size &lt; MIN_REQ_SSIZE) {;
    pthread_attr_setstacksize(&amp;stack_size_custom_attr,  
                   (<span style="color: #98fb98;">size_t</span>)MIN_REQ_SSIZE);      
}       
<span style="color: #b0c4de;">#endif</span>
</pre>
</div>
</div>
</li>
<li><a id="sec-5-1-2" name="sec-5-1-2"></a>Setting a Thread's Detached State<br  /><div class="outline-text-4" id="text-5-1-2">
<p>
Detaching from a thread informs the Pthreads library that no other
thread will use the pthread<sub>join</sub> mechanism to synchronize with the
thread's exiting. Because the library doesn't preserve the exit status
of a detached thread, it can operate more efficiently and make the
library resources that were associated with a thread available for
reuse more quickly. If no other thread cares when a particular thread
in your program exits, consider detaching that thread.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">detached_attr</span>;
pthread_attr_setdetachedstate(&amp;detached_attr, PTHREAD_CREATE_DETACHED);
pthread_create(&amp;thread, &amp;detached_attr, ...);
</pre>
</div>
</div>
</li></ul>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">The <code>pthread_once</code> Mechanism</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The <code>pthread_once</code> mechanism is the tool of choice for these situations.
It, like mutexes and condition variables, is a synchronization tool,
but its specialty is handling synchronization among threads at
initialization time. 
</p>

<p>
Remember, our library's multithreaded. How do we know whether or not
another thread might be trying to initialize the same objects
simultaneously?
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-2-1" name="sec-5-2-1"></a>Example: The ATM Server's Communication Module<br  /><div class="outline-text-4" id="text-5-2-1">
<p>
Thread A checks the value of <code>srv_comm_inited</code> and finds FALSE. Thread B
checks the value and also finds it FALSE. Then they both go forward
and call <code>srv_comm_init</code>.        
</p>

<p>
We'll consider two viable solutions:        
</p>
<ul class="org-ul">
<li>Adding a mutex to protect the <code>srv_comm_inited</code> flag and
<code>server_comm_init</code> routine. Using <code>PTHREAD_MUTEX_INITIALIZER</code>, we'll
statically initialize this mutex.        
</li>
<li>Designating that the entire routine needs special synchronization
handling by calling the <code>pthread_once</code> function.
</li>
</ul>
</div>
</li>

<li><a id="sec-5-2-2" name="sec-5-2-2"></a>Using the <code>pthread_once</code> mechanism<br  /><div class="outline-text-4" id="text-5-2-2">
<p>
If we use the <code>server_comm_init</code> routine only through the <code>pthread_once</code>
mechanism, we can make the following synchronization guarantees:
</p>
<ul class="org-ul">
<li>No matter how many times it is invoked by one or more threads, the
routine will be executed only once by its first caller.
</li>
<li>No caller will exit from the <code>pthread_once</code>
  mechanism until the routine's first caller has returned
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_once_t</span>      <span style="color: #eedd82;">srv_comm_inited_once</span> = PTHREAD_ONCE_INIT;   

pthread_once(&amp;srv_comm_inited_once, server_comm_init);
</pre>
</div>

<p>
no longer has to test a flag to determine whether to proceed with
initialization. Instead, it calls <code>pthread_once</code>, specifying the once
block and the routine
</p>

<p>
You can declare multiple once blocks in a program, associating each
with a different routine. Be careful, though. Once you associate a
routine with the <code>pthread_once</code> mechanism, you must always call it
through a <code>pthread_once</code> call, using the same once block. You cannot
call the routine directly elsewhere in your program without subverting
the synchronization the <code>pthread_once</code> mechanism is meant to provide
</p>

<p>
Notice that the pthread<sub>once</sub> interface does not allow you to pass
arguments to the routine that is protected by the once block. If
you're trying to fit a predefined routine with arguments into the
pthread<sub>once</sub> mechanism, you'll have to fiddle a bit with global
variables, wrapper routines, or environment variables to get it to
work properly.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Keys: Using Thread-Specific Data</h3>
<div class="outline-text-3" id="text-5-3">
</div><ul class="org-ul"><li><a id="sec-5-3-1" name="sec-5-3-1"></a>Overview<br  /><div class="outline-text-4" id="text-5-3-1">
<p>
To maintain long-lived data associated with a thread, we normally have two options:        
</p>
<ul class="org-ul">
<li>Pass the data as an argument to each call the thread makes.        
</li>
<li>Store the data in a global variable associated with the thread.

<p>
Most likely you don't have the option of redefining the library's
 call arguments. Because you don't necessarily know at compile time
 how many threads will be making library calls, it's very difficult
 to define an adequate number of global variables with the right
 amount of storage. Fortunately, the Pthreads standard provides a
 clever way of maintaining thread-specific data in such cases.
</p>
</li>
</ul>

<p>
Certain applications also use thread-specific data with keys to
associate special properties with a thread in one routine and then
retrieve them in another. Some examples include:
</p>
<ul class="org-ul">
<li>A resource management module (such as a memory manager or a file
manager) could use a key to point to a record of the resources that
have been allocated for a given thread. When the thread makes a call
to allocate more resources, the module uses the key to retrieve the
thread's record and process its request.
</li>
<li>A performance statistics module for threads could use a key to point
to a location where it saves the starting time for a calling thread.
</li>
<li>A debugging module that maintains mutex statistics could use a key
to point to a per-thread count of mutex locks and unlocks.
</li>
<li>A thread-specific exception-handling module, when servicing a try
call (which starts execution of the normal code path), could use a
key to point to a location to which to jump in case the thread
encounters an exception. The occurrence of an exception triggers a
catch call to the module. The module checks the key to determine
where to unwind the thread's execution.
</li>
<li>A random number generation module could use a key to point to a
location where it maintains a unique seed value and number stream
for each thread that calls it to obtain random numbers.
</li>
</ul>

<p>
These examples share some common characteristics:        
</p>
<ul class="org-ul">
<li>They are libraries with internal state.        
</li>
<li>They don't require their callers to provide context in interface
arguments. They don't burden the caller with maintaining this type
of context in the global environment.
</li>
<li>In a nonthreaded environment, the data to which the key refers would
normally be stored as static data.
</li>
</ul>

<p>
Note that thread-specific data is not a distinct data section like
global, heap, and stack. It offers no special system protection or
performance guarantees; it's as private or shared as other data in the
same data section. There are no special advantages to using
thread-specific data if you aren't writing a library and if you know
exactly how many threads will be in your program at a given time. If
this is the case, just allocate a global array with an element for
each known thread and store each thread's data in a separate element.
</p>
</div>
</li>

<li><a id="sec-5-3-2" name="sec-5-3-2"></a>Initializing a Key: <code>pthread_key_create</code><br  /><div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">

<pre class="src src-c">        <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">pthread_key_t</span> <span style="color: #eedd82;">conn_key</span>;
     pthread_key_create(&amp;conn_key, (<span style="color: #98fb98;">void</span> *)free_conn);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">free_conn</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">connp</span>)      
{       
       free(connp);     
}
</pre>
</div>

<p>
The <code>pthread_key_create</code> call takes two arguments: the key and a
destructor routine. 
</p>

<p>
When you're done with a key, call <code>pthread_key_delete</code> to allow
the library to recover resources associated with the key
itself.
</p>
</div>
</li>
<li><a id="sec-5-3-3" name="sec-5-3-3"></a>Associating Data with a Key<br  /><div class="outline-text-4" id="text-5-3-3">
<p>
You must always use <code>pthread_setspecific</code> and <code>pthread_getspecific</code> to
refer to any data item that is being managed by a key.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">connp</span>;
connp = (<span style="color: #98fb98;">int</span> *)malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
pthread_setspecific(conn_key, (<span style="color: #98fb98;">void</span> *)connp);
</pre>
</div>

<p>
The pthread<sub>setspecific</sub> routine takes, as an argument, a pointer to
the data to be associated with the key—not the data itself. 
</p>
</div>
</li>

<li><a id="sec-5-3-4" name="sec-5-3-4"></a>Retrieving Data from a Key<br  /><div class="outline-text-4" id="text-5-3-4">
<p>
Each routine uses a pointer, <code>saved_connp</code>, to point to the connection
identifier, 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">saved_connp</span>;
pthread_getspecific(conn_key, (<span style="color: #98fb98;">void</span> **)&amp;saved_connp);   
write(*saved_connp,...);
</pre>
</div>
</div>
</li>

<li><a id="sec-5-3-5" name="sec-5-3-5"></a>Destructors<br  /></li></ul>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Cancellation</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Cancellation allows one thread to terminate another.
</p>

<p>
Now you must reckon whether the thread you've targeted can be canceled
at all. The ability of a thread to go away or not go away when asked
by another thread is known as its cancelability state. Now you must
consider when it might go away—maybe immediately, maybe a bit later.
The degree to which a thread persists after it has been asked to go
away is known as its cancelability type
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-4-1" name="sec-5-4-1"></a>The Complication with Cancellation<br  /><div class="outline-text-4" id="text-5-4-1">
<p>
The simplest approach is to restrict the use of cancellation to
threads that execute only in simple routines that do not hold locks or
ever put shared data in an inconsistent state. Another option is to
restrict cancellation to certain points at which a thread is known to
have neither locks nor resources. Lastly, you could create a cleanup
stack for the thread that is to be canceled; it can then use the
cleanup stack to release locks and reset the state of shared data.
</p>
</div>
</li>

<li><a id="sec-5-4-2" name="sec-5-4-2"></a>Cancelability Types and States<br  /><div class="outline-text-4" id="text-5-4-2">
<p>
Because canceling a thread that holds locks and manipulates shared
data can be a tricky procedure, the Pthreads standard provides a
mechanism by which you can set a given thread's cancel ability 
</p>

<p>
A thread can set its own cancel ability only at run time, dynamically,
by calling into the Pthreads library.
</p>
</div>
</li>

<li><a id="sec-5-4-3" name="sec-5-4-3"></a>Cancellation Points: More on Deferred Cancellation<br  /><div class="outline-text-4" id="text-5-4-3">
<p>
These pending cancellations are delivered to a thread at defined
locations in its code path. These locations are known as cancellation
points, and they come in two flavors:
</p>

<ul class="org-ul">
<li>Automatic cancellation points
(<code>pthread_cond_wait</code>, <code>pthread_cond_timedwait</code>, and <code>pthread_join</code>). The
Pthreads library defines these function calls as cancellation points
because they can block the calling thread. Rather than maintain the
overhead of a blocked routine that's destined to be canceled, the
Pthreads library considers these calls to be a license to kill the
thread. Note that, if the thread for which the cancellation is
pending does not call any of these functions, it may never actually
be terminated. This is one of the reasons you may need to consider
using a programmer-defined cancellation point.
</li>
<li>Programmer-defined cancellation points (<code>pthread_testcancel</code>).To force
a pending cancellation to be delivered at a particular point ina
thread's code path, insert a call to pthread<sub>testcancel</sub>. The
<code>pthread_testcancel</code> function causes any pending cancellation to be
delivered to the thread at the program location where it occurs. If
no cancellation is pending on the thread, nothing happens. Thus, you
can freely insert this call at those places in a thread's code path
where it's safe for the thread to terminate. It's also prudent to
call pthread<sub>testcancel</sub> before a thread starts a time-consuming
operation. If a cancellation is pending on the thread, it's better
to terminate it as soon as possible, rather than have it continue
and consume system resources needlessly.
</li>
</ul>
</div>
</li>

<li><a id="sec-5-4-4" name="sec-5-4-4"></a>A Simple Cancellation Example<br  /><div class="outline-text-4" id="text-5-4-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">main:</span>

  <span style="color: #ff7f24;">/**** </span><span style="color: #ff7f24;">cancel each thread ***</span><span style="color: #ff7f24;">*/</span>        
  <span style="color: #00ffff;">for</span> (i = 0; i &lt; NUM_THREADS; i++) {;  
    pthread_cancel(threads[i]); 
  }
<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">1.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_state</span>;
pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;last_state);

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">2.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">last_state</span>, <span style="color: #eedd82;">last_type</span>;
pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;last_state);
pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &amp;last_type);
pthread_testcancel();

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">3.</span>
pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;last_type); 
pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;last_state);
</pre>
</div>
</div>
</li>
<li><a id="sec-5-4-5" name="sec-5-4-5"></a>Cleanup Stacks<br  /><div class="outline-text-4" id="text-5-4-5">
<p>
Pthreads associates a cleanup stack with each thread.
</p>

<p>
A cleanup stack contains pointers to routines to be executed just
before the thread terminates.By default the stack is empty; you use
<code>pthread_cleanup_push</code> to add routines to the stack, and
<code>pthread_cleanup_pop</code> to remove them. When the library processes a
thread's termination, the thread executes routines from the cleanup
stack in last-in first-out order.
</p>

<div class="org-src-container">

<pre class="src src-c"> <span style="color: #ff7f24;">/*     </span>
<span style="color: #ff7f24;"> Cleanup routine: last_breath   </span>
<span style="color: #ff7f24;"> </span><span style="color: #ff7f24;">*/</span>     
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">last_breath</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">messagep</span>)        
{       
  printf(<span style="color: #ffa07a;">"\n\n%s last_breath cleanup routine: freeing 0x%x\n\n"</span>, messagep,      
          messagep);    
  free(messagep);       
}

pthread_cleanup_push((<span style="color: #98fb98;">void</span> *)last_breath, (<span style="color: #98fb98;">void</span> *)messagep);
</pre>
</div>

<p>
First, pthread<sub>cleanup</sub><sub>pop</sub> takes a single argument—an integer that can have either of two values:        
</p>
<ul class="org-ul">
<li>If the value of this argument is 1, the thread that called
pthread<sub>cleanup</sub><sub>pop</sub> executes the cleanup routine whose pointer is
being removed from the cleanup stack. Afterwards, the thread resumes
at the line following its pthread<sub>cleanup</sub><sub>pop</sub> call. This allows a
thread to execute a cleanup routine whether or not it is actually
being terminated.
</li>
<li>If the value of this argument is 0, the pointer to the routine is
popped off the cleanup stack, but the routine itself does not
execute.
</li>
</ul>

<p>
Second, the Pthreads standard requires that there be one
<code>pthread_cleanup_pop</code> for each <code>pthread_cleanup_push</code> within a given
lexical scope of code.
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-4-5-1" name="sec-5-4-5-1"></a>Cancellation in the ATM Server<br  /></li></ul>
</li></ul>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Scheduling Pthreads</h3>
<div class="outline-text-3" id="text-5-5">
<p>
If your system supports the scheduling programming interface, the
compile-time constant <code>_POSIX_THREAD_PRIORITY_SCHEDULING</code> will be TRUE.
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-5-1" name="sec-5-5-1"></a>Scheduling Priority and Policy<br  /><div class="outline-text-4" id="text-5-5-1">
<p>
The eligibility of any given thread for special scheduling treatment
is determined by the settings of two thread-specific attributes:
</p>
<ul class="org-ul">
<li>Scheduling priority        A thread's scheduling priority, in relation to
that of other threads, determines which thread gets preferential
access to the available CPUs at any given time.
</li>
<li>Scheduling policy        A thread's scheduling policy is a way of
expressing how threads of the same priority run and share the
available CPUs.
</li>
</ul>
</div>
</li>
<li><a id="sec-5-5-2" name="sec-5-5-2"></a>Scheduling Scope and Allocation Domains<br  /><div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;
pthread_attr_init(&amp;custom_sched_attr);
pthread_attr_setscope(&amp;custom_sched_attr, PTHREAD_SCOPE_SYSTEM);        
pthread_create(&amp;thread, &amp;custom_sched_attr, ...);
</pre>
</div>

<p>
The <code>pthread_attr_setscope</code> function sets the scheduling-scope attribute
in a thread attribute object to either system-scope scheduling
(<code>PTHREAD_SCOPE_SYSTEM</code>), or process-scope scheduling
(<code>PTHREAD_SCOPE_PROCESS</code>).
</p>


<ul class="org-ul">
<li>When we say pool of threads, we mean:        
In process scope: all other threads in the same process        
In system scope: all threads of all processes in the same allocation domain        
</li>

<li>When we say scheduler, we mean:        
In process scope: the Pthreads library and/or the scheduler in the operating system's kernel        
In system scope: the scheduler in the operating system's kernel        
</li>

<li>When we say processing slot, we mean:        
In process scope: the portion of CPU time allocated to the process as a whole within its allocation domain        
In system scope: the portion of CPU time allocated to a specific thread within its allocation domain
</li>
</ul>
</div>
</li>

<li><a id="sec-5-5-3" name="sec-5-5-3"></a>Runnable and Blocked Threads<br  /></li>
<li><a id="sec-5-5-4" name="sec-5-5-4"></a>Scheduling Policy<br  /><div class="outline-text-4" id="text-5-5-4">
<p>
The two main scheduling policies are <code>SCHED_FIFO</code> and <code>SCHED-RR</code>:
</p>
<ul class="org-ul">
<li><code>SCHED_FIFO</code> This policy (first-in first-out) lets a thread run
until it either exits or blocks. As soon as it becomes unblocked, a
blocked thread that has given up its processing slot is placed at
the end of its priority queue.
</li>
<li><code>SCHED_RR</code> This policy (round robin) allows a thread to run for
only a fixed amount of time before it must yield its processing slot
to another thread of the same priority. This fixed amount of time is
usually referred to as a quantum. When a thread is interrupted, it
is placed at the end of its priority queue.
</li>
</ul>
</div>
</li>
<li><a id="sec-5-5-5" name="sec-5-5-5"></a>Using Priorities and Policies<br  /></li>
<li><a id="sec-5-5-6" name="sec-5-5-6"></a>Setting Scheduling Policy and Priority<br  /><div class="outline-text-4" id="text-5-5-6">
<p>
We specify it in calls to <code>pthread_attr_setschedpolicy</code> to set the
scheduling policy and <code>pthread_attr_setschedparam</code> to set the scheduling
priority
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;       
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fifo_max_prio</span>, <span style="color: #eedd82;">fifo_min_prio</span>;       
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sched_param</span> <span style="color: #eedd82;">fifo_param</span>;  
.       
.       
  pthread_attr_init(&amp;custom_sched_attr);        
  pthread_attr_setinheritsched(&amp;custom_sched_attr, PTHREAD_EXPLICIT_SCHED);     
  pthread_attr_setschedpolicy(&amp;custom_sched_attr, SCHED_FIFO);  
  fifo_max_prio = sched_get_priority_max(SCHED_FIFO);   
  fifo_min_prio = sched_get_priority_min(SCHED_FIFO);   
  fifo_mid_prio = (fifo_min_prio + fifo_max_prio)/2;    
  fifo_param.sched_priority = fifo_mid_prio;    
  pthread_attr_setschedparam(&amp;custom_sched_attr, &amp;fifo_param);  
  pthread_create(&amp;(threads[i]), &amp;custom_sched_attr, ....);
</pre>
</div>

<p>
The pthread<sub>attr</sub><sub>setschedparam</sub> function takes two arguments: the first is a thread attribute object, the second is a curious thing defined in the POSIX.1b standard and known as a struct sched<sub>param</sub>. It looks like this:        
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sched_param</span> {;   
          <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sched_priority</span>;   
}
</pre>
</div>

<p>
The absolute values and actual range of the priorities depend upon the
implementation, but one thing's for certain—you can use
<code>sched_get_priority_max</code> and <code>sched_get_priority_min</code> to get a handle on
them.
</p>

<p>
Setting Policy and Priority Dynamically (sched.c)        
</p>

<div class="org-src-container">

<pre class="src src-c">fifo_sched_param.sched_priority = fifo_min_prio;        
pthread_setschedparam(threads[i], SCHED_FIFO, &amp;fifo_min_prio)
</pre>
</div>

<p>
the <code>pthread_setschedparam</code> call sets both policy and priority at the
same time. 
</p>
</div>
</li>

<li><a id="sec-5-5-7" name="sec-5-5-7"></a>Inheritance<br  /><div class="outline-text-4" id="text-5-5-7">
<p>
Instead, you can specify that each thread should inherit its
scheduling characteristics from the thread that created it. Like other
per-thread scheduling attributes, the inheritance attribute is
specified in the attribute object used at thread creation
</p>


<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_attr_t</span> <span style="color: #eedd82;">custom_sched_attr</span>;       
        .       
pthread_attr_init(&amp;custom_sched_attr);  
pthread_attr_setinheritsched(&amp;custom_sched_attr, PTHREAD_INHERIT_SCHED) 
        .       
pthread_create(&amp;thread, &amp;custom_sched_attr, ...);
</pre>
</div>

<p>
The <code>pthread_attr_setinheritsched</code> function takes a thread attribute
object as its first argument and as its second argument either the
<code>PTHREAD_INHERIT_SCHED</code> flag or the <code>PTHREAD_EXPLICIT_SCHED</code> flag. You can
obtain the current inheritance attribute from an attribute object by
calling <code>pthread_attr_getinheritsched</code>
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">Mutex Scheduling Attributes</h3>
<div class="outline-text-3" id="text-5-6">
<p>
The Pthreads standard allows (but does not require) implementations to
design mutexes that can give a priority boost to low priority threads
that hold them. We can associate a mutex with either of two priority
protocols that provide this feature: priority ceiling or priority
inheritance. 
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-6-1" name="sec-5-6-1"></a>Priority Ceiling<br  /><div class="outline-text-4" id="text-5-6-1">
<p>
The priority ceiling protocol associates a scheduling priority with a
mutex. Thus equipped, a mutex can assign its holder an effective
priority equal to its own, if the mutex holder has a lower priority to
begin with.
</p>

<p>
If your platform supports the priority ceiling protocol, the
compile-time constant <code>_POSIX_THREAD_PRIO_PROTECT</code> will be defined.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">m1</span>;     
<span style="color: #98fb98;">pthread_mutexattr_t</span> <span style="color: #eedd82;">mutexattr_prioceiling</span>;      
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mutex_protocol</span>, <span style="color: #eedd82;">high_prio</span>;  
.       
high_prio = sched_get_priority_max(SCHED_FIFO); 
.       
pthread_mutexattr_init(&amp;mutexattr_prioceiling); 
pthread_mutexattr_getprotocol(&amp;mutexattr_prioceiling, &amp;mutex_protocol); 
pthread_mutexattr_setprotocol(&amp;mutexattr_prioceiling, PTHREAD_PRIO_PROTECT);    
pthread_mutexattr_setprioceiling(&amp;mutexattr_prioceiling, high_prio);    
pthread_mutex_init(&amp;m1, &amp;mutexattr_prioceiling);
</pre>
</div>

<p>
The priority protocol attribute can have one of three values:        
</p>
<ul class="org-ul">
<li><code>PTHREAD_PRIO_NONE</code>  The mutex uses no priority protocol.        
</li>
<li><code>PTHREAD_PRIO_PROTECT</code>  The mutex uses the priority ceiling protocol.        
</li>
<li><code>PTHREAD_PRIO_INHERIT</code>   The mutex uses the priority inheritance
protocol.
</li>
</ul>
</div>
</li>

<li><a id="sec-5-6-2" name="sec-5-6-2"></a>Priority Inheritance<br  /><div class="outline-text-4" id="text-5-6-2">
<p>
The priority inheritance protocol lets a mutex elevate the
priority of its holder to that of the waiting thread with the
highest priority.
</p>

<p>
Because the priority inheritance protocol awards a priority boost to a
mutex holder only when it's absolutely needed, it can be more
efficient than the priority ceiling protocol.
</p>

<p>
If your platform supports the priority inheritance feature,
the compile-time constant <code>_POSIX_THREAD_PRIO_INHERIT</code> will be
TRUE
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">m1</span>;     
<span style="color: #98fb98;">pthread_mutexattr_t</span> <span style="color: #eedd82;">mutexattr_prioinherit</span>;      
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mutex_procotol</span>;     
.       
pthread_mutexattr_init(&amp;mutexattr_prioinherit); 
pthread_mutexattr_getprotocol(&amp;mutexattr_prioinherit, &amp;mutex_protocol); 
<span style="color: #00ffff;">if</span> (mutex_protocol != PTHREAD_PRIO_INHERIT) {;  
    pthread_mutexattr_setprotocol(&amp;mutexattr_prioinherit, PTHREAD_PRIO_INHERIT);        
}       
pthread_mutex_init(&amp;m1, &amp;mutexattr_prioinherit);
</pre>
</div>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 5 - Pthreads and UNIX</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Overview</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Threadsafe libraries 
Most system libraries maintain internal data for the currently
executing process in internal data. To allow multiple threads
from the same process to execute library routines
simultaneously, library implementors must somehow protect this
data from unsynchronized accesses by otherwise cooperative
threads. Libraries that eliminate such race conditions are
known as threadsafe libraries. 
</li>

<li>Cancellation-safe library functions 
      If a thread is canceled while in the middle of a library call
that is modifying a library's internal data, it may exit, leaving
the data in an inconsistent or corrupted state. A library function
in which a thread can be canceled safely is known as a
cancellation-safe library routine.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Threads and Signals</h3>
<div class="outline-text-3" id="text-6-2">
<p>
This presented the Pthreads standard committee with three chief
challenges:         
</p>
<ul class="org-ul">
<li>A thread should be able to send and receive signals, yet, to
allow this, a Pthreads implementation cannot subvert a
single-threaded process's ability to process signals in the
way it always has.
</li>
<li>When a signal is delivered to a multithreaded process, a Pthreads
implementation must select one of the threads to perform the
required action. 
</li>
<li>What can a thread do, while in a signal handler, that won't
interfere with its mainline execution?
</li>
</ul>
</div>
<ul class="org-ul"><li><a id="sec-6-2-1" name="sec-6-2-1"></a>Traditional Signal Processing<br  /><div class="outline-text-4" id="text-6-2-1">
<p>
A process may choose to:
</p>
<ul class="org-ul">
<li>Ignore the signal (<code>SIG_IGN</code>)        
</li>
<li>Use the default action (<code>SIG_DFL</code>)
</li>
<li>Catch the signal, and execute a user-specified handler routine
</li>
</ul>

<p>
The arrival of a signal interrupts a process at its current point of
execution and transfers execution to a signal-handling routine. When
the signal handler returns, the process resumes at its prior execution
point. 
</p>
</div>
</li>

<li><a id="sec-6-2-2" name="sec-6-2-2"></a>Signal Processing in a Multithreaded World<br  /><div class="outline-text-4" id="text-6-2-2">
<p>
If multiple threads are executing within a process when a signal is
delivered to it, the system must select a thread to process it. At the
highest level, the selection of the thread is dictated by how the
signal was generated, what action caused the signal, and what the
effective target of the signal is. 
</p>
</div>
<ul class="org-ul"><li><a id="sec-6-2-2-1" name="sec-6-2-2-1"></a>Synchronously generated signals<br  /><div class="outline-text-5" id="text-6-2-2-1">
<p>
The system is sending the process a signal because one of its threads
tried to divide by zero (SIGFPE), touch forbidden memory in the wrong
way (SIGSEGV), use a broken pipe (SIGPIPE), or do something else that
triggered an exception. 
</p>

<p>
The other type of synchronously generated signal results from
one thread in a process calling <code>pthread_kill</code> to send a signal
to another thread in the same process. 
</p>

<p>
Note that you shouldn't use <code>pthread_kill</code> in place of cancellation or
condition variables
</p>
</div>
</li>

<li><a id="sec-6-2-2-2" name="sec-6-2-2-2"></a>Asynchronously generated signals<br  /><div class="outline-text-5" id="text-6-2-2-2">
<p>
The arrival of these signals is asynchronous to the activities of any
and all threads within the process. They are typically job control
signals—SIGALRM, SIGHUP, SIGINT, and SIGKILL—or the user-defined
signals—SIGUSR1 and SIGUSR2. They are sent to the process by a kill
call and can be handled by almost any of its threads. 
</p>
</div>
</li>
<li><a id="sec-6-2-2-3" name="sec-6-2-2-3"></a>Per-thread signal masks<br  /><div class="outline-text-5" id="text-6-2-2-3">
<p>
By default, the first thread in a child process inherits its signal
mask from the thread in its parent that called fork. Additional
threads inherit the signal mask of the thread that issued the
<code>pthread_create</code> that created them. Use the <code>pthread_sigmask</code> call to
block and unblock signals in the mask.
</p>

<p>
When an asynchronously generated signal arrives at a process, it is
handled once by exactly one thread in the process. The system selects
this thread by referring to the collection of per-thread signal masks
of all the threads. If more than one thread has the signal unblocked,
the system arbitrarily selects one of them.
</p>
</div>
</li>

<li><a id="sec-6-2-2-4" name="sec-6-2-2-4"></a>Per-process signal actions<br  /><div class="outline-text-5" id="text-6-2-2-4">
<p>
Although each thread has its own signal mask, all threads in a process
must share the process's own signal action (sigaction) structure.
Consequently, if a process specifies that a given signal should be
ignored, it will be ignored, regardless of to which thread in the
process the system delivers it. Similarly, if a process's sigaction
structure deems that a certain signal should be subjected to the
default action (whatever that might be for the signal) or processed by
a signal handler, the specified action will be carried out when the
signal is delivered to any of the process's threads. 
</p>

<p>
Any thread can make a sigaction call to set the action for a signal.
If a thread calls sigaction to set the SIG<sub>IGN</sub> action for the SIGTERM
signal, any other thread in the same process that does not block this
signal is prepared to ignore a SIGTERM should one be delivered to it.
If a thread assigns the ei-e-io signal handler to the SIGIO signal,
any thread selected to handle SIGIO will call ei-e-io. 
</p>
</div>
</li>

<li><a id="sec-6-2-2-5" name="sec-6-2-2-5"></a>Putting it all together<br  /></li></ul>
</li>
<li><a id="sec-6-2-3" name="sec-6-2-3"></a>Threads in Signal Handlers<br  /><div class="outline-text-4" id="text-6-2-3">
<p>
But where are the Pthreads calls? They're not in either of these
lists! In fact, the Pthreads standard specifies that the behavior of
all Pthreads functions is undefined when the function is called from a
signal handler.
</p>

<p>
To make our program take an action when a signal arrives we can use
sigwait as follows:         
</p>

<ul class="org-ul">
<li>Mask the interesting signals in all threads so that their arrival is
made pending. The sigwait call will detect these signals. 
</li>

<li>Create a dedicated thread that waits specifically for interesting
signals to arrive.         
</li>

<li>Insert a simple loop in the dedicated thread's code that calls
sigwait, indicating the signals that it will handle. Add the action
routine that executes when the sigwait call returns. 
</li>
</ul>
</div>
</li>

<li><a id="sec-6-2-4" name="sec-6-2-4"></a>A Simple Example<br  /><div class="outline-text-4" id="text-6-2-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">stats_thread</span>; 
<span style="color: #98fb98;">pthread_mutex_t</span> <span style="color: #eedd82;">stats_lock</span> = PTHREAD_MUTEX_INITIALIZER; 
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span>      
<span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)      
{       
.       
sigset_t sigs_to_block; 
.       
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set main thread's signal mask to block SIGUSR1.      </span>
<span style="color: #ff7f24;">All other threads will inherit mask and have it blocked too     </span>
<span style="color: #ff7f24;">*/</span>      
sigemptyset(&amp;sigs_to_block);    
sigaddset(&amp;sigs_to_block, SIGUSR1);     
pthread_sigmask(SIG_BLOCK, &amp;sigs_to_block, <span style="color: #7fffd4;">NULL</span>);       
.       
pthread_create(&amp;stats_thread, <span style="color: #7fffd4;">NULL</span>, report_stats, <span style="color: #7fffd4;">NULL</span>);        
}

<span style="color: #98fb98;">void</span> * <span style="color: #87cefa;">report_stats</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>)    
{       
<span style="color: #98fb98;">sigset_t</span> <span style="color: #eedd82;">sigs_to_catch</span>; 
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">caught</span>;     
sigemptyset(&amp;sigs_to_catch);    
sigaddset(&amp;sigs_to_catch, SIGUSR1);     
<span style="color: #00ffff;">for</span> (;;) {      
      sigwait(&amp;sigs_to_catch, &amp;caught); 
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Proceed to lock mutex and display statistics </span><span style="color: #ff7f24;">*/</span>        
      pthread_mutex_lock(&amp;stats_lock);  
      display_stats();  
      pthread_mutex_unlock(&amp;stats_lock);        
      } 
<span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;    
}
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Threadsafe Library Functions and System Calls</h3>
<div class="outline-text-3" id="text-6-3">
</div><ul class="org-ul"><li><a id="sec-6-3-1" name="sec-6-3-1"></a>Threadsafe and Reentrant Functions<br  /><div class="outline-text-4" id="text-6-3-1">
<p>
The degree to which a library function or routine allows itself to
have multiple instances of itself in progress at the same time is
known as its reentrancy. 
</p>
</div>
</li>
<li><a id="sec-6-3-2" name="sec-6-3-2"></a>Functions That Return Pointers to Static Data<br  /></li>
<li><a id="sec-6-3-3" name="sec-6-3-3"></a>Using Thread-Unsafe Functions in a Multithreaded Program<br  /></li></ul>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Cancellation-Safe Library Functions and System Calls</h3>
<div class="outline-text-3" id="text-6-4">
</div><ul class="org-ul"><li><a id="sec-6-4-1" name="sec-6-4-1"></a>Cancellation Points in System and Library Calls<br  /><div class="outline-text-4" id="text-6-4-1">
<p>
we know of four Pthreads function calls that act as cancellation
points: they are <code>pthread_testcancel</code>, <code>pthread_cond_wait</code>,
<code>pthread_cond_timedwait</code>, and <code>pthread_join</code>. 
</p>
</div>
</li></ul>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Thread-Blocking Library Functions and System Calls</h3>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Threads and Process Management</h3>
<div class="outline-text-3" id="text-6-6">
</div><ul class="org-ul"><li><a id="sec-6-6-1" name="sec-6-6-1"></a>Calling fork from a Thread<br  /><div class="outline-text-4" id="text-6-6-1">
<p>
In a Pthreads-compliant implementation, the fork call always creates a
new child process with a single thread, regardless of how many threads
its parent may have had at the time of the call. Furthermore, the
child's thread is a replica of the thread in the parent that called
fork—including a process address space shared by all of its parent's
threads and its parent thread's per-thread stack. 
</p>

<p>
Consider the headaches:         
</p>
<ul class="org-ul">
<li>The new single-threaded child process could inherit held locks from
threads in the parent that don't exist in the child. It may have no
idea what these locks mean, let alone realize that it holds one of
them. Confusion and deadlock are in the forecast.         
</li>
<li>The child process could inherit heap areas that were allocated by
threads in the parent that don't exist in the child. Here we see
memory leaks, data loss, and bug reports.         
</li>
</ul>

<p>
The Pthreads standard defines the <code>pthread_atfork</code> call to help you
manage these problems. The <code>pthread_atfork</code> function allows a parent
process to specify preparation and cleanup routines that parent and
child processes run as part of the fork operation. Using these
routines a parent or child process can manage the release and
reacquisition of locks and resources before and after the fork. 
</p>
</div>

<ul class="org-ul"><li><a id="sec-6-6-1-1" name="sec-6-6-1-1"></a>Fork-handling stacks<br  /><div class="outline-text-5" id="text-6-6-1-1">
<p>
To perform its magic, the pthread<sub>atfork</sub> call pushes addresses of
preparation and cleanup routines on any of three fork-handling stacks:
</p>

<ul class="org-ul">
<li>Routines placed on the prepare stack are run in the parent before the fork.         
</li>
<li>Routines placed on the parent stack are run in the parent after the fork.         
</li>
<li>Routines placed on the child stack are run in the child after the
fork.
</li>
</ul>

<p>
Before pursuing this course, you should consider a less complex alternative:         
</p>
<ul class="org-ul">
<li>If possible, fork before you've created any threads.         Instead of
forking, create a new thread. If you are forking to exec a binary
image, can you convert the image to a callable shared library to
which you could simply link?         
</li>

<li>Consider the surrogate parent model.          In the surrogate parent
model, a program forks a child process at initialization time. The
sole purpose of the child is to serve as a sort of "surrogate
parent" for the original process should it ever need to fork another
child. After initialization, the original parent can proceed to
create its additional threads. When it wants to exec an image, it
communicates this to its child (which has remained single-threaded).
The child then performs the fork and exec on behalf of the original
process.
</li>
</ul>
</div>
</li></ul>
</li>

<li><a id="sec-6-6-2" name="sec-6-6-2"></a>Calling exec from a Thread<br  /><div class="outline-text-4" id="text-6-6-2">
<p>
With this in mind, the Pthreads standard specifies that an exec call
from any thread must terminate all threads in the process and start a
single new thread at main in the new image. 
</p>
</div>
</li>

<li><a id="sec-6-6-3" name="sec-6-6-3"></a>Process Exit and Threads<br  /><div class="outline-text-4" id="text-6-6-3">
<p>
Regardless of whether or not a process contains multiple threads, it
can be terminated when:         
</p>

<ul class="org-ul">
<li>Any thread in it makes an exit system call.         
</li>
<li>The thread running the main routine completes its execution.         
</li>
<li>A fatal signal is delivered. 
</li>
</ul>
</div>
</li></ul>
</div>

<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7">Multiprocessor Memory Synchronization</h3>
<div class="outline-text-3" id="text-6-7">
<p>
The functions that must synchronize memory operations include:         
</p>

<div class="org-src-container">

<pre class="src src-sh">pthread_cond_broadcast  
pthread_mutex_unlock    
pthread_cond_signal     
sem_post        
pthread_cond_timedwait  
sem_trywait     
pthread_cond_wait       
sem_wait        
pthread_create  
fork    
pthread_join    
<span style="color: #b0c4de;">wait</span>    
pthread_mutex_trylock   
waitpid 
pthread_mutex_lock
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 6: Practical Considerations</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Understanding Pthreads Implementation</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Pthreads implementations fall into three basic categories: 
</p>
<ul class="org-ul">
<li>Based on pure user space.         
</li>
<li>Based on pure kernel thread.         
</li>
<li>Implementations somewhere between the two. These hybrid
implementations are referred to variously as two-level schedulers,
lightweight processes (LWPs), or activations
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Debugging</h3>
<div class="outline-text-3" id="text-7-2">
</div><ul class="org-ul"><li><a id="sec-7-2-1" name="sec-7-2-1"></a>Overview<br  /><div class="outline-text-4" id="text-7-2-1">
<p>
First of all, you'll investigate types of programming errors that
result from thread synchronization problems, namely deadlocks and race
conditions. Second, once you've seen a problem (for instance, some
data corruption or a hang), you'll discover you may have a hard time
duplicating it. Because the alignment of events among threads that run
concurrently is largely left up to chance, errors, once found, may be
unrepeatable. Finally, because threads are a new technology, many
vendors have yet to upgrade their debuggers to operate well on
threaded programs. 
</p>
</div>
</li>

<li><a id="sec-7-2-2" name="sec-7-2-2"></a>Deadlock<br  /></li></ul>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Performance</h3>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Appendix C: Pthreads Quick Reference</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">

<pre class="src src-c++">pthread_atfork ( )      

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_atfork</span> (    
<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">prepare</span>)(<span style="color: #98fb98;">void</span>),  
<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">parent</span>)(<span style="color: #98fb98;">void</span>),   
<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">child</span>)(<span style="color: #98fb98;">void</span>));   

Declares procedures to be <span style="color: #98fb98;">called</span> <span style="color: #eedd82;">before</span> <span style="color: #00ffff;">and</span> after a fork call. The prepare fork handler runs in the parent process before the fork. After the fork, <span style="color: #eedd82;">the</span> parent handler runs in the parent process, <span style="color: #00ffff;">and</span> the child handler runs in the child process.     

pthread_attr_destroy( ) 

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_destroy</span> (      
<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);  

Destroys a thread <span style="color: #98fb98;">attribute</span> <span style="color: #87cefa;">object</span>.     

pthread_attr_getdetachstate( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getdetachstate</span> (       
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">detachstate</span>);      

Obtains the setting of the detached state of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.  

pthread_attr_getinheritsched( ) 

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getinheritsched</span> (      
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">inheritsched</span>);     
Obtains the setting of the scheduling inheritance of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.  

pthread_attr_getschedparam( )   

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getschedparam</span> (        
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sched_param</span> *<span style="color: #eedd82;">param</span>);     

Obtains <span style="color: #98fb98;">the</span> <span style="color: #87cefa;">parameters</span> (<span style="color: #00ffff;">for</span> instance, <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">scheduling</span> <span style="color: #eedd82;">priority</span>) associated with <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">scheduling</span> policy <span style="color: #98fb98;">attribute</span> of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.     

pthread_attr_getschedpolicy( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getschedpolicy</span> (       
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">policy</span>);   

Obtains <span style="color: #98fb98;">the</span> setting of <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">scheduling</span> policy of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.       

pthread_attr_getscope( )        

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getscope</span> (     
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">scope</span>);    

Obtains <span style="color: #98fb98;">the</span> setting of <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">scheduling</span> scope of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.        

pthread_attr_getstackaddr( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstackaddr</span> ( 
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">void</span> **<span style="color: #eedd82;">stackaddr</span>);      

Obtains <span style="color: #98fb98;">the</span> stack address of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.  

pthread_attr_getstacksize( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_getstacksize</span> ( 
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">size_t</span> *<span style="color: #eedd82;">stacksize</span>);     

Obtains <span style="color: #98fb98;">the</span> stack size of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.     

pthread_attr_init( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_init</span> ( 
<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>);  

Initializes <span style="color: #98fb98;">a</span> thread <span style="color: #98fb98;">attribute</span> <span style="color: #87cefa;">object</span>. A thread specifies a thread attribute object in its calls to pthread_create to set the characteristics of newly created threads.         

pthread_attr_setdetachstate( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setdetachstate</span> (       
<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,   
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">detachstate</span>);       

Adjusts <span style="color: #98fb98;">the</span> detached state of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>. A thread<span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s detached state can be joinable (PTHREAD_CREATE_JOINABLE) or it can be detached (PTHREAD_CREATE_DETACHED).    </span>

<span style="color: #ffa07a;">pthread_attr_setinheritsched( ) </span>

<span style="color: #ffa07a;">int pthread_attr_setinheritsched (      </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int inherit);   </span>

<span style="color: #ffa07a;">Adjusts the scheduling inheritance of a thread. A thread can inherit the scheduling policy and the parameters of its creator thread (PTHREAD_INHERIT_SCHED) or obtain them from the thread attribute object specified in the pthread_create call (PTHREAD_EXPLICIT_SCHED).      </span>

<span style="color: #ffa07a;">pthread_attr_setschedparam( )   </span>

<span style="color: #ffa07a;">int pthread_attr_setschedparam (        </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">const struct sched_param *param);       </span>

<span style="color: #ffa07a;">Adjusts the parameters (for instance, the scheduling priority) associated with the scheduling policy of a thread. The scheduling priority parameter (as specified in the struct sched_param) depends upon the selected scheduling policy (SCHED_FIFO, SCHED_RR, or SCHED_OTHER). Use sched_get_priority_max and sched_get_priority_min to obtain the maximum and minimum priority settings for a given policy.  </span>

<span style="color: #ffa07a;">pthread_attr_setschedpolicy( )  </span>

<span style="color: #ffa07a;">int pthread_attr_setschedpolicy (       </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int policy);    </span>

<span style="color: #ffa07a;">Adjusts the scheduling policy of a thread. Pthreads defines the SCHED_FIFO, SCHED_RR, and SCHED_OTHER policies.         </span>

<span style="color: #ffa07a;">pthread_attr_setscope( )        </span>

<span style="color: #ffa07a;">int pthread_attr_setscope (     </span>
<span style="color: #ffa07a;">pthread_attr_t *attr,   </span>
<span style="color: #ffa07a;">int scope);     </span>

<span style="color: #ffa07a;">Adjusts the scheduling scope of a thread. A thread can use system-scope scheduling (PTHREAD_SCOPE_SYSTEM), in which case the operating system compares the priorities of all runnable threads of all processes systemwide in order to select a thread to run on an available CPU. Alternatively, it can use process-scope scheduling (PTHREAD_SCOPE_PROCESS), in which case only the highest priority runnable thread in a process competes against the highest priority threads of other processes in the system'</span>s scheduling activity.        

pthread_attr_setstackaddr( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstackaddr</span> ( 
<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,   
<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">stackaddr</span>);       

Adjusts <span style="color: #98fb98;">the</span> stack address of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>.  

pthread_attr_setstacksize( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_attr_setstacksize</span> ( 
<span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,   
<span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">stacksize</span>);      

Adjusts <span style="color: #98fb98;">the</span> stack size of <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span>. The stack size must be greater than <span style="color: #00ffff;">or</span> equal to PTHREAD_STACK_MIN.  

pthread_cancel( )       

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cancel</span> (    
<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);      

Cancels <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">specified</span> <span style="color: #87cefa;">thread</span>.   

pthread_cleanup_pop( )  

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">pthread_cleanup_pop</span> (      
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">execute</span>);   

Removes <span style="color: #98fb98;">the</span> routine from <span style="color: #98fb98;">the</span> top of <span style="color: #98fb98;">a</span> <span style="color: #eedd82;">thread</span><span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s cleanup stack, and if execute is nonzero, runs it.       </span>

<span style="color: #ffa07a;">pthread_cleanup_push( ) </span>

<span style="color: #ffa07a;">void pthread_cleanup_push (     </span>
<span style="color: #ffa07a;">void (*routine)(void *),        </span>
<span style="color: #ffa07a;">void *arg);     </span>

<span style="color: #ffa07a;">Places a routine on the the top of a thread'</span>s cleanup stack, <span style="color: #00ffff;">and</span>  when the routine is called, ensures that <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">specified</span> argument is passed <span style="color: #98fb98;">to</span> <span style="color: #87cefa;">it</span>.      

pthread_condattr_destroy( )     

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_destroy</span> (  
<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);      

Destroys <span style="color: #98fb98;">a</span> condition variable <span style="color: #98fb98;">attribute</span> <span style="color: #87cefa;">object</span>.         

pthread_condattr_getpshared( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_getpshared</span> (       
<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>,       
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">pshared</span>);  

Obtains <span style="color: #98fb98;">the</span> <span style="color: #87cefa;">process</span>-shared setting of a condition variable attribute object.    

pthread_condattr_init( )        

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_init</span> (     
<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);      

Initializes <span style="color: #98fb98;">a</span> condition variable <span style="color: #98fb98;">attribute</span> <span style="color: #87cefa;">object</span>. A thread specifies a condition variable attribute object in its calls to pthread_cond_init to set the characteristics of <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">condition</span> variables.    

pthread_condattr_setpshared( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_condattr_setpshared</span> (       
<span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>,       
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pshared</span>);   

Sets <span style="color: #98fb98;">the</span> <span style="color: #87cefa;">process</span>-shared attribute in a condition variable attribute object to either PTHREAD_PROCESS_SHARED <span style="color: #00ffff;">or</span> PTHREAD_PROCESS_PRIVATE.         

pthread_cond_broadcast( )       

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_broadcast</span> (    
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);  

Unblocks all threads that are waiting on <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">condition</span> <span style="color: #87cefa;">variable</span>.  

pthread_cond_destroy( ) 

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_destroy</span> (      
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);  

Destroys <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">condition</span> <span style="color: #87cefa;">variable</span>.  

pthread_cond_init( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_init</span> ( 
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,   
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_condattr_t</span> *<span style="color: #eedd82;">attr</span>);        

Initializes <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">condition</span> variable with <span style="color: #98fb98;">the</span> attributes <span style="color: #98fb98;">specified</span> in <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">specified</span> <span style="color: #98fb98;">condition</span> variable <span style="color: #98fb98;">attribute</span> <span style="color: #eedd82;">object</span>. If attr is <span style="color: #7fffd4;">NULL</span>, <span style="color: #87cefa;">the</span> <span style="color: #00ffff;">default</span> attributes are used.  

pthread_cond_signal( )  

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_signal</span>(        
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>);  

Unblocks at least one thread waiting on <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">condition</span> <span style="color: #87cefa;">variable</span>. The scheduling priority determines which thread is awakened.      

pthread_cond_timedwait( )       

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_timedwait</span> (    
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,   
<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>, 
<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">timespec</span> *<span style="color: #eedd82;">abstime</span>);        

Atomically unlocks <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">specified</span> <span style="color: #eedd82;">mutex</span>, <span style="color: #00ffff;">and</span> places the calling thread into a wait state. When the specified condition variable is signaled <span style="color: #00ffff;">or</span> broadcast, <span style="color: #00ffff;">or</span> the system time is greater than <span style="color: #00ffff;">or</span> equal to abstime, <span style="color: #00ffff;">this</span> function reacquires the mutex <span style="color: #00ffff;">and</span> resumes its caller.     

pthread_cond_wait( )    

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_cond_wait</span> ( 
<span style="color: #98fb98;">pthread_cond_t</span> *<span style="color: #eedd82;">cond</span>,   
<span style="color: #98fb98;">pthread_mutex_t</span> *<span style="color: #eedd82;">mutex</span>);        

Atomically unlocks <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">specified</span> <span style="color: #eedd82;">mutex</span>, <span style="color: #00ffff;">and</span> places the calling thread into a wait state. When the specified condition variable is signaled <span style="color: #00ffff;">or</span> broadcasted, <span style="color: #00ffff;">this</span> function reacquires the mutex <span style="color: #00ffff;">and</span> resumes its caller.   

pthread_create( )       

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_create</span> (    
<span style="color: #98fb98;">pthread_t</span> *<span style="color: #eedd82;">thread</span>,      
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">pthread_attr_t</span> *<span style="color: #eedd82;">attr</span>,     
<span style="color: #98fb98;">void</span> *(*<span style="color: #eedd82;">start_routine</span>)(<span style="color: #98fb98;">void</span> *), 
<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">arg</span>);     

Creates <span style="color: #98fb98;">a</span> thread with <span style="color: #98fb98;">the</span> attributes <span style="color: #98fb98;">specified</span> <span style="color: #98fb98;">in</span> <span style="color: #eedd82;">attr</span>. If attr is <span style="color: #7fffd4;">NULL</span>, <span style="color: #87cefa;">the</span> <span style="color: #00ffff;">default</span> attributes are used. The thread argument receives a thread handle <span style="color: #00ffff;">for</span> the <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">thread</span>. The <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">thread</span> starts execution in start_routine <span style="color: #00ffff;">and</span> is passed the single specified argument.        

pthread_detach( )       

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_detach</span> (    
<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">thread</span>);      

Marks <span style="color: #98fb98;">a</span> <span style="color: #87cefa;">thread</span><span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s internal data structures for deletion. When a detached thread terminates, the system reclaims the storage used for its thread object.  </span>

<span style="color: #ffa07a;">pthread_equal( )        </span>

<span style="color: #ffa07a;">int pthread_equal (     </span>
<span style="color: #ffa07a;">pthread_t t1,   </span>
<span style="color: #ffa07a;">pthread_t t2);  </span>

<span style="color: #ffa07a;">Compares one thread handle to another thread handle.    </span>

<span style="color: #ffa07a;">pthread_exit( ) </span>

<span style="color: #ffa07a;">void pthread_exit (     </span>
<span style="color: #ffa07a;">void *value);   </span>

<span style="color: #ffa07a;">Terminates the calling thread, returning the specified value to any thread that may have previously issued a pthread_join on the thread.        </span>

<span style="color: #ffa07a;">pthread_getschedparam( )        </span>

<span style="color: #ffa07a;">int pthread_getschedparam (     </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int *policy,    </span>
<span style="color: #ffa07a;">struct sched_param *param);     </span>

<span style="color: #ffa07a;">Obtains both the scheduling policy and scheduling parameters of an existing thread. (This function differs from the pthread_attr_getschedpolicy function and the pthread_attr_getschedparam function in that the latter functions return the policy and parameters that will be used whenever a new thread is created.)         </span>

<span style="color: #ffa07a;">pthread_getspecific( )  </span>

<span style="color: #ffa07a;">void *pthread_getspecific (     </span>
<span style="color: #ffa07a;">pthread_key_t key);     </span>

<span style="color: #ffa07a;">Obtains the thread-specific data value associated with the specified key in the calling thread.         </span>

<span style="color: #ffa07a;">pthread_join( ) </span>

<span style="color: #ffa07a;">int pthread_join (      </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">void **value_ptr);      </span>

<span style="color: #ffa07a;">Causes the calling thread to wait for the specified thread'</span>s termination. The value_ptr parameter receives the <span style="color: #00ffff;">return</span> value of the terminating thread.  

pthread_key_create( )   

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_key_create</span> (        
<span style="color: #98fb98;">pthread_key_t</span> *<span style="color: #eedd82;">key</span>,     
<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">destructor</span>)(<span style="color: #98fb98;">void</span> *));    

Generates <span style="color: #98fb98;">a</span> <span style="color: #98fb98;">unique</span> <span style="color: #87cefa;">thread</span>-specific key that<span style="color: #ffa07a;">'s visible to all threads in a process. Although different threads can use the same key, the value any thread associates with the key (by calling pthread_specific) are specific to that thread alone and persist for the life of that thread. When a thread terminates, its thread-specific data value is destroyed (but the key persists until pthread_key_destroy is called). If a destructor routine was specified for the key in the pthread_key_create call, it'</span>s then called in the thread<span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s context with the thread-specific data value associated with the key as an argument.      </span>

<span style="color: #ffa07a;">pthread_key_delete( )   </span>

<span style="color: #ffa07a;">int pthread_key_delete (        </span>
<span style="color: #ffa07a;">pthread_key_t key);     </span>

<span style="color: #ffa07a;">Deletes a thread-specific key.  </span>

<span style="color: #ffa07a;">pthread_kill( ) </span>

<span style="color: #ffa07a;">int pthread_kill (      </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int sig);       </span>

<span style="color: #ffa07a;">Delivers a signal to the specified thread.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_destroy( )    </span>

<span style="color: #ffa07a;">int pthread_mutexattr_destroy ( </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr);     </span>

<span style="color: #ffa07a;">Destroys a mutex attribute object.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_getprioceiling( )     </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getprioceiling (  </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *prioceiling);      </span>

<span style="color: #ffa07a;">Obtains the priority ceiling of a mutex attribute object.       </span>

<span style="color: #ffa07a;">pthread_mutexattr_getprotocol( )        </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getprotocol(      </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *protocol); </span>

<span style="color: #ffa07a;">Obtains the protocol of a mutex attribute object.       </span>

<span style="color: #ffa07a;">pthread_mutexattr_getpshared( ) </span>

<span style="color: #ffa07a;">int pthread_mutexattr_getpshared(       </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int *pshared);  </span>

<span style="color: #ffa07a;">Obtains the process-shared setting of a mutex attribute object.         </span>

<span style="color: #ffa07a;">pthread_mutexattr_init( )       </span>

<span style="color: #ffa07a;">int pthread_mutexattr_init (    </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr);     </span>

<span style="color: #ffa07a;">Initializes a mutex attribute object. A thread specifies a mutex attribute object in its calls to pthread_mutex_init to set the characteristics of new mutexes.         </span>

<span style="color: #ffa07a;">pthread_mutexattr_setprioceiling( )     </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setprioceiling (  </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int prioceiling);       </span>

<span style="color: #ffa07a;">Sets the priority ceiling attribute of a mutex attribute object.        </span>

<span style="color: #ffa07a;">pthread_mutexattr_setprotocol( )        </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setprotocol(      </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int protocol);  </span>

<span style="color: #ffa07a;">Sets the protocol attribute of a mutex attribute object. There are three valid settings: PTHREAD_PRIO_INHERIT, PTHREAD_PRIO_PROTECT, or PTHREAD_PRIO_NONE.      </span>

<span style="color: #ffa07a;">pthread_mutexattr_setpshared( ) </span>

<span style="color: #ffa07a;">int pthread_mutexattr_setpshared(       </span>
<span style="color: #ffa07a;">pthread_mutexattr_t *attr,      </span>
<span style="color: #ffa07a;">int pshared);   </span>

<span style="color: #ffa07a;">Sets the process-shared attribute of a mutex attribute object to PTHREAD_PROCESS_SHARED or PTHREAD_PROCESS_PRIVATE.     </span>

<span style="color: #ffa07a;">pthread_mutex_destroy( )        </span>

<span style="color: #ffa07a;">int pthread_mutex_destroy (     </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Destroys a mutex.       </span>

<span style="color: #ffa07a;">pthread_mutex_init( )   </span>

<span style="color: #ffa07a;">int pthread_mutex_init (        </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex, </span>
<span style="color: #ffa07a;">const pthread_mutexattr_t *attr);       </span>

<span style="color: #ffa07a;">Initializes a mutex with the attributes specified in the specified mutex attribute object. If attr is NULL, the default attributes are used.    </span>

<span style="color: #ffa07a;">pthread_mutex_lock( )   </span>

<span style="color: #ffa07a;">int pthread_mutex_lock (        </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Locks an unlocked mutex. If the mutex is already locked, the calling thread blocks until the thread that currently holds the mutex releases it.         </span>

<span style="color: #ffa07a;">pthread_mutex_trylock( )        </span>

<span style="color: #ffa07a;">int pthread_mutex_trylock (     </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Tries to lock a mutex. If the mutex is already locked, the calling thread returns without waiting for the mutex to be freed.    </span>

<span style="color: #ffa07a;">pthread_mutex_unlock( ) </span>

<span style="color: #ffa07a;">int pthread_mutex_unlock (      </span>
<span style="color: #ffa07a;">pthread_mutex_t *mutex);        </span>

<span style="color: #ffa07a;">Unlocks a mutex. The scheduling priority determines which blocked thread is resumed. The resumed thread may or may not succeed in its next attempt to lock the mutex, depending upon whether another thread has locked the mutex in the interval between the thread'</span>s being resumed <span style="color: #00ffff;">and</span> its issuing the pthread_mutex_lock call.        

pthread_once( ) 

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pthread_once</span> (      
<span style="color: #98fb98;">pthread_once_t</span> *<span style="color: #eedd82;">once_block</span>,     
<span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">init_routine</span>) (<span style="color: #98fb98;">void</span>);    

Ensures that init_routine will run just once regardless of how many threads <span style="color: #98fb98;">in</span> <span style="color: #98fb98;">a</span> process <span style="color: #98fb98;">call</span> <span style="color: #eedd82;">it</span>. All threads issue calls to the routine by making identical pthread_once calls (with <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">same</span> <span style="color: #eedd82;">once_block</span> <span style="color: #00ffff;">and</span> init_routine). The thread that first makes the pthread_once call succeeds in running the routine; subsequent pthread_once calls from <span style="color: #98fb98;">other</span> <span style="color: #eedd82;">threads</span> <span style="color: #00ffff;">do</span> <span style="color: #00ffff;">not</span> run the routine.        

pthread_self( ) 

<span style="color: #98fb98;">pthread_t</span> <span style="color: #eedd82;">pthread_self</span> (        
<span style="color: #98fb98;">void</span>);  

Obtains <span style="color: #98fb98;">the</span> thread handle of <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">calling</span> <span style="color: #eedd82;">thread</span>.        

pthread_setcancelstate( )       

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pthread_setcancelstate</span> (    
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">state</span>,      
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">oldstate</span>); 

Sets <span style="color: #98fb98;">a</span> <span style="color: #eedd82;">thread</span><span style="color: #ffa07a;">'s cancelability state. You can enable a thread'</span>s cancellation by specifying the PTHREAD_CANCEL_ENABLE state, <span style="color: #00ffff;">or</span> disable it by specifying PTHREAD_CANCEL_DISABLE.  

pthread_setcanceltype( )        

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pthread_setcanceltype</span> (     
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">type</span>,       
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">oldtype</span>);  

Sets <span style="color: #98fb98;">a</span> <span style="color: #eedd82;">thread</span><span style="color: #ffc0cb; font-weight: bold;">'</span><span style="color: #ffa07a;">s cancelability type. To allow a thread to receive cancellation orders only at defined cancellation points, you can specify the PTHREAD_CANCEL_DEFERRED type; this is the default. To allow a thread to be canceled at any point during its execution, you can specify PTHREAD_CANCEL_ASYNCHRONOUS.       </span>

<span style="color: #ffa07a;">pthread_setschedparam( )        </span>

<span style="color: #ffa07a;">int pthread_setschedparam (     </span>
<span style="color: #ffa07a;">pthread_t thread,       </span>
<span style="color: #ffa07a;">int policy,     </span>
<span style="color: #ffa07a;">const struct sched_param *param);       </span>

<span style="color: #ffa07a;">Adjusts the scheduling policy and scheduling parameters of an existing thread. (This function differs from the functions pthread_attr_setschedpolicy and pthread_attr_setschedparam in that they set the policy and parameters that will be used whenever a new thread is created.)     </span>

<span style="color: #ffa07a;">pthread_setspecific( )  </span>

<span style="color: #ffa07a;">int pthread_setspecific (       </span>
<span style="color: #ffa07a;">pthread_key_t key,      </span>
<span style="color: #ffa07a;">void *value);   </span>

<span style="color: #ffa07a;">Sets the thread-specific data value associated with the specified key in the calling thread.    </span>

<span style="color: #ffa07a;">pthread_sigmask( )      </span>

<span style="color: #ffa07a;">int pthread_sigmask (   </span>
<span style="color: #ffa07a;">int how,        </span>
<span style="color: #ffa07a;">const sigset_t *set,    </span>
<span style="color: #ffa07a;">sigset_t *oset);        </span>

<span style="color: #ffa07a;">Examines or changes the calling thread'</span>s signal mask.   

pthread_testcancel( )   

<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">pthread_testcancel</span> (<span style="color: #98fb98;">void</span>); 

Requests that any pending cancellation request be delivered <span style="color: #98fb98;">to</span> <span style="color: #98fb98;">the</span> <span style="color: #98fb98;">calling</span> <span style="color: #eedd82;">thread</span>.
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-01-26 Thu 21:27</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
