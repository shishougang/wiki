<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Google C++ Style Guide Notes (Revision 3.274)</title>
<!-- 2017-01-26 Thu 20:46 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Google C++ Style Guide Notes (Revision 3.274)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Homepage</a></li>
<li><a href="#sec-2">Header Files</a>
<ul>
<li><a href="#sec-2-1">The #define Guard</a></li>
<li><a href="#sec-2-2">Forward Declarations</a></li>
<li><a href="#sec-2-3">Inline Functions</a></li>
<li><a href="#sec-2-4">The -inl.h Files</a></li>
<li><a href="#sec-2-5">Function Parameter Ordering</a></li>
<li><a href="#sec-2-6">Names and Order of Includes</a></li>
</ul>
</li>
<li><a href="#sec-3">Scoping</a>
<ul>
<li><a href="#sec-3-1">Namespaces</a></li>
<li><a href="#sec-3-2">Nested Classes</a></li>
<li><a href="#sec-3-3">Nonmember, Static Member, and Global Functions</a></li>
<li><a href="#sec-3-4">Local Variables</a></li>
<li><a href="#sec-3-5">Static and Global Variables</a></li>
</ul>
</li>
<li><a href="#sec-4">Classes</a>
<ul>
<li><a href="#sec-4-1">Doing Work in Constructors</a></li>
<li><a href="#sec-4-2">Initialization</a></li>
<li><a href="#sec-4-3">Explicit Constructors</a></li>
<li><a href="#sec-4-4">Copy Constructors</a></li>
<li><a href="#sec-4-5">Delegating and inheriting constructors</a></li>
<li><a href="#sec-4-6">Structs vs. Classes</a></li>
<li><a href="#sec-4-7">Inheritance</a></li>
<li><a href="#sec-4-8">Multiple Inheritance</a></li>
<li><a href="#sec-4-9">Interfaces</a></li>
<li><a href="#sec-4-10">Operator Overloading</a></li>
<li><a href="#sec-4-11">Access Control</a></li>
<li><a href="#sec-4-12">Declaration Order</a></li>
<li><a href="#sec-4-13">Write Short Functions</a></li>
</ul>
</li>
<li><a href="#sec-5">Google-Specific Magic</a>
<ul>
<li><a href="#sec-5-1">Ownership and Smart Pointers</a></li>
<li><a href="#sec-5-2">cpplint</a></li>
</ul>
</li>
<li><a href="#sec-6">Other C++ Features</a>
<ul>
<li><a href="#sec-6-1">Reference Arguments</a></li>
<li><a href="#sec-6-2">Rvalue references</a></li>
<li><a href="#sec-6-3">Function Overloading</a></li>
<li><a href="#sec-6-4">Default Arguments</a></li>
<li><a href="#sec-6-5">Variable-Length Arrays and alloca()</a></li>
<li><a href="#sec-6-6">Friends</a></li>
<li><a href="#sec-6-7">Exceptions</a></li>
<li><a href="#sec-6-8">Run-Time Type Information (RTTI)</a></li>
<li><a href="#sec-6-9">Casting</a></li>
<li><a href="#sec-6-10">Streams</a></li>
<li><a href="#sec-6-11">Preincrement and Predecrement</a></li>
<li><a href="#sec-6-12">Use of const</a></li>
<li><a href="#sec-6-13">Use of constexpr</a></li>
<li><a href="#sec-6-14">Integer Types</a></li>
<li><a href="#sec-6-15">64-bit Portability</a></li>
<li><a href="#sec-6-16">Preprocessor Macros</a></li>
<li><a href="#sec-6-17">0 and nullptr/NULL</a></li>
<li><a href="#sec-6-18">sizeof</a></li>
<li><a href="#sec-6-19">auto</a></li>
<li><a href="#sec-6-20">Brace Initialization</a></li>
<li><a href="#sec-6-21">Lambda expressions</a></li>
<li><a href="#sec-6-22">Boost</a></li>
<li><a href="#sec-6-23">C++11</a></li>
</ul>
</li>
<li><a href="#sec-7">Naming</a>
<ul>
<li><a href="#sec-7-1">General Naming Rules</a></li>
<li><a href="#sec-7-2">File Names</a></li>
<li><a href="#sec-7-3">Type Names</a></li>
<li><a href="#sec-7-4">Variable Names</a></li>
<li><a href="#sec-7-5">Constant Names</a></li>
<li><a href="#sec-7-6">Function Names</a></li>
<li><a href="#sec-7-7">Namespace Names</a></li>
<li><a href="#sec-7-8">Enumerator Names</a></li>
<li><a href="#sec-7-9">Macro Names</a></li>
<li><a href="#sec-7-10">Exceptions to Naming Rules</a></li>
</ul>
</li>
<li><a href="#sec-8">Comments</a>
<ul>
<li><a href="#sec-8-1">Comment Style</a></li>
<li><a href="#sec-8-2">File Comments</a></li>
<li><a href="#sec-8-3">Class Comments</a></li>
<li><a href="#sec-8-4">Function Comments</a></li>
<li><a href="#sec-8-5">Variable Comments</a></li>
<li><a href="#sec-8-6">Implementation Comments</a></li>
<li><a href="#sec-8-7">Punctuation, Spelling and Grammar</a></li>
<li><a href="#sec-8-8"><span class="todo TODO">TODO</span> Comments</a></li>
<li><a href="#sec-8-9">Deprecation Comments</a></li>
</ul>
</li>
<li><a href="#sec-9">Formatting</a>
<ul>
<li><a href="#sec-9-1">Line Length</a></li>
<li><a href="#sec-9-2">Non-ASCII Characters</a></li>
<li><a href="#sec-9-3">Spaces vs. Tabs</a></li>
<li><a href="#sec-9-4">Function Declarations and Definitions</a></li>
<li><a href="#sec-9-5">Function Calls</a></li>
<li><a href="#sec-9-6">Braced Initializer Lists</a></li>
<li><a href="#sec-9-7">Conditionals</a></li>
<li><a href="#sec-9-8">Loops and Switch Statements</a></li>
<li><a href="#sec-9-9">Pointer and Reference Expressions</a></li>
<li><a href="#sec-9-10">Boolean Expressions</a></li>
<li><a href="#sec-9-11">Return Values</a></li>
<li><a href="#sec-9-12">Variable and Array Initialization</a></li>
<li><a href="#sec-9-13">Preprocessor Directives</a></li>
<li><a href="#sec-9-14">Class Format</a></li>
<li><a href="#sec-9-15">Constructor Initializer Lists</a></li>
<li><a href="#sec-9-16">Namespace Formatting</a></li>
<li><a href="#sec-9-17">Horizontal Whitespace</a></li>
<li><a href="#sec-9-18">Vertical Whitespace</a></li>
</ul>
</li>
<li><a href="#sec-10">Exceptions to the Rules</a>
<ul>
<li><a href="#sec-10-1">Existing Non-conformant Code</a></li>
<li><a href="#sec-10-2">Windows Code</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Homepage</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>en:<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a>
</li>
<li>zh:<a href="http://zh-google-styleguide.readthedocs.org/en/latest/">http://zh-google-styleguide.readthedocs.org/en/latest/</a> 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Header Files</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">The #define Guard</h3>
<div class="outline-text-3" id="text-2-1">
<p class="info">
所有头文件都应该使用 #define 防止头文件被多重包含, 
命名格式当是: &ltPROJECT&gt_&ltPATH&gt_&ltFILE&gt_H_
</p>

<p>
For example, the file <code>foo/src/bar/baz.h</code> in project <code>foo</code> should have the
following guard:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> FOO_BAR_BAZ_H_
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">FOO_BAR_BAZ_H_</span>

...

<span style="color: #b0c4de;">#endif</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">FOO_BAR_BAZ_H_</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Forward Declarations</h3>
<div class="outline-text-3" id="text-2-2">
<p class="info">
能用前置声明来避免不必要的#include.
</p>

<p>
A "forward declaration" is a declaration of a class, function, or
template without an associated definition.
</p>

<p>
用前置声明可以显著减少需要包含的头文件数量. 举例说明: 如果头文件中用到类 File, 但不需要访问 File 类的声明, 头文件中只需前置声明 class File; 而无须 #include "file/base/file.h".
</p>

<p>
不允许访问类的定义的前提下, 我们在一个头文件中能对类 Foo 做哪些操作?
</p>

<ul class="org-ul">
<li>我们可以将数据成员类型声明为 Foo * 或 Foo &amp;.
</li>
<li>我们可以将函数参数 / 返回值的类型声明为 Foo (但不能定义实现).
</li>
<li>我们可以将静态数据成员的类型声明为 Foo, 因为静态数据成员的定义在类定义之外.
</li>
</ul>
<p>
反之, 如果你的类是 Foo 的子类, 或者含有类型为 Foo 的非静态数据成员, 则必须包含 Foo 所在的头文件.
</p>

<p>
<b>Decision:</b>
</p>
<ul class="org-ul">
<li>When using a <b>function</b> declared in a header file, always #include
that header.
</li>
<li>When using a class template, prefer to #include its header file.
</li>
<li>When using an ordinary class, relying on a forward declaration is
OK, but be wary of situations where a forward declaration may be
insufficient or incorrect; when in doubt, just #include the
appropriate header.
</li>
<li>Do not replace data members with pointers just to avoid
an #include.
</li>
</ul>

<p>
当然 .cc 文件无论如何都需要所使用类的定义部分, 自然也就会包含若干头文件.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Inline Functions</h3>
<div class="outline-text-3" id="text-2-3">
<p class="info">
只有当函数只有 10 行甚至更少时才将其定义为内联函数.
</p>
<p>
 <b>Decision:</b>
一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数,
析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
</p>

<p>
另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).
</p>

<p>
有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.
</p>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">The -inl.h Files</h3>
<div class="outline-text-3" id="text-2-4">
<p class="info">
复杂的内联函数的定义, 可放在后缀名为 -inl.h 的头文件中.
</p>

<p>
Another use of -inl.h files is for definitions of function templates.
This can be used to keep your template definitions easy to read.
</p>

<p>
Do not forget that a -inl.h file requires a #define guard just like
any other header file.
</p>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Function Parameter Ordering</h3>
<div class="outline-text-3" id="text-2-5">
<p class="info">
When defining a function, parameter order is: inputs, then outputs.
</p>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Names and Order of Includes</h3>
<div class="outline-text-3" id="text-2-6">
<p class="info">
使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: C 库, C++ 库, 其他库的 .h, 本项目内的 .h.
</p>

<p>
For example, <code>google-awesome-project/src/base/logging.h</code> should be
included as
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"base/logging.h"</span>
</pre>
</div>

<p>
In <code>dir/foo.cc</code> or <code>dir/foo_test.cc</code>, whose main purpose is to implement
or test the stuff in dir2/foo2.h, order your includes as follows:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #87cefa;">dir2/foo2.h</span> (preferred location &#8212; see details below).
C system files.
C++ system files.
Other libraries<span style="color: #ffa07a;">' .h files.</span>
<span style="color: #ffa07a;">Your project'</span>s .h files.
</pre>
</div>

<p>
With the preferred ordering, if dir2/foo2.h omits any necessary
includes, the build of dir/foo.cc or <code>dir/foo_test.cc</code> will break. Thus,
this rule ensures that build breaks show up first for the people
working on these files, not for innocent people in other packages.
</p>

<p>
Within each section the includes should be ordered alphabetically.
Note that older code might not conform to this rule and should be
fixed when convenient.
</p>

<p>
Exception: sometimes, system-specific code needs conditional includes.
Such code can put conditional includes after other includes. Example:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"foo/public/fooserver.h"</span>

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"base/port.h"</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For LANG_CXX11.</span>

<span style="color: #b0c4de;">#ifdef</span> LANG_CXX11
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;initializer_list&gt;</span>
<span style="color: #b0c4de;">#endif</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">LANG_CXX11</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Scoping</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Namespaces</h3>
<div class="outline-text-3" id="text-3-1">
<p class="info">
鼓励在 .cc 文件内使用匿名名字空间. 使用具名的名字空间时, 
其名称可基于项目名或相对路径. 不要使用 using 关键字.
不要使用内嵌名字空间
</p>

<p>
 <b>Decision:</b>
Use namespaces according to the policy described below. Terminate
namespaces with comments as shown in the given examples.
</p>
</div>
<ul class="org-ul"><li><a id="sec-3-1-1" name="sec-3-1-1"></a>Unnamed Namespaces<br  /><div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>Unnamed namespaces are allowed and even encouraged in .cc files, to
avoid runtime naming conflicts:

<div class="org-src-container">

<pre class="src src-c">namespace {                           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This is in a .cc file.</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The content of a namespace is not indented</span>
<span style="color: #00ffff;">enum</span> { <span style="color: #eedd82;">kUnused</span>, <span style="color: #98fb98;">kEOF</span>, <span style="color: #eedd82;">kError</span> };       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Commonly used tokens.</span>
<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">AtEof</span>() { <span style="color: #00ffff;">return</span> pos_ == kEOF; }  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Uses our namespace's EOF.</span>

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace</span>
</pre>
</div>
<p>
However, file-scope declarations that are associated with a
particular class may be declared in that class as types, static data
members or static member functions rather than as members of an
unnamed namespace.
</p>
</li>

<li>Do not use unnamed namespaces in .h files.
</li>
</ul>
</div>
</li>
<li><a id="sec-3-1-2" name="sec-3-1-2"></a>Named Namespaces<br  /><div class="outline-text-4" id="text-3-1-2">
<p>
Named namespaces should be used as follows:
</p>
<ul class="org-ul">
<li>Namespaces wrap the entire source file after includes, gflags
definitions/declarations, and forward declarations of classes from
other namespaces:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">In the .h file</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">mynamespace</span> {

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">All declarations are within the namespace scope.</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Notice the lack of indentation.</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MyClass</span> {
 <span style="color: #7fffd4;">public</span>:
  ...
  <span style="color: #98fb98;">void</span> Foo();
};

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace mynamespace</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">In the .cc file</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">mynamespace</span> {

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Definition of functions is within scope of the namespace.</span>
<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">MyClass</span>::Foo() {
  ...
}

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace mynamespace</span>
</pre>
</div>
<p>
The typical .cc file might have more complex detail, including the
need to reference classes in other namespaces.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">"a.h"</span>

DEFINE_bool(someflag, <span style="color: #7fffd4;">false</span>, <span style="color: #ffa07a;">"dummy flag"</span>);

<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">C</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forward declaration of class C in the global namespace.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">a</span> { <span style="color: #98fb98;">class</span> <span style="color: #eedd82;">A</span>; }  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forward declaration of a::A.</span>

<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">b</span> {

...code <span style="color: #00ffff;">for</span> b...         <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Code goes against the left margin.</span>

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace b</span>
</pre>
</div>
</li>
<li>Do not declare anything in namespace std, not even forward
declarations of standard library classes.
</li>
<li>You may not use a using-directive to make all names from a namespace
available.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Forbidden -- This pollutes the namespace.</span>
using <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">foo</span>;
</pre>
</div>
</li>
<li>You may use a using-declaration anywhere in a .cc file, and in
functions, methods or classes in .h files.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK in .cc files.</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Must be in a function, method or class in .h files.</span>
using ::foo::bar;
</pre>
</div>
</li>
<li>Namespace aliases are allowed anywhere in a .cc file, anywhere
inside the named namespace that wraps an entire .h file, and in
functions and methods.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Shorten access to some commonly used names in .cc files.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">fbz</span> = ::foo::bar::baz;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Shorten access to some commonly used names (in a .h file).</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">librarian</span> {
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The following alias is available to all files including</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">this header (in namespace librarian):</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">alias names should therefore be chosen consistently</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">within a project.</span>
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">pd_s</span> = ::pipeline_diagnostics::sidetable;

<span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">my_inline_function</span>() {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace alias local to a function (or method).</span>
  <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">fbz</span> = ::foo::bar::baz;
  ...
}
}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace librarian</span>
</pre>
</div>
</li>
<li>Do not use inline namespaces.
</li>
</ul>
</div>
</li></ul>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Nested Classes</h3>
<div class="outline-text-3" id="text-3-2">
<p class="info">
当公有嵌套类作为接口的一部分时, 
虽然可以直接将他们保持在全局作用域中, 但将嵌套类的声明置于名字空间内是更好的选择.
</p>
<p>
Do not make nested classes public unless they are actually part of the
interface, e.g., a class that holds a set of options for some method.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Nonmember, Static Member, and Global Functions</h3>
<div class="outline-text-3" id="text-3-3">
<p class="info">
使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数.
</p>

<p>
Sometimes it is useful, or even necessary, to define a function not
bound to a class instance. Such a function can be either a static
member or a nonmember function. Nonmember functions should not depend
on external variables, and should nearly always exist in a namespace.
Rather than creating classes only to group static member functions
which do not share static data, use namespaces instead.
</p>

<p>
Functions defined in the same compilation unit as production classes
may introduce unnecessary coupling and link-time dependencies when
directly called from other compilation units; static member functions
are particularly susceptible to this. Consider extracting a new class,
or placing the functions in a namespace possibly in a separate
library.
</p>

<p>
If you must define a nonmember function and it is only needed in its
.cc file, use an unnamed namespace or static linkage (eg static int
Foo() {&#x2026;}) to limit its scope.
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Local Variables</h3>
<div class="outline-text-3" id="text-3-4">
<p class="info">
将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.
</p>

<p>
There is one caveat: if the variable is an object, its constructor is
invoked every time it enters scope and is created, and its destructor
is invoked every time it goes out of scope.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Inefficient implementation:</span>
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 1000000; ++i) {
  <span style="color: #98fb98;">Foo</span> <span style="color: #eedd82;">f</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">My ctor and dtor get called 1000000 times each.</span>
  f.DoSomething(i);
}
</pre>
</div>
<p>
It may be more efficient to declare such a variable used in a loop
outside that loop:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">Foo</span> <span style="color: #eedd82;">f</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">My ctor and dtor get called once each.</span>
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Static and Global Variables</h3>
<div class="outline-text-3" id="text-3-5">
<p class="info">
禁止使用 class 类型的静态或全局变量: 它们会导致很难发现的 
bug 和不确定的构造和析构函数调用顺序.但是，允许这些变量，
当他们是没有动态初始和析构的constexpr:时。
</p>

<p>
Objects with static storage duration, including global variables,
static variables, static class member variables, and function static
variables, must be Plain Old Data (POD): only ints, chars, floats, or
pointers, or arrays/structs of POD.
</p>

<p>
The order in which class constructors and initializers for static
variables are called is only partially specified in C++ and can even
change from build to build, which can cause bugs that are difficult to
find. Therefore in addition to banning globals of class type, we do
not allow static POD variables to be initialized with the result of a
function, unless that function (such as getenv(), or getpid()) does
not itself depend on any other globals.
</p>

<p>
One way to alleviate the destructor problem is to terminate the
program by calling <code>quick_exit()</code> instead of <code>exit()</code>. The difference is
that <code>quick_exit()</code> does not invoke destructors and does not invoke any
handlers that were registered by calling <code>atexit()</code>. If you have a
handler that needs to run when a program terminates via <code>quick_exit()</code>
(flushing logs, for example), you can register it using
<code>at_quick_exit()</code>. (If you have a handler that needs to run at both
<code>exit()</code> and <code>quick_exit()</code>, you need to register it in both places.)、
</p>

<p>
If you need a static or global variable of a class type, consider
initializing a pointer (which will never be freed), from either your
main() function or from <code>pthread_once()</code>. Note that this must be a raw
pointer, not a "smart" pointer, since the smart pointer's destructor
will have the order-of-destructor issue that we are trying to avoid.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Classes</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Doing Work in Constructors</h3>
<div class="outline-text-3" id="text-4-1">
<p class="info">
在构造函数中避免做复杂的初始化（特别，能失败或需要调用虚函数）
</p>

<p>
 <b>Decision:</b>
Constructors should never call virtual functions or attempt to raise
non-fatal failures. If your object requires non-trivial
initialization, consider using a factory function or Init() method.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Initialization</h3>
<div class="outline-text-3" id="text-4-2">
<p class="info">
如果类定义了成员变量，必须在类中定义一个初始化所有成员变量的初始化函数
或构造函数（可以是默认构造函数）。如果没有定义任何默认构造函数. 编译器
将自动生产一个默认的构造函数，使得一些没被初始化或初始化位不合理的值。
</p>
<p>
 <b>Decision:</b>
Use in-class member initialization for simple initializations,
especially when a member variable must be initialized the same way in
more than one constructor.
</p>

<p>
If your class defines member variables that aren't initialized
in-class, and if it has no other constructors, you must define a
default constructor (one that takes no arguments).
</p>

<p>
If your class inherits from an existing class but you add no new
member variables, you are not required to have a default constructor.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Explicit Constructors</h3>
<div class="outline-text-3" id="text-4-3">
<p class="info">
对单个参数的构造函数使用 C++ 关键字 explicit.
</p>
<p>
 <b>Decision:</b>
We require all single argument constructors to be explicit. Always put
explicit in front of one-argument constructors in the class
definition: explicit Foo(string name); 
</p>

<p>
The exception is copy constructors, which, in the rare cases when we
allow them, should probably not be explicit. Classes that are intended
to be transparent wrappers around other classes are also exceptions.
Such exceptions should be clearly marked with comments. 
</p>

<p>
Finally, constructors that take only an initializer<sub>list</sub> may be
non-explicit. This is to permit construction of your type using the
assigment form for brace init lists (i.e. MyType m = {1, 2} ).
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Copy Constructors</h3>
<div class="outline-text-3" id="text-4-4">
<p class="info">
仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数; 
大部分情况下都不需要, 此时应使用 DISALLOW_COPY_AND_ASSIGN.
</p>

<p>
 <b>Decision:</b>
Few classes need to be copyable. Most should have neither a copy
constructor nor an assignment operator. In many situations, a pointer
or reference will work just as well as a copied value, with better
performance. For example, you can pass function parameters by
reference or pointer instead of by value, and you can store pointers
rather than objects in an STL container. 
</p>

<p>
If your class needs to be copyable, prefer providing a copy method,
such as CopyFrom() or Clone(), rather than a copy constructor, because
such methods cannot be invoked implicitly. If a copy method is
insufficient in your situation (e.g. for performance reasons, or
because your class needs to be stored by value in an STL container),
provide both a copy constructor and assignment operator. 
</p>

<p>
If your class does not need a copy constructor or assignment operator,
you must explicitly disable them. To do so, add dummy declarations for
the copy constructor and assignment operator in the private: section
of your class, but do not provide any corresponding definition (so
that any attempt to use them results in a link error). 
</p>

<p>
For convenience, a <code>DISALLOW_COPY_AND_ASSIGN</code> macro can be used:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A macro to disallow the copy constructor and operator= functions</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This should be used in the private: declarations for a class</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">DISALLOW_COPY_AND_ASSIGN</span>(<span style="color: #eedd82;">TypeName</span>) \
  TypeName(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">TypeName</span>&amp;);               \
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">operator</span>=(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">TypeName</span>&amp;)
</pre>
</div>
<p>
Then, in <code>class Foo</code>:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">class</span> <span style="color: #eedd82;">Foo</span> {
 <span style="color: #7fffd4;">public</span>:
  Foo(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">f</span>);
  ~Foo();

 <span style="color: #7fffd4;">private</span>:
  DISALLOW_COPY_AND_ASSIGN(Foo);
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Delegating and inheriting constructors</h3>
<div class="outline-text-3" id="text-4-5">
<p class="info">
使用委托和继承构造函数，当他们减少重复代码。
</p>

<p>
<b>Decision:</b>
Use delegating and inheriting constructors when they reduce
boilerplate and improve readability. Be cautious about inheriting
constructors when your derived class has new member variables.
Inheriting constructors may still be appropriate in that case if you
can use in-class member initialization for the derived class's member
variables. 
</p>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Structs vs. Classes</h3>
<div class="outline-text-3" id="text-4-6">
<p class="info">
仅当只有数据时使用 struct, 其它一概使用 class.
</p>
<p>
structs should be used for passive objects that carry data, and may
have associated constants, but lack any functionality other than
access/setting the data members. The accessing/setting of fields is
done by directly accessing the fields rather than through method
invocations. Methods should not provide behavior but should only be
used to set up the data members, e.g., constructor, destructor,
Initialize(), Reset(), Validate(). 
</p>

<p>
If more functionality is required, a class is more appropriate. If in
doubt, make it a class.
</p>

<p>
For consistency with STL, you can use struct instead of class for
functors(仿函数) and traits(特性). 
</p>

<p>
Note that member variables in structs and classes have <b>different
naming rules</b>.
</p>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Inheritance</h3>
<div class="outline-text-3" id="text-4-7">
<p class="info">
使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.
</p>
<p>
 <b>定义:</b>
当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承 (implementation inheritance), 子类继承父类的实现代码; 接口继承 (interface inheritance), 子类仅继承父类的方法名称. 
</p>

<p>
 <b>Decision:</b>
All inheritance should be public. If you want to do private
inheritance, you should be including an instance of the base class as
a member instead. 
</p>

<p>
Do not overuse implementation inheritance. Composition is often more
appropriate. Try to restrict use of inheritance to the "is-a" case:
Bar subclasses Foo if it can reasonably be said that Bar "is a kind
of" Foo. 
</p>

<p>
Make your destructor virtual if necessary. If your class has virtual
methods, its destructor should be virtual. 
</p>

<p>
Limit the use of protected to those member functions that might need
to be accessed from subclasses. Note that <b>data members should be
private</b>. 
</p>

<p>
When redefining an inherited virtual function, explicitly declare it
virtual in the declaration of the derived class. Rationale: If virtual
is omitted, the reader has to check all ancestors of the class in
question to determine if the function is virtual or not.
</p>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">Multiple Inheritance</h3>
<div class="outline-text-3" id="text-4-8">
<p class="info">
真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 
最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.
</p>
<p>
 <b>Decision:</b>
Multiple inheritance is allowed only when all superclasses, with the
possible exception of the first one, are pure interfaces. In order to
ensure that they remain pure interfaces, they must end with the
Interface suffix. 
</p>

<p>
Note: There is an exception to this rule on Windows.
</p>
</div>
</div>

<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9">Interfaces</h3>
<div class="outline-text-3" id="text-4-9">
<p class="info">
接口是指满足特定条件的类, 这些类以 Interface 为后缀,不强制.
</p>

<p>
<b>定义:</b>
当一个类满足以下要求时, 称之为纯接口:
</p>

<ul class="org-ul">
<li>只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).
</li>
<li>没有非静态数据成员.
</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.
</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.

<p>
<b>Decision:</b>
</p>
</li>
</ul>
<p>
A class may end with Interface only if it meets the above
requirements. however: classes that meet the above requirements are
not required to end with Interface.  
</p>
</div>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10">Operator Overloading</h3>
<div class="outline-text-3" id="text-4-10">
<p class="info">
除少数特定环境外，不要重载运算符. 不要自己定义字义。
</p>

<p>
 <b>Decision:</b>
In general, do not overload operators. The assignment operator
(operator=), in particular, is insidious and should be avoided. You
can define functions like Equals() and CopyFrom() if you need them.
Likewise, avoid the dangerous unary operator&amp; at all costs, if there's
any possibility the class might be forward-declared. 
</p>

<p>
Do not overload operator"", i.e. do not introduce user-defined
literals. 
</p>

<p>
However, there may be rare cases where you need to overload an
operator to interoperate with templates or "standard" C++ classes
(such as operator&lt;&lt;(ostream&amp;, const T&amp;) for logging). These are
acceptable if fully justified, but you should try to avoid these
whenever possible. In particular, do not overload operator== or
operator&lt; just so that your class can be used as a key in an STL
container; instead, you should create equality and comparison functor
types when declaring the container. 
</p>

<p>
Some of the STL algorithms do require you to overload operator==, and
you may do so in these cases, provided you document why.
</p>
</div>
</div>

<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11">Access Control</h3>
<div class="outline-text-3" id="text-4-11">
<p class="info">
将所有数据成员声明为 private, 并根据需要提供相应的存取函数(一些技术原
因，允许测试类的数据成员位protected，当使用Google Test). 例如, 某个名
为 foo_ 的变量, 其取值函数是 foo(). 还可能需要一个赋值函数set_foo().
例外：static const的数据成员（通常称为kFoo)不需要private.
</p>

<p>
The definitions of accessors are usually inlined in the header file.
</p>
</div>
</div>

<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12">Declaration Order</h3>
<div class="outline-text-3" id="text-4-12">
<p class="info">
在类中使用特定的声明顺序: public: 在 private: 之前, 成员函数在数据成员 (变量) 前;
</p>
<p>
Your class definition should start with its public: section, followed
by its protected: section and then its private: section. If any of
these sections are empty, omit them. 
</p>

<p>
Within each section, the declarations generally should be in the
following order: 
</p>

<ul class="org-ul">
<li>Typedefs and Enums
</li>
<li>Constants (static const data members)
</li>
<li>Constructors
</li>
<li>Destructor
</li>
<li>Methods, including static methods
</li>
<li>Data Members (except static const data members)
</li>
</ul>

<p>
Friend declarations should always be in the private section, and the
<code>DISALLOW_COPY_AND_ASSIGN</code> macro invocation should be at the end of the
private: section. It should be the last thing in the class.
</p>

<p>
Method definitions in the corresponding .cc file should be the same as
the declaration order, as much as possible. 
</p>

<p>
Do not put large method definitions inline in the class definition.
Usually, only trivial or performance-critical, and very short, methods
may be defined inline. 
</p>
</div>
</div>

<div id="outline-container-sec-4-13" class="outline-3">
<h3 id="sec-4-13">Write Short Functions</h3>
<div class="outline-text-3" id="text-4-13">
<p class="info">
倾向编写简短, 凝练的函数.
</p>
<p>
如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Google-Specific Magic</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Ownership and Smart Pointers</h3>
<div class="outline-text-3" id="text-5-1">
<p class="info">
对动态分配的对象只有一个固定的隶属折。传递隶属使用智能指针。
</p>
</div>

<ul class="org-ul"><li><a id="sec-5-1-1" name="sec-5-1-1"></a>Definition:<br  /><div class="outline-text-4" id="text-5-1-1">
<p>
"Ownership" is a bookkeeping technique for managing dynamically
allocated memory (and other resources). The owner of a dynamically
allocated object is an object or function that is responsible for
ensuring that it is deleted when no longer needed. Ownership can
sometimes be shared, in which case the last owner is typically
responsible for deleting it. Even when ownership is not shared, it can
be transferred from one piece of code to another. 
</p>

<p>
"Smart" pointers are classes that act like pointers, e.g. by
overloading the * and -&gt; operators. Some smart pointer types can be
used to automate ownership bookkeeping, to ensure these
responsibilities are met. <code>std::unique_ptr</code> is a smart pointer type
introduced in C++11, which expresses exclusive ownership of a
dynamically allocated object; the object is deleted when the
<code>std::unique_ptr</code> goes out of scope. It cannot be copied, but can be
moved to represent ownership transfer. <code>shared_ptr</code> is a smart pointer
type which expresses shared ownership of a dynamically allocated
object. <code>shared_ptrs</code> can be copied; ownership of the object is shared
among all copies, and the object is deleted when the last <code>shared_ptr</code>
is destroyed.
</p>
</div>
</li>

<li><a id="sec-5-1-2" name="sec-5-1-2"></a>Cons:<br  /><div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>Ownership must be represented and transferred via pointers (whether
smart or plain). Pointer semantics are more complicated than value
semantics, especially in APIs: you have to worry not just about
ownership, but also aliasing, lifetime, and mutability, among other
issues. 
</li>
<li>The performance costs of value semantics are often overestimated, so
the performance benefits of ownership transfer might not justify the
readability and complexity costs. 
</li>
<li>APIs that transfer ownership force their clients into a single
memory management model.
</li>
<li>Code using smart pointers is less explicit about where the resource
releases take place. 
</li>
<li>std::unique<sub>ptr</sub> expresses ownership transfer using C++11's move
semantics, which are generally forbidden in Google code, and may
confuse some programmers. 
</li>
<li>Shared ownership can be a tempting alternative to careful ownership
design, obfuscating the design of a system. 
</li>
<li>Shared ownership requires explicit bookkeeping at run-time, which
can be costly. 
</li>
<li>In some cases (e.g. cyclic references), objects with shared
ownership may never be deleted. 
</li>
<li>Smart pointers are not perfect substitutes for plain pointers.
</li>
</ul>
</div>
</li>
<li><a id="sec-5-1-3" name="sec-5-1-3"></a>Decision:<br  /><div class="outline-text-4" id="text-5-1-3">
<p>
If dynamic allocation is necessary, prefer to keep ownership with the
code that allocated it. If other code needs access to the object,
consider passing it a copy, or passing a pointer or reference without
transferring ownership. Prefer to use <code>std::unique_ptr</code> to make
ownership transfer explicit. For example: 
</p>
<div class="org-src-container">

<pre class="src src-c">std::unique_ptr&lt;Foo&gt; FooFactory();
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">FooConsumer</span>(std::unique_ptr&lt;Foo&gt; ptr);
</pre>
</div>
<p>
Do not design your code to use shared ownership without a very good
reason. One such reason is to avoid expensive copy operations, but you
should only do this if the performance benefits are significant, and
the underlying object is immutable (i.e. <code>shared_ptr&lt;const Foo&gt;</code>). If
you do use shared ownership, prefer to use <code>shared_ptr</code>. 
</p>

<p>
Do not use <code>scoped_ptr</code> in new code unless you need to be compatible
with older versions of C++. Never use <code>linked_ptr</code> or <code>std::auto_ptr</code>. In
all three cases, use <code>std::unique_ptr</code> instead.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">cpplint</h3>
<div class="outline-text-3" id="text-5-2">
<p class="info">
使用 cpplint.py 检查风格错误.
</p>

<p>
False positives can be ignored by putting // NOLINT at the end of the line.
</p>

<p>
download <a href="http://google-styleguide.googlecode.com/svn/trunk/cpplint/cpplint.py">cpplint.py</a> separately.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Other C++ Features</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Reference Arguments</h3>
<div class="outline-text-3" id="text-6-1">
<p class="info">
所有按引用传递的参数必须加上 const.
</p>

<p>
<b>Decision:</b>
Within function parameter lists all references must be const:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Foo</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">string</span> &amp;in, <span style="color: #98fb98;">string</span> *<span style="color: #eedd82;">out</span>);
</pre>
</div>
<p>
In fact it is a very strong convention in Google code that input
arguments are values or const references while output arguments are
pointers. Input parameters may be const pointers, but we never allow
non-const reference parameters except when required by convention,
e.g., <code>swap()</code>. 
</p>

<p>
However, there are some instances where using <code>const T*</code> is preferable
to <code>const T&amp;</code> for input parameters. For example: 
</p>

<ul class="org-ul">
<li>You want to pass in a null pointer.
</li>
<li>The function saves a pointer or reference to the input. 
</li>
</ul>

<p>
So if you choose <code>const T*</code> rather than <code>const T&amp;</code>, do so for a concrete
reason; otherwise it will likely confuse readers by making them look
for an explanation that doesn't exist.
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Rvalue references</h3>
<div class="outline-text-3" id="text-6-2">
<p class="info">
Do not use rvalue references, std::forward, std::move_iterator, or
std::move_if_noexcept. Use the single-argument form of std::move only
with non-copyable arguments. 
</p>
<p>
<b>Decision:</b>
Do not use rvalue references, and do not use the <code>std::forward</code> or
<code>std::move_if_noexcept</code> utility functions (which are essentially just
casts to rvalue reference types), or <code>std::move_iterator</code>. Use
single-argument <code>std::move</code> only with objects that are not copyable
(e.g. <code>std::unique_ptr</code>), or in templated code with objects that might
not be copyable.
</p>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Function Overloading</h3>
<div class="outline-text-3" id="text-6-3">
<p class="info">
仅在读者看到调用能很好的知道发生了啥而不是首先去搞清楚哪个重载被调用时
使用重载函数 (含构造函数). 
</p>

<p>
<b>Decision:</b>
If you want to overload a function, consider qualifying the name with
some information about the arguments, e.g., AppendString(),
AppendInt() rather than just Append().
</p>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Default Arguments</h3>
<div class="outline-text-3" id="text-6-4">
<p class="info">
我们不允许使用缺省函数参数，除了以下说明的有限场合。如果合适，用函数重
载来模仿它们。
</p>

<p>
<b>Decision:</b>
So except as described below, we require all arguments to be
explicitly specified. 
</p>

<p>
One specific exception is when the function is a static function (or
in an unnamed namespace) in a .cc file. In this case, the cons don't
apply since the function's use is so localized. 
</p>

<p>
Another specific exception is when default arguments are used to
simulate variable-length argument lists. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Support up to 4 params by using a default empty AlphaNum.</span>
<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">StrCat</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">AlphaNum</span> &amp;a,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">AlphaNum</span> &amp;b = gEmptyAlphaNum,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">AlphaNum</span> &amp;c = gEmptyAlphaNum,
              <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">AlphaNum</span> &amp;d = gEmptyAlphaNum);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Variable-Length Arrays and alloca()</h3>
<div class="outline-text-3" id="text-6-5">
<p class="info">
我们不允许使用变长数组和 alloca().
</p>

<p>
<b>Decision:</b>
Use a safe allocator instead, such as <code>scoped_ptr/scoped_array</code>.
</p>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Friends</h3>
<div class="outline-text-3" id="text-6-6">
<p class="info">
我们允许合理的使用友元类及友元函数.
</p>

<p>
Friends should usually be defined in the same file so that the reader
does not have to look in another file to find uses of the private
members of a class. A common use of friend is to have a FooBuilder
class be a friend of Foo so that it can construct the inner state of
Foo correctly, without exposing this state to the world. In some cases
it may be useful to make a unittest class a friend of the class it
tests.
</p>
</div>
</div>
<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7">Exceptions</h3>
<div class="outline-text-3" id="text-6-7">
<p class="info">
我们不使用 C++ 异常.
</p>

<p>
On their face, the benefits of using exceptions outweigh the costs,
especially in new projects. However, for existing code, the
introduction of exceptions has implications on all dependent code. If
exceptions can be propagated beyond a new project, it also becomes
problematic to integrate the new project into existing exception-free
code. Because most existing C++ code at Google is not prepared to deal
with exceptions, it is comparatively difficult to adopt new code that
generates exceptions.
</p>

<p>
Given that Google's existing code is not exception-tolerant, the costs
of using exceptions are somewhat greater than the costs in a new
project. 
</p>

<p>
This prohibition also applies to the exception-related features added
in C++11, such as <code>noexcept</code>, <code>std::exception_ptr</code>, and
<code>std::nested_exception</code>. 
</p>

<p>
There is an exception to this rule (no pun intended) for Windows code.
</p>
</div>
</div>
<div id="outline-container-sec-6-8" class="outline-3">
<h3 id="sec-6-8">Run-Time Type Information (RTTI)</h3>
<div class="outline-text-3" id="text-6-8">
<p class="info">
禁止使用 RTTI.
</p>
<p>
RTTI allows a programmer to query the C++ class of an object at run
time. This is done by use of <code>typeid</code> or <code>dynamic_cast</code>. 
</p>

<p>
<b>Decision:</b>
RTTI has legitimate uses but is prone to abuse, so you must be careful
when using it. You may use it freely in unittests, but avoid it when
possible in other code. In particular, think twice before using RTTI
in new code. If you find yourself needing to write code that behaves
differently based on the class of an object, consider one of the
following alternatives to querying the type: 
</p>

<ul class="org-ul">
<li>Virtual methods are the preferred way of executing different code
paths depending on a specific subclass type. This puts the work
within the object itself. 
</li>
<li>If the work belongs outside the object and instead in some
processing code, consider a double-dispatch solution, such as the
Visitor design pattern. This allows a facility outside the object
itself to determine the type of class using the built-in type
system.
</li>
</ul>

<p>
When the logic of a program guarantees that a given instance of a base
class is in fact an instance of a particular derived class, then a
<code>dynamic_cast</code> may be used freely on the object. Usually one can use a
<code>static_cast</code> as an alternative in such situations. 
</p>

<p>
Do not hand-implement an RTTI-like workaround. The arguments against
RTTI apply just as much to workarounds like class hierarchies with
type tags. Moreover, workarounds disguise your true intent.
</p>
</div>
</div>
<div id="outline-container-sec-6-9" class="outline-3">
<h3 id="sec-6-9">Casting</h3>
<div class="outline-text-3" id="text-6-9">
<p class="info">
使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或
int y = int(x) 等转换方式; 
</p>

<p>
<b>Decision:</b>
Do not use C-style casts. Instead, use these C++-style casts.
</p>

<ul class="org-ul">
<li>Use <code>static_cast</code> as the equivalent of a C-style cast that does value
conversion, or when you need to explicitly up-cast a pointer from a
class to its superclass. 
</li>
<li>Use <code>const_cast</code> to remove the const qualifier (see const).
</li>
<li>Use <code>reinterpret_cast</code> to do unsafe conversions of pointer types to
and from integer and other pointer types. Use this only if you know
what you are doing and you understand the aliasing issues. 
</li>
<li>You may use <code>dynamic_cast</code> freely in unittests, but avoid it when
possible in other code.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-10" class="outline-3">
<h3 id="sec-6-10">Streams</h3>
<div class="outline-text-3" id="text-6-10">
<p class="info">
只在记录日志时使用流
</p>

<p>
<b>Decision:</b>
Do not use streams, except where required by a logging interface. Use
printf-like routines instead. 
</p>

<p>
Either path would yield different advantages and disadvantages, and
there is not a clearly superior solution. The simplicity doctrine
mandates we settle on one of them though, and the majority decision
was on <code>printf + read/write</code>.
</p>
</div>
</div>
<div id="outline-container-sec-6-11" class="outline-3">
<h3 id="sec-6-11">Preincrement and Predecrement</h3>
<div class="outline-text-3" id="text-6-11">
<p class="info">
对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.
</p>

<p>
<b>Decision:</b>
For simple scalar (non-object) values there is no reason to prefer one
form and we allow either. For iterators and other template types, use
pre-increment.
</p>
</div>
</div>
<div id="outline-container-sec-6-12" class="outline-3">
<h3 id="sec-6-12">Use of const</h3>
<div class="outline-text-3" id="text-6-12">
<p class="info">
我们强烈建议你在任何可能的情况下都要使用 const. 对于C++11中一些const，
constexpr 是更好的选择。
</p>

<p>
<code>const</code> variables, data members, methods and arguments add a level of
compile-time type checking; it is better to detect errors as soon as
possible. Therefore we strongly recommend that you use const whenever
it makes sense to do so: 
</p>

<ul class="org-ul">
<li>If a function does not modify an argument passed by reference or by
pointer, that argument should be const. 
</li>
<li>Declare methods to be const whenever possible. Accessors should
almost always be const. Other methods should be const if they do not
modify any data members, do not call any non-const methods, and do
not return a non-const pointer or non-const reference to a data
member. 
</li>
<li>Consider making data members const whenever they do not need to be
modified after construction. 
</li>
</ul>

<p>
The <code>mutable</code> keyword is allowed but is unsafe when used with threads,
so thread safety should be carefully considered first. 
</p>

<p>
That said, while we encourage putting <code>const</code> first, we do not require
it. But be consistent with the code around you!
</p>
</div>
</div>
<div id="outline-container-sec-6-13" class="outline-3">
<h3 id="sec-6-13">Use of constexpr</h3>
<div class="outline-text-3" id="text-6-13">
<p class="info">
In C++11, use constexpr to define true constants or to ensure constant
initialization. 
</p>

<p>
<b>Decision:</b>
<code>constexpr</code> definitions enable a more robust specification of the
constant parts of an interface. Use <code>constexpr</code> to specify true
constants and the functions that support their definitions. Avoid
complexifying function definitions to enable their use with <code>constexpr</code>.
Do not use constexpr to force inlining.
</p>
</div>
</div>
<div id="outline-container-sec-6-14" class="outline-3">
<h3 id="sec-6-14">Integer Types</h3>
<div class="outline-text-3" id="text-6-14">
<p>
Of the built-in C++ integer types, the only one used is int. If a
program needs a variable of a different size, use a precise-width
integer type from <code>&lt;stdint.h&gt;</code>, such as <code>int16_t</code>. If your variable
represents a value that could ever be greater than or equal to 2<sup>31</sup>
(2GiB), use a 64-bit type such as <code>int64_t</code>. Keep in mind that even if
your value won't ever be too large for an int, it may be used in
intermediate calculations which may require a larger type. When in
doubt, choose a larger type.
</p>

<p>
<b>Decision:</b>
<code>&lt;stdint.h&gt;</code> defines types like <code>int16_t</code>, <code>uint32_t</code>, <code>int64_t</code>, etc. You
should always use those in preference to short, unsigned long long and
the like, when you need a guarantee on the size of an integer. Of the
C integer types, only int should be used. When appropriate, you are
welcome to use standard types like <code>size_t</code> and <code>ptrdiff_t</code>. 
</p>

<p>
For integers we know can be "big", use <code>int64_t</code>.
</p>

<p>
You should not use the unsigned integer types such as uint32<sub>t</sub>, unless
there is a valid reason such as representing a bit pattern rather than
a number, or you need defined overflow modulo 2<sup>N</sup>. In particular, do
not use unsigned types to say a number will never be negative.
Instead, use <b>assertions</b> for this. 
</p>

<p>
Use care when converting integer types. Integer conversions and
promotions can cause non-intuitive behavior.
</p>

<p>
So, document that a variable is non-negative using assertions. Don't
use an unsigned type. 
</p>
</div>
</div>

<div id="outline-container-sec-6-15" class="outline-3">
<h3 id="sec-6-15">64-bit Portability</h3>
<div class="outline-text-3" id="text-6-15">
<p class="info">
代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:
</p>

<ul class="org-ul">
<li>printf() specifiers for some types are not cleanly portable between
32-bit and 64-bit systems. C99 defines some portable format
specifiers. Unfortunately, MSVC 7.1 does not understand some of
these specifiers and the standard is missing a few, so we have to
define our own ugly versions in some cases (in the style of the
standard include file inttypes.h): 
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">printf macros for size_t, in the style of inttypes.h</span>
<span style="color: #b0c4de;">#ifdef</span> _LP64
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">__PRIS_PREFIX</span> <span style="color: #ffa07a;">"z"</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">__PRIS_PREFIX</span>
<span style="color: #b0c4de;">#endif</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Use these macros after a % in a printf format string</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">to get correct 32/64 bit behavior, like this:</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">size_t size = records.size();</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">printf("%"PRIuS"\n", size);</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PRIdS</span> __PRIS_PREFIX <span style="color: #ffa07a;">"d"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PRIxS</span> __PRIS_PREFIX <span style="color: #ffa07a;">"x"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PRIuS</span> __PRIS_PREFIX <span style="color: #ffa07a;">"u"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PRIXS</span> __PRIS_PREFIX <span style="color: #ffa07a;">"X"</span>
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PRIoS</span> __PRIS_PREFIX <span style="color: #ffa07a;">"o"</span>
</pre>
</div>
</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">DO NOT use</th>
<th scope="col" class="left">DO use</th>
<th scope="col" class="left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">=void *=(or any pointer)</td>
<td class="left">%lx</td>
<td class="left">%p</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>int64_t</code></td>
<td class="left">%qd,%lld</td>
<td class="left">%"PRId64"</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>uint64_t</code></td>
<td class="left">%qu,%llu,%llx</td>
<td class="left">%"PRIu64",%"PRIx64"</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>size_t</code></td>
<td class="left">%u</td>
<td class="left">%"PRIuS",%"PRIxS"</td>
<td class="left">C99 sepecifies %zu</td>
</tr>

<tr>
<td class="left"><code>ptrdiff_t</code></td>
<td class="left">%d</td>
<td class="left">%"PRIdS"</td>
<td class="left">C99 sepecifies %td</td>
</tr>
</tbody>
</table>
<p>
Note that the PRI* macros expand to independent strings which are
concatenated by the compiler. Hence if you are using a non-constant
format string, you need to insert the value of the macro into the
format, rather than the name. It is still possible, as usual, to
include length specifiers, etc., after the % when using the PRI*
macros. So, e.g. <code>printf("x = %30"PRIuS"\n", x)</code> would expand on 32-bit
Linux to <code>printf("x = %30" "u" "\n", x)</code>, which the compiler will treat
as <code>printf("x = %30u\n", x)</code>. 
</p>

<ul class="org-ul">
<li>Remember that <code>sizeof(void *) != sizeof(int)</code>. Use <code>intptr_t</code> if you
want a pointer-sized integer. 
</li>
<li>You may need to be careful with structure alignments, particularly
for structures being stored on disk. Any class/structure with a
int64<sub>t</sub>/uint64<sub>t</sub> member will by default end up being 8-byte aligned
on a 64-bit system. If you have such structures being shared on disk
between 32-bit and 64-bit code, you will need to ensure that they
are packed the same on both architectures. Most compilers offer a
way to alter structure alignment. For gcc, you can use
<code>__attribute__((packed))</code>. MSVC offers <code>#pragma pack()</code> and
<code>__declspec(align())</code>. 
</li>
<li>Use the LL or ULL suffixes as needed to create 64-bit constants. For
example:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int64_t</span> <span style="color: #eedd82;">my_value</span> = 0x123456789LL;
<span style="color: #98fb98;">uint64_t</span> <span style="color: #eedd82;">my_mask</span> = 3ULL &lt;&lt; 48;
</pre>
</div>
</li>
<li>If you really need different code on 32-bit and 64-bit systems,
use #ifdef _LP64 to choose between the code variants. (But please
avoid this if possible, and keep any such changes localized.)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-16" class="outline-3">
<h3 id="sec-6-16">Preprocessor Macros</h3>
<div class="outline-text-3" id="text-6-16">
<p class="info">
使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之. 
</p>

<p>
Instead of using a macro to inline performance-critical code, use an
inline function. Instead of using a macro to store a constant, use a
const variable. Instead of using a macro to "abbreviate" a long
variable name, use a reference. Instead of using a macro to
conditionally compile code &#x2026; well, don't do that at all (except, of
course, for the #define guards to prevent double inclusion of header
files). It makes testing much more difficult.
</p>

<p>
Macros can do things these other techniques cannot, and you do see
them in the codebase, especially in the lower-level libraries. And
some of their special features (like stringifying(#), concatenation(##), and
so forth) are not available through the language proper. But before
using a macro, consider carefully whether there's a non-macro way to
achieve the same result. 
</p>

<p>
The following usage pattern will avoid many problems with macros; if
you use macros, follow it whenever possible: 
</p>

<ul class="org-ul">
<li>Don't define macros in a .h file.
</li>
<li>#define macros right before you use them, and #undef them right after.
</li>
<li>Do not just #undef an existing macro before replacing it with your
own; instead, pick a name that's likely to be unique. 
</li>
<li>Try not to use macros that expand to unbalanced C++ constructs, or
at least document that behavior well. 
</li>
<li>Prefer not using ## to generate function/class/variable names.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-17" class="outline-3">
<h3 id="sec-6-17">0 and nullptr/NULL</h3>
<div class="outline-text-3" id="text-6-17">
<p class="info">
整数用 0, 实数用 0.0, 指针用 nullptr(或NULL), 字符 (串) 用 '\0'.
</p>
<p>
For pointers (address values), there is a choice between 0, NULL, and
nullptr. For projects that allow C++11 features, use nullptr.  
</p>

<p>
In fact, some C++ compilers provide special definitions of NULL which
enable them to give useful warnings, particularly in situations where
sizeof(NULL) is not equal to sizeof(0).
</p>
</div>
</div>
<div id="outline-container-sec-6-18" class="outline-3">
<h3 id="sec-6-18">sizeof</h3>
<div class="outline-text-3" id="text-6-18">
<p class="info">
尽可能用 sizeof(varname) 代替 sizeof(type).
</p>
<p>
Use sizeof(varname) when you take the size of a particular variable.
sizeof(varname) will update appropriately if someone changes the
variable type either now or later. You may use sizeof(type) for code
unrelated to any particular variable, such as code that manages an
external or internal data format where a variable of an appropriate
C++ type is not convenient. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">Struct</span> <span style="color: #eedd82;">data</span>;
memset(&amp;data, 0, <span style="color: #00ffff;">sizeof</span>(data));

memset(&amp;data, 0, <span style="color: #00ffff;">sizeof</span>(Struct));

<span style="color: #00ffff;">if</span> (raw_size &lt; <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>)) {
  LOG(ERROR) &lt;&lt; <span style="color: #ffa07a;">"compressed record not big enough for count: "</span> &lt;&lt; raw_size;
  <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
}
&lt;/p&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-19" class="outline-3">
<h3 id="sec-6-19">auto</h3>
<div class="outline-text-3" id="text-6-19">
<p class="info">
仅使用auto来避免杂乱的类型名。继续使用明示的类型声明当有助于读取，仅对本地变量使用auto。
</p>

<p>
<b>Decision:</b>
auto is permitted, for local variables only. . Never assign a braced
initializer list to an auto-typed variable.
</p>

<p>
The auto keyword is also used in an unrelated C++11 feature: it's part
of the syntax for a new kind of function declaration with a trailing
return type. Function declarations with trailing return types are not
permitted.
</p>
</div>
</div>
<div id="outline-container-sec-6-20" class="outline-3">
<h3 id="sec-6-20">Brace Initialization</h3>
<div class="outline-text-3" id="text-6-20">
<p class="info">
可用 brace initialization.
</p>

<p>
Never assign a braced-init-list to an auto local variable. In the
single element case, what this means can be confusing. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">d</span> = {1.23};        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">d is an initializer_list&lt;double&gt;</span>
<span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">d</span> = <span style="color: #98fb98;">double</span>{1.23};  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Good -- d is a double, not an initializer_list.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-21" class="outline-3">
<h3 id="sec-6-21">Lambda expressions</h3>
<div class="outline-text-3" id="text-6-21">
<p class="info">
不要使用lamba表达式，或相关的 std::function和std::bind程序。
</p>
</div>
</div>
<div id="outline-container-sec-6-22" class="outline-3">
<h3 id="sec-6-22">Boost</h3>
<div class="outline-text-3" id="text-6-22">
<p class="info">
只使用 Boost 中被认可的库.
</p>

<p>
<b>Decision:</b>
</p>
<ul class="org-ul">
<li><code>Call Traits</code> from <code>boost/call_traits.hpp</code>
</li>
<li><code>Compressed Pair</code> from <code>boost/compressed_pair.hpp</code>
</li>
<li><code>The Boost Graph Library (BGL)</code> from boost/graph, except serialization
(<code>adj_list_serialize.hpp</code>) and parallel/distributed algorithms and
data structures (<code>boost/graph/parallel/*</code> and
<code>boost/graph/distributed/*</code>). 
</li>
<li><code>Property Map</code> from <code>boost/property_map</code>, except
parallel/distributed property maps (<code>boost/property_map/parallel/*</code>). 
</li>
<li>The part of <code>Iterator</code> that deals with defining iterators:
<code>boost/iterator/iterator_adaptor.hpp</code>,
<code>boost/iterator/iterator_facade.hpp</code>, and
<code>boost/function_output_iterator.hpp</code>
</li>
<li>The part of <code>Polygon</code> that deals with Voronoi diagram construction and
doesn't depend on the rest of Polygon:
<code>boost/polygon/voronoi_builder.hpp</code>,
<code>boost/polygon/voronoi_diagram.hpp</code>, and
<code>boost/polygon/voronoi_geometry_type.hpp</code>
</li>
<li><code>Bimap</code> from <code>boost/bimap</code>
</li>
<li><code>Statistical Distributions and Functions</code> from
<code>boost/math/distributions</code>
</li>
</ul>

<p>
The following libraries are permitted, but their use is discouraged
because they've been superseded by standard libraries in C++11: 
</p>

<ul class="org-ul">
<li><code>Array</code> from <code>boost/array.hpp</code>: use <code>std::array instead</code>.
</li>
<li><code>Pointer Container</code> from <code>boost/ptr_container</code>: use containers of
<code>std::unique_ptr</code> instead.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-23" class="outline-3">
<h3 id="sec-6-23">C++11</h3>
<div class="outline-text-3" id="text-6-23">
<p class="info">
适宜的使用C++11的库和语言扩展。再工程中使用c++11的特性前，考虑移植不同的环境。
</p>

<p>
<b>Decision:</b>
C++11 features may be used unless specified otherwise. In addition to what's described in the rest of the style guide, the following C++11 features may not be used:
</p>

<ul class="org-ul">
<li>Functions with trailing return types, e.g. writing <code>auto foo()
  -&gt;int</code>; instead of <code>int foo()</code>;, because of a desire to preserve 
stylistic consistency with the many existing function declarations. 
</li>
<li>Compile-time rational numbers (<code>&lt;ratio&gt;</code>), because of concerns that
it's tied to a more template-heavy interface style. 
</li>
<li>The <code>&lt;cfenv&gt;</code> and <code>&lt;fenv.h&gt;</code> headers, because many compilers do not
support those features reliably. 
</li>
<li>Lambda expressions, or the related <code>std::function</code> or <code>std::bind
  utilities</code>. 
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Naming</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">General Naming Rules</h3>
<div class="outline-text-3" id="text-7-1">
<p class="info">
函数命名, 变量命名, 文件命名应具备描述性; 不要过度缩写.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">price_count_reader</span>;    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No abbreviation.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_errors</span>;            <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">"num" is a widespread convention.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_dns_connections</span>;   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Most people know what "DNS" stands for.</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;                     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Meaningless.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nerr</span>;                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Ambiguous abbreviation.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n_comp_conns</span>;          <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Ambiguous abbreviation.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">wgc_connections</span>;       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Only your group knows what this stands for.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pc_reader</span>;             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Lots of things can be abbreviated "pc".</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">cstmr_id</span>;              <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Deletes internal letters.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">File Names</h3>
<div class="outline-text-3" id="text-7-2">
<p class="info">
文件名要全部小写, 可以包含下划线 (_) 或连字符 (-). 按项目约定来.如果没有本地模式遵循，用"_".
</p>

<p>
Examples of acceptable file names:
</p>
<div class="org-src-container">

<pre class="src src-c">my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
myusefulclass_test.cc <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">_unittest and _regtest are deprecated.</span>
</pre>
</div>
<p>
C++ files should end in .cc and header files should end in .h.
</p>

<p>
Inline functions must be in a .h file. If your inline functions are
very short, they should go directly into your .h file. However, if
your inline functions include a lot of code, they may go into a third
file that ends in -inl.h. In a class with a lot of inline code, your
class could have three files: 
</p>
<div class="org-src-container">

<pre class="src src-c">url_table.h      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The class declaration.</span>
url_table.cc     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The class definition.</span>
url_table-inl.h  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Inline functions that include lots of code.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Type Names</h3>
<div class="outline-text-3" id="text-7-3">
<p class="info">
类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
</p>

<p>
The names of all types — <b>classes, structs, typedefs, and enums</b> — have
the same naming convention. Type names should start with a capital
letter and have a capital letter for each new word. No underscores.
For example: 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">classes and structs</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">UrlTable</span> { ...
class UrlTableTester { ...
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">UrlTableProperties</span> { ...

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">typedefs</span>
<span style="color: #00ffff;">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">enums</span>
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">UrlTableErrors</span> { ...
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Variable Names</h3>
<div class="outline-text-3" id="text-7-4">
<p class="info">
变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 
如:<code>my_exciting_local_variable</code>,
<code>my_exciting_member_variable_</code>.
</p>

<ul class="org-ul">
<li>Common Variable names
For example:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">string</span> <span style="color: #eedd82;">table_name</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK - uses underscore.</span>
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">tablename</span>;   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK - all lowercase.</span>
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">tableName</span>;   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bad - mixed case.</span>
</pre>
</div>
</li>
<li>Class Data Members
Data members (also called instance variables or member variables)
are lowercase with optional underscores like regular variable names,
but always end with a trailing underscore. 
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">string</span> <span style="color: #eedd82;">table_name_</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK - underscore at end.</span>
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">tablename_</span>;   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK.</span>
</pre>
</div>
</li>
<li>Struct Variables
Data members in structs should be named like regular variables
without the trailing underscores that data members in classes have. 
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">UrlTableProperties</span> {
  <span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_entries</span>;
}
</pre>
</div>
</li>
<li>Global Variables
There are no special requirements for global variables, which should
be rare in any case, but if you use one, consider prefixing it with
<code>g_</code> or some other marker to easily distinguish it from local
variables.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">Constant Names</h3>
<div class="outline-text-3" id="text-7-5">
<p class="info">
在名称前加 k: kDaysInAWeek.
</p>

<p>
All compile-time constants, whether they are declared locally, globally, or as part of a class, follow a slightly different naming convention from other variables. Use a k followed by words with uppercase first letters:
</p>

<p>
<code>const int kDaysInAWeek = 7;</code>
</p>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">Function Names</h3>
<div class="outline-text-3" id="text-7-6">
<p class="info">
常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction(), 
MyExcitingMethod(), my_exciting_member_variable(), 
set_my_exciting_member_variable()</code>
</p>

<ul class="org-ul">
<li>Regular Functions
Functions should start with a capital letter and have a capital
letter for each new word. No underscores. 

<p>
If your function crashes upon an error, you should append OrDie to
the function name. This only applies to functions which could be
used by production code and to errors that are reasonably likely to
occur during normal operation. 
</p>
<div class="org-src-container">

<pre class="src src-c">AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>
</div>
</li>

<li>Accessors and Mutators
Accessors and mutators (get and set functions) should match the name
of the variable they are getting and setting. This shows an excerpt
of a class whose instance variable is <code>num_entries_</code>. 
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MyClass</span> {
 <span style="color: #7fffd4;">public</span>:
  ...
  <span style="color: #98fb98;">int</span> num_entries() <span style="color: #00ffff;">const</span> { <span style="color: #00ffff;">return</span> num_entries_; }
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">set_num_entries</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_entries</span>) { num_entries_ = num_entries; }

 private:
  <span style="color: #98fb98;">int</span> num_entries_;
};
</pre>
</div>
<p>
You may also use lowercase letters for other very short inlined functions.
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7">Namespace Names</h3>
<div class="outline-text-3" id="text-7-7">
<p class="info">
名字空间用小写字母命名, 并基于项目名称和目录结构: <code>google_awesome_project</code>.
</p>
</div>
</div>
<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8">Enumerator Names</h3>
<div class="outline-text-3" id="text-7-8">
<p class="info">
枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 <code>ENUM_NAME</code>.
</p>

<p>
Preferably, the individual enumerators should be named like <b>constants</b>.
However, it is also acceptable to name them like macros. The
enumeration name, UrlTableErrors (and AlternateUrlTableErrors), is a
type, and therefore mixed case. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">UrlTableErrors</span> {
  <span style="color: #eedd82;">kOK</span> = 0,
  <span style="color: #98fb98;">kErrorOutOfMemory</span>,
  <span style="color: #98fb98;">kErrorMalformedInput</span>,
};
<span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">AlternateUrlTableErrors</span> {
  <span style="color: #eedd82;">OK</span> = 0,
  <span style="color: #eedd82;">OUT_OF_MEMORY</span> = 1,
  <span style="color: #eedd82;">MALFORMED_INPUT</span> = 2,
};
</pre>
</div>
<p>
Until January 2009, the style was to name enum values like macros.
This caused problems with name collisions between enum values and
macros. Hence, the change to prefer constant-style naming was put in
place. New code should prefer constant-style naming if possible.
</p>
</div>
</div>
<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9">Macro Names</h3>
<div class="outline-text-3" id="text-7-9">
<p class="info">
你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: 
<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.
</p>

<p>
Please see the description of macros; in general macros should not be
used. However, if they are absolutely needed, then they should be
named with all capitals and underscores. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">ROUND</span>(<span style="color: #eedd82;">x</span>) ...
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PI_ROUNDED</span> 3.0
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-10" class="outline-3">
<h3 id="sec-7-10">Exceptions to Naming Rules</h3>
<div class="outline-text-3" id="text-7-10">
<p class="info">
如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.
</p>

<ul class="org-ul">
<li>bigopen()
function name, follows form of open()
</li>
<li>uint
typedef
</li>
<li>bigpos
struct or class, follows form of pos
</li>
<li><code>sparse_hash_map</code>
  STL-like entity; follows STL naming conventions
</li>
<li><code>LONGLONG_MAX</code>
  a constant, as in <code>INT_MAX</code>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Comments</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Comment Style</h3>
<div class="outline-text-3" id="text-8-1">
<p class="info">
使用 // 或 /* */, 统一就好.
</p>
<p>
You can use either the <i>/ or the /* *</i> syntax; however, // is much
more common.
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">File Comments</h3>
<div class="outline-text-3" id="text-8-2">
<p class="info">
在每一个文件开头加入版权公告, 然后是文件内容描述.
</p>
<ul class="org-ul">
<li>Legal Notice and Author Line
Every file should contain license boilerplate. Choose the appropriate boilerplate for the license used by the project (for example, Apache 2.0, BSD, LGPL, GPL).

<p>
If you make significant changes to a file with an author line,
consider deleting the author line. 
</p>
</li>
<li>File Contents
Every file should have a comment at the top describing its contents.

<p>
Generally a .h file will describe the classes that are declared in the file with an overview of what they are for and how they are used. A .cc file should contain more information about implementation details or discussions of tricky algorithms. If you feel the implementation details or a discussion of the algorithms would be useful for someone reading the .h, feel free to put it there instead, but mention in the .cc that the documentation is in the .h file.
</p>

<p>
Do not duplicate comments in both the .h and the .cc.
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Class Comments</h3>
<div class="outline-text-3" id="text-8-3">
<p class="info">
每个类的定义都要附带一份注释, 描述类的功能和用法.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Iterates over the contents of a GargantuanTable.  Sample usage:</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">GargantuanTableIterator* iter = table-&gt;NewIterator();</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {</span>
<span style="color: #ff7f24;">//      </span><span style="color: #ff7f24;">process(iter-&gt;key(), iter-&gt;value());</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">}</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">delete iter;</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">GargantuanTableIterator</span> {
  ...
};
</pre>
</div>

<p>
If you have already described a class in detail in the comments at the top of your file feel free to simply state "See comment at top of file for a complete description", but be sure to have some sort of comment.
</p>

<p>
Document the synchronization assumptions the class makes, if any. If
an instance of the class can be accessed by multiple threads, take
extra care to document the rules and invariants surrounding
multithreaded use.
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Function Comments</h3>
<div class="outline-text-3" id="text-8-4">
<p class="info">
函数声明处注释描述函数功能; 定义处描述函数实现.
</p>

<ul class="org-ul">
<li>函数声明:
注释位于声明之前, 对函数功能及用法进行描述. 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.

<p>
函数声明处注释的内容:
</p>
<ul class="org-ul">
<li>函数的输入输出.
</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.
</li>
<li>如果函数分配了空间, 需要由调用者释放.
</li>
<li>参数是否可以为 NULL.
</li>
<li>是否存在函数使用上的性能隐患.
</li>
<li>如果函数是可重入的, 其同步前提是什么?
</li>
</ul>
<p>
举例如下:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Returns an iterator for this table.  It is the client's</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">responsibility to delete the iterator when it is done with it,</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and it must not use the iterator once the GargantuanTable object</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">on which the iterator was created has been deleted.</span>
<span style="color: #ff7f24;">//</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The iterator is initially positioned at the beginning of the table.</span>
<span style="color: #ff7f24;">//</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">This method is equivalent to:</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">Iterator* iter = table-&gt;NewIterator();</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">iter-&gt;Seek("");</span>
<span style="color: #ff7f24;">//    </span><span style="color: #ff7f24;">return iter;</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If you are going to immediately seek to another place in the</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">returned iterator, it will be faster to use NewIterator()</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and avoid the extra seek.</span>
Iterator* GetIterator() <span style="color: #00ffff;">const</span>;
</pre>
</div>
<p>
但也要避免罗罗嗦嗦, 或做些显而易见的说明. 下面的注释就没有必要加上 “returns false otherwise”, 因为已经暗含其中了:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Returns true if the table cannot hold any more entries.</span>
<span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">IsTableFull</span>();
</pre>
</div>
<p>
注释构造/析构函数时, 切记读代码的人知道构造/析构函数是干啥的, 所以“destroys this object” 这样的注释是没有意义的. 注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的. 
</p>
</li>
<li>函数定义:
每个函数定义时要用注释说明函数功能和实现要点. 比如说说你用的编程技巧,
实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要. 

<p>
不要 从 .h 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.
</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">Variable Comments</h3>
<div class="outline-text-3" id="text-8-5">
<p class="info">
通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.
</p>

<ul class="org-ul">
<li>Class Data Members
Each class data member (also called an instance variable or member
variable) should have a comment describing what it is used for. If
the variable can take sentinel values with special meanings, such as
a null pointer or -1, document this. For example: 
<div class="org-src-container">

<pre class="src src-c"><span style="color: #7fffd4;">private</span>:
 <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Keeps track of the total number of entries in the table.</span>
 <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Used to ensure we do not go over the limit. -1 means</span>
 <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">that we don't yet know how many entries the table has.</span>
 <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">num_total_entries_</span>;
</pre>
</div>
</li>
<li>Global Variables
As with data members, all global variables should have a comment describing what they are and what they are used for. For example:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The total number of tests cases that we run through in this regression test.</span>
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kNumTestCases</span> = 6;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6">Implementation Comments</h3>
<div class="outline-text-3" id="text-8-6">
<p class="info">
对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.
</p>

<ul class="org-ul">
<li>Class Data Members
Tricky or complicated code blocks should have comments before them. Example:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Divide result by two, taking into account that x</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">contains the carry from the add.</span>
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; result-&gt;size(); i++) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</pre>
</div>
</li>
<li>Line Comments
Also, lines that are non-obvious should get a comment at the end of the line. These end-of-line comments should be separated from the code by 2 spaces. Example:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">If we have enough memory, mmap the data portion too.</span>
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
<span style="color: #00ffff;">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  <span style="color: #00ffff;">return</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Error already logged.</span>
</pre>
</div>

<p>
Note that there are both comments that describe what the code is doing, and comments that mention that an error has already been logged when the function returns.
</p>

<p>
If you have several comments on subsequent lines, it can often be more readable to line them up:
</p>
<div class="org-src-container">

<pre class="src src-c">DoSomething();                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Comment here so the comments line up.</span>
DoSomethingElseThatIsLonger();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Comment here so there are two spaces between</span>
                                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the code and the comment.</span>
{ <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">One space before comment when opening a new scope is allowed,</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">thus the comment lines up with the following comments and code.</span>
  DoSomethingElse();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Two spaces before line comments normally.</span>
}
DoSomething(); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">For trailing block comments, one space is fine. </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
</li>
<li>nullptr/NULL, true/false, 1, 2, 3&#x2026;
When you pass in a null pointer, boolean, or literal integer values to functions, you should consider adding a comment about what they are, or make your code self-documenting by using constants. For example, compare:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">success</span> = CalculateSomething(interesting_value,
                                  10,
                                  <span style="color: #7fffd4;">false</span>,
                                  <span style="color: #7fffd4;">NULL</span>);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">What are these arguments??</span>
</pre>
</div>
<p>
versus:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">success</span> = CalculateSomething(interesting_value,
                                  10,     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Default base value.</span>
                                  <span style="color: #7fffd4;">false</span>,  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Not the first time we're calling this.</span>
                                  <span style="color: #7fffd4;">NULL</span>);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No callback.</span>
</pre>
</div>
<p>
Or alternatively, constants or self-describing variables:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">kDefaultBaseValue</span> = 10;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">kFirstTimeCalling</span> = <span style="color: #7fffd4;">false</span>;
<span style="color: #98fb98;">Callback</span> *<span style="color: #eedd82;">null_callback</span> = <span style="color: #7fffd4;">NULL</span>;
<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">success</span> = CalculateSomething(interesting_value,
                                  kDefaultBaseValue,
                                  kFirstTimeCalling,
                                  null_callback);
</pre>
</div>
</li>
<li>Don'ts
Note that you should never describe the code itself. Assume that the person reading the code knows C++ better than you do, even though he or she does not know what you are trying to do:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Now go through the b array and make sure that if i occurs,</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the next element is i+1.</span>
...        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Geez.  What a useless comment.</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7">Punctuation, Spelling and Grammar</h3>
<div class="outline-text-3" id="text-8-7">
<p class="info">
注意标点, 拼写和语法; 写的好的注释比差的要易读的多.
</p>
<p>
Comments should be as readable as narrative text, with proper
capitalization and punctuation. In many cases, complete sentences are
more readable than sentence fragments. Shorter comments, such as
comments at the end of a line of code, can sometimes be less formal,
but you should be consistent with your style.
</p>
</div>
</div>

<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="todo TODO">TODO</span> Comments</h3>
<div class="outline-text-3" id="text-8-8">
<p class="info">
对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.
</p>

<p>
TODOs should include the string TODO in all caps, followed by the
name, e-mail address, or other identifier of the person who can best
provide context about the problem referenced by the TODO. A colon is
optional. The main purpose is to have a consistent TODO format that
can be searched to find the person who can provide more details upon
request. A TODO is not a commitment that the person referenced will
fix the problem. Thus when you create a TODO, it is almost always your
name that is given. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">TODO(Zeke) change this to use relations.</span>
</pre>
</div>
<p>
If your TODO is of the form "At a future date do something" make sure
that you either include a very specific date ("Fix by November 2005")
or a very specific event ("Remove this code when all clients can
handle XML responses."). 
</p>
</div>
</div>

<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9">Deprecation Comments</h3>
<div class="outline-text-3" id="text-8-9">
<p class="info">
用DEPRECATED注释来标识废弃的接口。
</p>
<p>
You can mark an interface as deprecated by writing a comment containing the word DEPRECATED in all caps. The comment goes either before the declaration of the interface or on the same line as the declaration.
</p>

<p>
After the word DEPRECATED, write your name, e-mail address, or other identifier in parentheses.
</p>

<p>
A deprecation comment must include simple, clear directions for people
to fix their callsites. In C++, you can implement a deprecated
function as an inline function that calls the new interface point.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Formatting</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Line Length</h3>
<div class="outline-text-3" id="text-9-1">
<p class="info">
每一行代码字符数不超过 80.
</p>

<p>
80 characters is the maximum.
</p>

<ul class="org-ul">
<li>Exception: if a comment line contains an example command or a literal URL longer than 80 characters, that line may be longer than 80 characters for ease of cut and paste.
</li>
<li>Exception: an #include statement with a long path may exceed 80 columns. Try to avoid situations where this becomes necessary.
</li>
<li>Exception: you needn't be concerned about header guards that exceed the maximum length.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Non-ASCII Characters</h3>
<div class="outline-text-3" id="text-9-2">
<p class="info">
量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.
</p>

<p>
Hex encoding is also OK, and encouraged where it enhances readability — for example, "\xEF\xBB\xBF", or, even more simply, u8"\uFEFF", is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.
</p>

<p>
Use the u8 prefix to guarantee that a string literal containing \uXXXX escape sequences is encoded as UTF-8. Do not use it for strings containing non-ASCII characters encoded as UTF-8, because that will produce incorrect output if the compiler does not interpret the source file as UTF-8.
</p>

<p>
You shouldn't use the C++11 char16<sub>t</sub> and char32<sub>t</sub> character types,
since they're for non-UTF-8 text. For similar reasons you also
shouldn't use wchar<sub>t</sub> (unless you're writing code that interacts with
the Windows API, which uses wchar<sub>t</sub> extensively).
</p>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Spaces vs. Tabs</h3>
<div class="outline-text-3" id="text-9-3">
<p class="info">
只使用空格, 每次缩进 2 个空格.
</p>
<p>
We use spaces for indentation. Do not use tabs in your code. You
should set your editor to emit spaces when you hit the tab key.
</p>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">Function Declarations and Definitions</h3>
<div class="outline-text-3" id="text-9-4">
<p class="info">
返回类型和函数名在同一行, 参数也尽量放在同一行.
</p>

<p>
Functions look like this:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">ReturnType</span> <span style="color: #87cefa;">ClassName</span>::FunctionName(<span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name1</span>, <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name2</span>) {
  DoSomething();
  ...
}
</pre>
</div>
<p>
If you have too much text to fit on one line:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">ReturnType</span> <span style="color: #87cefa;">ClassName</span>::ReallyLongFunctionName(<span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name1</span>, <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name2</span>,
                                             <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name3</span>) {
  DoSomething();
  ...
}
</pre>
</div>
<p>
or if you cannot fit even the first parameter:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">ReturnType</span> <span style="color: #87cefa;">LongClassName</span>::ReallyReallyReallyLongFunctionName(
    <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name1</span>,  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 space indent</span>
    <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name2</span>,
    <span style="color: #98fb98;">Type</span> <span style="color: #eedd82;">par_name3</span>) {
  DoSomething();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent</span>
  ...
}
</pre>
</div>

<p>
注意以下几点:
</p>
<ul class="org-ul">
<li>如果不能使返回值和函数名在同一行，分开它们;
</li>
<li>如果返回值总是和函数名被分开，不要缩进;
</li>
<li>左圆括号总是和函数名在同一行;
</li>
<li>函数名和左圆括号间没有空格;
</li>
<li>圆括号与参数间没有空格;
</li>
<li>左大括号总在最后一个参数同一行的末尾处;
</li>
<li>右大括号总是单独位于函数最后一行;
</li>
<li>右圆括号和左大括号间总是有一个空格;
</li>
<li>函数声明和实现处的所有形参名称必须保持一致;
</li>
<li>所有形参应尽可能对齐;
</li>
<li>缺省缩进为 2 个空格;
</li>
<li>换行后的参数保持 4 个空格的缩进;
</li>
</ul>

<p>
If some parameters are unused, comment out the variable name in the function definition:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Always have named parameters in interfaces.</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">Shape</span> {
 <span style="color: #7fffd4;">public</span>:
  virtual <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Rotate</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radians</span>) = 0;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Always have named parameters in the declaration.</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">Circle</span> : public Shape {
 <span style="color: #7fffd4;">public</span>:
  virtual <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Rotate</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">radians</span>);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Comment out unused named parameters in definitions.</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Circle</span>::Rotate(<span style="color: #98fb98;">double</span> <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">radians</span><span style="color: #ff7f24;">*/</span>) {}
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bad - if someone wants to implement later, it's not clear what the</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">variable means.</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Circle</span>::Rotate(<span style="color: #98fb98;">double</span>) {}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">Function Calls</h3>
<div class="outline-text-3" id="text-9-5">
<p class="info">
尽量放在同一行, 否则, 将实参封装在圆括号中.
</p>

<p>
Function calls have the following format:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">retval</span> = DoSomething(argument1, argument2, argument3);
</pre>
</div>

<p>
If the arguments do not all fit on one line, they should be broken up onto multiple lines, with each subsequent line aligned with the first argument. Do not add spaces after the open paren or before the close paren:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">retval</span> = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>
</div>

<p>
If the function has many arguments, consider having one per line if this makes the code more readable:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">retval</span> = DoSomething(argument1,
                          argument2,
                          argument3,
                          argument4);
</pre>
</div>

<p>
Arguments may optionally all be placed on subsequent lines, with one line per argument:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (...) {
  ...
  ...
  <span style="color: #00ffff;">if</span> (...) {
    DoSomething(
        argument1,  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 space indent</span>
        argument2,
        argument3,
        argument4);
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6">Braced Initializer Lists</h3>
<div class="outline-text-3" id="text-9-6">
<p class="info">
如格式化函数调用一样格式化括号列单。
</p>

<p>
If the braced list follows a name (e.g. a type or variable name), format as if the {} were the parentheses of a function call with that name. If there is no name, assume a zero-length name.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Examples of braced init list on a single line.</span>
<span style="color: #00ffff;">return</span> {foo, bar};
functioncall({foo, bar});
pair&lt;<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">int</span>&gt; p{foo, bar};

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">When you have to wrap.</span>
SomeFunction(
    {<span style="color: #ffa07a;">"assume a zero-length name before {"</span>},
    some_other_function_parameter);
<span style="color: #98fb98;">SomeType</span> <span style="color: #eedd82;">variable</span>{
    some, other, values,
    {<span style="color: #ffa07a;">"assume a zero-length name before {"</span>},
    SomeOtherType{
        <span style="color: #ffa07a;">"Very long string requiring the surrounding breaks."</span>,
        some, <span style="color: #98fb98;">other</span> <span style="color: #eedd82;">values</span>},
    SomeOtherType{<span style="color: #ffa07a;">"Slightly shorter string"</span>,
                  some, other, values}};
<span style="color: #98fb98;">SomeType</span> <span style="color: #eedd82;">variable</span>{
    <span style="color: #ffa07a;">"This is too long to fit all in one line"</span>};
<span style="color: #98fb98;">MyType</span> <span style="color: #eedd82;">m</span> = {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Here, you could also break before {.</span>
    superlongvariablename1,
    superlongvariablename2,
    {<span style="color: #98fb98;">short</span>, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-7" class="outline-3">
<h3 id="sec-9-7">Conditionals</h3>
<div class="outline-text-3" id="text-9-7">
<p class="info">
倾向于不在圆括号内使用空格. 关键字 else 另起一行.
</p>

<p>
There are two acceptable formats for a basic conditional statement. One includes spaces between the parentheses and the condition, and one does not.
</p>

<p>
The most common form is without spaces. Either is fine, but be consistent. If you are modifying a file, use the format that is already present. If you are writing new code, use the format that the other files in that directory or project use. If in doubt and you have no personal preference, do not add the spaces.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (condition) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">no spaces inside parentheses</span>
  ...  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent.</span>
} <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (...) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The else goes on the same line as the closing brace.</span>
  ...
} <span style="color: #00ffff;">else</span> {
  ...
}
</pre>
</div>

<p>
If you prefer you may add spaces inside the parentheses:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> ( condition ) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">spaces inside parentheses - rare</span>
  ...  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent.</span>
} <span style="color: #00ffff;">else</span> {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The else goes on the same line as the closing brace.</span>
  ...
}
</pre>
</div>
<p>
Note that in all cases you must have a space between the if and the open parenthesis. You must also have a space between the close parenthesis and the curly brace, if you're using one.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span>(condition)     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bad - space missing after IF.</span>
<span style="color: #00ffff;">if</span> (condition){   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bad - space missing before {.</span>
<span style="color: #00ffff;">if</span>(condition){    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Doubly bad.</span>
<span style="color: #00ffff;">if</span> (condition) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Good - proper space after IF and before {.</span>
</pre>
</div>
<p>
Short conditional statements may be written on one line if this enhances readability. You may use this only when the line is brief and the statement does not use the else clause.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (x == kFoo) <span style="color: #00ffff;">return</span> new Foo();
<span style="color: #00ffff;">if</span> (x == kBar) <span style="color: #00ffff;">return</span> new Bar();
</pre>
</div>
<p>
This is not allowed when the if statement has an else:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Not allowed - IF statement on one line when there is an ELSE clause</span>
<span style="color: #00ffff;">if</span> (x) DoThis();
<span style="color: #00ffff;">else</span> DoThat();
</pre>
</div>
<p>
In general, curly braces are not required for single-line statements, but they are allowed if you like them; conditional or loop statements with complex conditions or statements may be more readable with curly braces. Some projects require that an if must always always have an accompanying brace.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (condition)
  DoSomething();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent.</span>

<span style="color: #00ffff;">if</span> (condition) {
  DoSomething();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent.</span>
}
</pre>
</div>
<p>
However, if one part of an if-else statement uses curly braces, the other part must too:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Not allowed - curly on IF but not ELSE</span>
<span style="color: #00ffff;">if</span> (condition) {
  foo;
} <span style="color: #00ffff;">else</span>
  bar;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Not allowed - curly on ELSE but not IF</span>
<span style="color: #00ffff;">if</span> (condition)
  foo;
<span style="color: #00ffff;">else</span> {
  bar;
}
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Curly braces around both IF and ELSE required because</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">one of the clauses used braces.</span>
<span style="color: #00ffff;">if</span> (condition) {
  foo;
} <span style="color: #00ffff;">else</span> {
  bar;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-8" class="outline-3">
<h3 id="sec-9-8">Loops and Switch Statements</h3>
<div class="outline-text-3" id="text-9-8">
<p class="info">
switch 语句可以使用大括号分段. 空循环体应使用 {} 或 continue.
</p>

<p>
case blocks in switch statements can have curly braces or not, depending on your preference. If you do include curly braces they should be placed as shown below.
</p>

<p>
If not conditional on an enumerated value, switch statements should always have a default case (in the case of an enumerated value, the compiler will warn you if any values are not handled). If the default case should never execute, simply assert:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">switch</span> (var) {
  <span style="color: #00ffff;">case</span> 0: {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2 space indent</span>
    ...      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 space indent</span>
    <span style="color: #00ffff;">break</span>;
  }
  <span style="color: #00ffff;">case</span> 1: {
    ...
    <span style="color: #00ffff;">break</span>;
  }
  <span style="color: #00ffff;">default</span>: {
    assert(<span style="color: #7fffd4;">false</span>);
  }
}
</pre>
</div>
<p>
Empty loop bodies should use {} or continue, but not a single semicolon.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">while</span> (condition) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Repeat test until it returns false.</span>
}
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; kSomeNumber; ++i) {}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Good - empty body.</span>
<span style="color: #00ffff;">while</span> (condition) <span style="color: #00ffff;">continue</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Good - continue indicates no logic.</span>
<span style="color: #00ffff;">while</span> (condition);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bad - looks like part of do/while loop.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-9" class="outline-3">
<h3 id="sec-9-9">Pointer and Reference Expressions</h3>
<div class="outline-text-3" id="text-9-9">
<p class="info">
句点或箭头前后不要有空格. 指针/地址操作符 (*, &) 之后不能有空格.
</p>

<p>
Note that:
</p>
<ul class="org-ul">
<li>There are no spaces around the period or arrow when accessing a member.
</li>
<li>Pointer operators have no space after the * or &amp;.
</li>
</ul>
<p>
When declaring a pointer variable or argument, you may place the
asterisk adjacent to either the type or to the variable name 
</p>
</div>
</div>
<div id="outline-container-sec-9-10" class="outline-3">
<h3 id="sec-9-10">Boolean Expressions</h3>
<div class="outline-text-3" id="text-9-10">
<p class="info">
如果一个布尔表达式超过 标准行宽, 断行方式要统一一下.
</p>
<p>
In this example, the logical AND operator is always at the end of the lines:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>
</div>

<p>
Note that when the code wraps in this example, both of the &amp;&amp; logical
AND operators are at the end of the line. This is more common in
Google code, though wrapping all operators at the beginning of the
line is also allowed. Feel free to insert extra parentheses
judiciously because they can be very helpful in increasing readability
when used appropriately.
</p>
</div>
</div>
<div id="outline-container-sec-9-11" class="outline-3">
<h3 id="sec-9-11">Return Values</h3>
<div class="outline-text-3" id="text-9-11">
<p class="info">
return 表达式中不要用圆括号包围.
</p>

<p>
Use parentheses in return expr; only where you would use them in x = expr;.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">return</span> result;                  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No parentheses in the simple case.</span>
<span style="color: #00ffff;">return</span> (some_long_condition &amp;&amp;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Parentheses ok to make a complex</span>
        another_condition);     <span style="color: #ff7f24;">//     </span><span style="color: #ff7f24;">expression more readable.</span>
<span style="color: #00ffff;">return</span> (value);                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">You wouldn't write var = (value);</span>
<span style="color: #00ffff;">return</span>(result);                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">return is not a function!</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-12" class="outline-3">
<h3 id="sec-9-12">Variable and Array Initialization</h3>
<div class="outline-text-3" id="text-9-12">
<p class="info">
用 =, ()或{} 均可.
</p>

<p>
You may choose between =, (), and {}; the following are all correct:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 3;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">x</span>(3);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>{3};
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span> = <span style="color: #ffa07a;">"Some Name"</span>;
<span style="color: #98fb98;">string</span> <span style="color: #87cefa;">name</span>(<span style="color: #ffa07a;">"Some Name"</span>);
<span style="color: #98fb98;">string</span> <span style="color: #eedd82;">name</span>{<span style="color: #ffa07a;">"Some Name"</span>};
</pre>
</div>
<p>
Be careful when using the {} on a type that takes an initializer<sub>list</sub>
in one of its constructors. The {} syntax prefers the initializer<sub>list</sub>
constructor whenever possible. To get the non- initializer<sub>list</sub>
constructor, use (). 
</p>
<div class="org-src-container">

<pre class="src src-c">vector&lt;<span style="color: #98fb98;">int</span>&gt; v(100, 1);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A vector of 100 1s.</span>
vector&lt;<span style="color: #98fb98;">int</span>&gt; v{100, 1};  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A vector of 100, 1.</span>
</pre>
</div>
<p>
Also, the brace form prevents narrowing of integral types. This can
prevent some types of programming errors. 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">pi</span>(3.14);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK -- pi == 3.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">pi</span>{3.14};  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Compile error: narrowing conversion.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-13" class="outline-3">
<h3 id="sec-9-13">Preprocessor Directives</h3>
<div class="outline-text-3" id="text-9-13">
<p class="info">
预处理指令不要缩进, 从行首开始.
</p>
<p>
Even when preprocessor directives are within the body of indented code, the directives should start at the beginning of the line.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Good - directives at beginning of line</span>
  <span style="color: #00ffff;">if</span> (lopsided_score) {
<span style="color: #b0c4de;">#if</span> DISASTER_PENDING      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Correct -- Starts at beginning of line</span>
    DropEverything();
<span style="color: #b0c4de;"># if</span> NOTIFY               <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">OK but not required -- Spaces after #</span>
    NotifyClient();
<span style="color: #b0c4de;"># endif</span>
<span style="color: #b0c4de;">#endif</span>
    BackToNormal();
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-14" class="outline-3">
<h3 id="sec-9-14">Class Format</h3>
<div class="outline-text-3" id="text-9-14">
<p class="info">
访问控制块的声明依次序是 public:, protected:, private:, 每次缩进 1 个
空格. 
</p>

<p>
The basic format for a class declaration (lacking the comments, see
Class Comments for a discussion of what comments are needed) is: 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">class</span> <span style="color: #eedd82;">MyClass</span> : public OtherClass {
 <span style="color: #7fffd4;">public</span>:      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Note the 1 space indent!</span>
  MyClass();  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Regular 2 space indent.</span>
  <span style="color: #98fb98;">explicit</span> <span style="color: #eedd82;">MyClass</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>);
  ~MyClass() {}

  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">SomeFunction</span>();
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">SomeFunctionThatDoesNothing</span>() {
  }

  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">set_some_var</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>) { some_var_ = var; }
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">some_var</span>() <span style="color: #00ffff;">const</span> { <span style="color: #00ffff;">return</span> some_var_; }

 private:
  bool SomeInternalFunction();

  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">some_var_</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">some_other_var_</span>;
  DISALLOW_COPY_AND_ASSIGN(MyClass);
};
</pre>
</div>
<p>
Things to note:
</p>

<ul class="org-ul">
<li>Any base class name should be on the same line as the subclass name, subject to the 80-column limit.
</li>
<li>The public:, protected:, and private: keywords should be indented one space.
</li>
<li>Except for the first instance, these keywords should be preceded by a blank line. This rule is optional in small classes.
</li>
<li>Do not leave a blank line after these keywords.
</li>
<li>The public section should be first, followed by the protected and finally the private section.
</li>
<li>See Declaration Order for rules on ordering declarations within each of these sections.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-15" class="outline-3">
<h3 id="sec-9-15">Constructor Initializer Lists</h3>
<div class="outline-text-3" id="text-9-15">
<p class="info">
构造函数初始化列表放在同一行或按四格缩进并排几行.
</p>

<p>
There are two acceptable formats for initializer lists:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">When it all fits on one line:</span>
MyClass::MyClass(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>) : some_var_(var), some_other_var_(var + 1) {}
</pre>
</div>

<p>
or
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">When it requires multiple lines, indent 4 spaces, putting the colon on</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the first initializer line:</span>
MyClass::MyClass(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">var</span>)
    : some_var_(var),             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 space indent</span>
      some_other_var_(var + 1) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">lined up</span>
  ...
  DoSomething();
  ...
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-16" class="outline-3">
<h3 id="sec-9-16">Namespace Formatting</h3>
<div class="outline-text-3" id="text-9-16">
<p class="info">
名字空间内容不缩进.
</p>

<p>
Namespaces do not add an extra level of indentation. For example, use:
</p>
<div class="org-src-container">

<pre class="src src-c">namespace {

<span style="color: #98fb98;">void</span> <span style="color: #eedd82;">foo</span>() {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Correct.  No extra indentation within namespace.</span>
  ...
}

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace</span>
</pre>
</div>
<p>
Do not indent within a namespace:
</p>
<div class="org-src-container">

<pre class="src src-c">namespace {

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Wrong.  Indented when it should not be.</span>
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">foo</span>() {
    ...
  }

}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">namespace</span>
</pre>
</div>
<p>
When declaring nested namespaces, put each namespace on its own line.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">foo</span> {
<span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">bar</span> {
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9-17" class="outline-3">
<h3 id="sec-9-17">Horizontal Whitespace</h3>
<div class="outline-text-3" id="text-9-17">
<p class="info">
水平留白的使用因地制宜. 永远不要在行尾添加没意义的留白
</p>
</div>

<ul class="org-ul"><li><a id="sec-9-17-1" name="sec-9-17-1"></a>General<br  /><div class="outline-text-4" id="text-9-17-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">b</span>) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Open braces should always have a space before them.</span>
  ...
<span style="color: #98fb98;">int</span> i = 0;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Semicolons usually have no space before them.</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>[] = { 0 };  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Spaces inside braces for braced-init-list are</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>[] = {0};    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">optional.  If you use them, put them on both sides!</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Spaces around the colon in inheritance and initializer lists.</span>
<span style="color: #98fb98;">class</span> <span style="color: #eedd82;">Foo</span> : public Bar {
 <span style="color: #7fffd4;">public</span>:
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For inline function implementations, put spaces between the braces</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">and the implementation itself.</span>
  Foo(<span style="color: #98fb98;">int</span> <span style="color: #7fffd4;">b</span>) : Bar(), baz_(b) {}  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No spaces inside empty braces.</span>
  <span style="color: #98fb98;">void</span> <span style="color: #eedd82;">Reset</span>() { baz_ = 0; }  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Spaces separating braces from implementation.</span>
  ...
</pre>
</div>

<p>
Adding trailing whitespace can cause extra work for others editing the
same file, when they merge, as can removing existing trailing
whitespace. So: Don't introduce trailing whitespace. Remove it if
you're already changing that line, or do it in a separate clean-up
operation (preferably when no-one else is working on the file). 
</p>
</div>
</li>

<li><a id="sec-9-17-2" name="sec-9-17-2"></a>Loops and Conditionals<br  /><div class="outline-text-4" id="text-9-17-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> (b) {          <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Space after the keyword in conditions and loops.</span>
} <span style="color: #00ffff;">else</span> {          <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Spaces around else.</span>
}
<span style="color: #00ffff;">while</span> (test) {}   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">There is usually no space inside parentheses.</span>
<span style="color: #00ffff;">switch</span> (i) {
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 5; ++i) {
<span style="color: #00ffff;">switch</span> ( i ) {    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Loops and conditions may have spaces inside</span>
<span style="color: #00ffff;">if</span> ( test ) {     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">parentheses, but this is rare.  Be consistent.</span>
<span style="color: #00ffff;">for</span> ( <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; 5; ++i ) {
<span style="color: #00ffff;">for</span> ( ; i &lt; 5 ; ++i) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For loops always have a space after the</span>
  ...                   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">semicolon, and may have a space before the</span>
                        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">semicolon.</span>
<span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">auto</span> <span style="color: #98fb98;">x</span> : counts) {  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Range-based for loops always have a</span>
  ...                    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">space before and after the colon.</span>
}
<span style="color: #00ffff;">switch</span> (i) {
  <span style="color: #00ffff;">case</span> 1:         <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No space before colon in a switch case.</span>
    ...
  <span style="color: #00ffff;">case</span> 2: <span style="color: #00ffff;">break</span>;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Use a space after a colon if there's code after it.</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-9-17-3" name="sec-9-17-3"></a>Operators<br  /><div class="outline-text-4" id="text-9-17-3">
<div class="org-src-container">

<pre class="src src-c">x = 0;              <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Assignment operators always have spaces around</span>
                    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">them.</span>
x = -5;             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No spaces separating unary operators and their</span>
++x;                <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">arguments.</span>
<span style="color: #00ffff;">if</span> (x &amp;&amp; !y)
  ...
v = w * x + y / z;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Binary operators usually have spaces around them,</span>
v = w*x + y/z;      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">but it's okay to remove spaces around factors.</span>
v = w * (x + z);    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Parentheses should have no spaces inside them.</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-9-17-4" name="sec-9-17-4"></a>Templates and Casts<br  /><div class="outline-text-4" id="text-9-17-4">
<div class="org-src-container">

<pre class="src src-c">vector&lt;string&gt; x;           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">No spaces inside the angle</span>
y = static_cast&lt;<span style="color: #98fb98;">char</span>*&gt;(x);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">brackets (&lt; and &gt;), before</span>
                            <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&lt;, or between &gt;( in a cast.</span>
vector&lt;<span style="color: #98fb98;">char</span> *&gt; x;           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Spaces between type and pointer are</span>
                            <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">okay, but be consistent.</span>
set&lt;list&lt;string&gt;&gt; x;        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Permitted in C++11 code.</span>
set&lt;list&lt;string&gt; &gt; x;       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">C++03 required a space in &gt; &gt;.</span>
set&lt; list&lt;string&gt; &gt; x;      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">You may optionally use</span>
                            <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">symmetric spacing in &lt; &lt;.</span>
</pre>
</div>
</div>
</li></ul>
</div>
<div id="outline-container-sec-9-18" class="outline-3">
<h3 id="sec-9-18">Vertical Whitespace</h3>
<div class="outline-text-3" id="text-9-18">
<p class="info">
垂直留白越少越好.
</p>

<p>
This is more a principle than a rule: don't use blank lines when you
don't have to. In particular, don't put more than one or two blank
lines between functions, resist starting functions with a blank line,
don't end functions with a blank line, and be discriminating with your
use of blank lines inside functions.
</p>

<p>
The basic principle is: The more code that fits on one screen, the easier it is to follow and understand the control flow of the program. Of course, readability can suffer from code being too dense as well as too spread out, so use your judgement. But in general, minimize use of vertical whitespace.
</p>

<p>
Some rules of thumb to help when blank lines may be useful:
</p>
<ul class="org-ul">
<li>Blank lines at the beginning or end of a function very rarely help readability.
</li>
<li>Blank lines inside a chain of if-else blocks may well help readability.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Exceptions to the Rules</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Existing Non-conformant Code</h3>
<div class="outline-text-3" id="text-10-1">
<p>
#+begin<sub>html</sub>
&lt;p class="info"&gt;
对于现有不符合既定编程风格的代码可以网开一面.
&lt;/p&gt;
#+end<sub>html</sub>.
当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心可以与代码原作者或现在的负责人员商讨, 记住, 一致性包括原有的一致性.
</p>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">Windows Code</h3>
<div class="outline-text-3" id="text-10-2">
<p class="info">
Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它
Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台
的 C++ 编程只给出一个单独的指南.
</p>

<p>
如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:
</p>

<ul class="org-ul">
<li>不要使用匈牙利命名法 (比如把整型变量命名成 iNum). 使用 Google 命名约定, 包括对源文件使用 .cc 扩展名.
</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 DWORD, HANDLE 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 但还是尽量使用原有的 C++ 类型, 例如, 使用 const TCHAR * 而不是 LPCTSTR.
</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有 warnings 当作 errors 处理.
</li>
<li>不要使用 #pragma once; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (yospaly 注: 如 #ifndef SRC<sub>DIR</sub><sub>BAR</sub><sub>H</sub>_, 参考 #define 保护 一节).
</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 #pragma 和 _<sub>declspec</sub>. 允许使用 _<sub>declspec</sub>(dllimport) 和 _<sub>declspec</sub>(dllexport); 但你必须通过宏来使用, 比如 DLLIMPORT 和 DLLEXPORT, 这样其他人在分享使用这些代码时很容易就去掉这些扩展.
</li>
</ul>
<p>
在 Windows 上, 只有很少的一些情况下, 我们可以偶尔违反规则:
</p>

<ul class="org-ul">
<li>通常我们 禁止使用多重继承, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.
</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 _ATL<sub>NO</sub><sub>EXCEPTIONS</sub> 以禁用异常. 你要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 启用编译器异常也可以. (注意这只是为了编译 STL, 自己代码里仍然不要含异常处理.)
</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 StdAfx.h 或 precompile.h 的文件. 为了使代码方便与其他项目共享, 避免显式包含此文件 (precompile.cc), 使用 /FI 编译器选项以自动包含.
</li>
<li>资源头文件通常命名为 resource.h, 且只包含宏的, 不需要遵守本风格指南.
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2017-01-26 Thu 20:46</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
