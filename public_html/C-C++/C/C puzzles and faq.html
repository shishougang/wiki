<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C puzzles and FAQ</title>
<!-- 2015-03-05 Thu 23:21 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>

<script type="text/javascript" src="assets/js/org-info.js">
/**
 *
 * @source: assets/js/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in assets/js/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in assets/js/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "#dddddd");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C puzzles and FAQ</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">read() and write() truncate buffer length</a></li>
<li><a href="#sec-2">在宏定义中使用 do&#x2026;while</a>
<ul>
<li><a href="#sec-2-1">do&#x2026;while(0)消除goto语句</a></li>
</ul>
</li>
<li><a href="#sec-3">Swap</a></li>
<li><a href="#sec-4">指针数组和数组指针</a></li>
<li><a href="#sec-5">pointer</a></li>
<li><a href="#sec-6">the sizes of the standard types aren't precisely defined</a></li>
<li><a href="#sec-7">donot use gets()</a>
<ul>
<li><a href="#sec-7-1">Example 1</a></li>
</ul>
</li>
<li><a href="#sec-8">strings are represented as null-terminated arrays</a>
<ul>
<li><a href="#sec-8-1">Example 1</a></li>
</ul>
</li>
<li><a href="#sec-9">What is the significance of the keyword “volatile” in C?</a></li>
<li><a href="#sec-10">Scope rules in C</a></li>
<li><a href="#sec-11">What are the default values of static variables in C?</a></li>
<li><a href="#sec-12">Scansets in C</a>
<ul>
<li><a href="#sec-12-1">store only capital letters to character array ‘str’</a></li>
<li><a href="#sec-12-2">stop reading</a></li>
</ul>
</li>
<li><a href="#sec-13">What is use of %n in printf() ?</a></li>
<li><a href="#sec-14">Precedence of postfix <del>+ and prefix +</del> in C/C++</a></li>
<li><a href="#sec-15">Modulus on Negative Numbers</a></li>
<li><a href="#sec-16">Variable length arguments for Macros</a></li>
<li><a href="#sec-17">CRASH() macro – interpretation</a></li>
<li><a href="#sec-18">The OFFSETOF() macro</a></li>
<li><a href="#sec-19">Are array members deeply copied?</a></li>
<li><a href="#sec-20">Functions that are executed before and after main() in C</a></li>
<li><a href="#sec-21">How to Count Variable Numbers of Arguments in C?</a></li>
<li><a href="#sec-22">exit(), abort()</a>
<ul>
<li><a href="#sec-22-1">exit()</a></li>
<li><a href="#sec-22-2">abort()</a></li>
</ul>
</li>
<li><a href="#sec-23">Struct Hack</a></li>
<li><a href="#sec-24">fseek() vs rewind() in C</a></li>
<li><a href="#sec-25">EOF, getc() and feof() in C</a></li>
<li><a href="#sec-26">Implement Your Own sizeof</a></li>
<li><a href="#sec-27">Complicated declarations in C</a></li>
<li><a href="#sec-28">How Linkers Resolve Multiply Defined Global Symbols?</a></li>
<li><a href="#sec-29">Use of bool in C</a></li>
<li><a href="#sec-30">Little and Big Endian Mystery</a>
<ul>
<li><a href="#sec-30-1">Is there a quick way to determine endianness of your machine?</a></li>
<li><a href="#sec-30-2">Does endianness matter for programmers?</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">read() and write() truncate buffer length</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="https://bugzilla.redhat.com/show_bug.cgi?id=612839">https://bugzilla.redhat.com/show_bug.cgi?id=612839</a>
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">在宏定义中使用 do&#x2026;while<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">do&#x2026;while(0)消除goto语句</h3>
<div class="outline-text-3" id="text-2-1">
<p>
通常，如果在一个函数中开始要分配一些资源，然后在中途执行过程中如果遇到错误则退出函数，当然，退出前先释放资源，我们的代码可能是这样：
</p>
</div>

<ul class="org-ul"><li><a id="sec-2-1-1" name="sec-2-1-1"></a>version 1<br  /><div class="outline-text-4" id="text-2-1-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">Execute</span>()
{
   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20998;&#37197;&#36164;&#28304;</span>
   <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p</span> = new <span style="color: #98fb98;">int</span>;
   <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">bOk</span>(<span style="color: #7fffd4;">true</span>);

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892;&#24182;&#36827;&#34892;&#38169;&#35823;&#22788;&#29702;</span>
   bOk = func1();
   <span style="color: #00ffff;">if</span>(!bOk) 
   {
      <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
      p = <span style="color: #7fffd4;">NULL</span>;
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
   }

   bOk = func2();
   <span style="color: #00ffff;">if</span>(!bOk) 
   {
      <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
      p = <span style="color: #7fffd4;">NULL</span>;
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
   }

   bOk = func3();
   <span style="color: #00ffff;">if</span>(!bOk) 
   {
      <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
      p = <span style="color: #7fffd4;">NULL</span>;
      <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;
   }

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">..........</span>

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892;&#25104;&#21151;&#65292;&#37322;&#25918;&#36164;&#28304;&#24182;&#36820;&#22238;</span>
    <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
    p = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

}
</pre>
</div>
<p>
这里一个最大的问题就是代码的冗余，而且我每增加一个操作，就需要做相应的错误处理，非常不灵活。于是我们想到了goto:
</p>
</div>
</li>

<li><a id="sec-2-1-2" name="sec-2-1-2"></a>version 2<br  /><div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">Execute</span>()
{
   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20998;&#37197;&#36164;&#28304;</span>
   <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p</span> = new <span style="color: #98fb98;">int</span>;
   <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">bOk</span>(<span style="color: #7fffd4;">true</span>);

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892;&#24182;&#36827;&#34892;&#38169;&#35823;&#22788;&#29702;</span>
   bOk = func1();
   <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">errorhandle</span>;

   bOk = func2();
   <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">errorhandle</span>;

   bOk = func3();
   <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">errorhandle</span>;

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">..........</span>

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892;&#25104;&#21151;&#65292;&#37322;&#25918;&#36164;&#28304;&#24182;&#36820;&#22238;</span>
    <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
    p = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">true</span>;

<span style="color: #7fffd4;">errorhandle</span>:
    <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
    p = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">false</span>;

}
</pre>
</div>
<p>
代码冗余是消除了，但是我们引入了C++中身份比较微妙的goto语句，虽然正确的使用goto可以大大提高程序的灵活性与简洁性，但太灵 活的东西往往是很危险的，它会让我们的程序捉摸不定，那么怎么才能避免使用goto语句，又能消除代码冗余呢，请看do&#x2026;while(0)循环：
</p>
</div>
</li>

<li><a id="sec-2-1-3" name="sec-2-1-3"></a>version 3<br  /><div class="outline-text-4" id="text-2-1-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">bool</span> <span style="color: #87cefa;">Execute</span>()
{
   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20998;&#37197;&#36164;&#28304;</span>
   <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">p</span> = new <span style="color: #98fb98;">int</span>;

   <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">bOk</span>(<span style="color: #7fffd4;">true</span>);
   <span style="color: #00ffff;">do</span>
   {
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892;&#24182;&#36827;&#34892;&#38169;&#35823;&#22788;&#29702;</span>
      bOk = func1();
      <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">break</span>;

      bOk = func2();
      <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">break</span>;

      bOk = func3();
      <span style="color: #00ffff;">if</span>(!bOk) <span style="color: #00ffff;">break</span>;

      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">..........</span>

   }<span style="color: #00ffff;">while</span>(0);

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#37322;&#25918;&#36164;&#28304;</span>
    <span style="color: #98fb98;">delete</span> <span style="color: #eedd82;">p</span>;   
    p = <span style="color: #7fffd4;">NULL</span>;
    <span style="color: #00ffff;">return</span> bOk;

}
</pre>
</div>
</div>
</li></ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Swap</h2>
<div class="outline-text-2" id="text-3">
<p>
<b>swap1</b>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap1</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q1</span>,<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q2</span>)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">temp</span>;
  temp = *q1;
  *q1 = *q2;
  *q2 = temp;
}
</pre>
</div>
<p>
<b>swap2</b>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">swap2</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q1</span>, <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q2</span>)
{
  <span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">temp</span>;
  temp = q1;
  q1 = q2;
  q2 = temp;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">指针数组和数组指针</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>int *p[2];</code> 首先声明了一个数组，数组的元素是int型的指针。用于存储指针的数组
</p>

<p>
<code>int (*p)[2];</code> 声明了一个指针， 指向了一个有两个int元素的数组。指向数组的指针
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span>* <span style="color: #98fb98;">intPtr</span>;
<span style="color: #98fb98;">intPtr</span> <span style="color: #eedd82;">p</span>[2];

<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">int</span> <span style="color: #98fb98;">intArray</span>[2];
<span style="color: #98fb98;">intArray</span> *<span style="color: #eedd82;">p</span>;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#23450;&#20041;&#20108;&#32500;&#25968;&#32452;m&#24182;&#21021;&#22987;&#21270;</span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">p</span>)[4];<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">&#25351;&#21521;&#25968;&#32452;&#30340;&#25351;&#38024;  p&#26159;&#25351;&#38024;&#65292;&#25351;&#21521;&#19968;&#32500;&#25968;&#32452;,&#27599;&#20010;&#19968;&#32500;&#25968;&#32452;&#26377;4&#20010;int&#20803;&#32032;</span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">q</span>[3];<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">&#29992;&#20110;&#23384;&#20648;&#25351;&#38024;&#30340;&#25968;&#32452; q&#26159;&#25968;&#32452;&#65292;&#25968;&#32452;&#20803;&#32032;&#26159;&#25351;&#38024;&#65292;3&#20010;int&#25351;&#38024;</span><span style="color: #ff7f24;">*/</span>

p=m;    <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">p&#26159;&#25351;&#38024;&#65292;&#21487;&#20197;&#30452;&#25509;&#25351;&#21521;&#20108;&#32500;&#25968;&#32452;</span>

<span style="color: #00ffff;">for</span>(i=0;i&lt;3;i++)
  q[i]=m[i];<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">q&#26159;&#25968;&#32452;&#65292;&#20803;&#32032;q[i]&#26159;&#25351;&#38024;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">pointer</h2>
<div class="outline-text-2" id="text-5">
<p>
<a href="http://see.xidian.edu.cn/cpp/html/476.html">http://see.xidian.edu.cn/cpp/html/476.html</a>
<a href="http://see.xidian.edu.cn/cpp/html/477.html">http://see.xidian.edu.cn/cpp/html/477.html</a>
<a href="http://abruzzi.iteye.com/blog/416199">http://abruzzi.iteye.com/blog/416199</a>
<a href="http://topic.csdn.net/u/20080710/15/01ca0f15-4403-45c1-91a8-a0326ceed700.html">http://topic.csdn.net/u/20080710/15/01ca0f15-4403-45c1-91a8-a0326ceed700.html</a>
<a href="http://blog.csdn.net/qq515383106/article/details/7370241">http://blog.csdn.net/qq515383106/article/details/7370241</a>
<a href="http://blog.csdn.net/dtmine/article/details/7366750">http://blog.csdn.net/dtmine/article/details/7366750</a>
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">the sizes of the standard types aren't precisely defined</h2>
<div class="outline-text-2" id="text-6">
<p>
Though C is considered relatively low-level as high-level languages
go, it does take the position that the exact size of an object (i.e.
in bits) is an implementation detail. Type int is supposed to
represent a machine's natural word size. 
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">donot use gets()</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Example 1</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">char</span> <span style="color: #eedd82;">buf</span>[256];
gets(buf);
</pre>
</div>
<p>
One should never use gets, since there is no way to limit the amount of input it will
read. This leads to security problems(get the root priviledge). 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">strings are represented as null-terminated arrays<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h2>
<div class="outline-text-2" id="text-8">
<p>
It makes some confusing problems.
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Example 1</h3>
<div class="outline-text-3" id="text-8-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span>, <span style="color: #eedd82;">buf</span>[256];
p = malloc(strlen(buf)+1);
strcpy(p, buf);
</pre>
</div>
<p>
<code>strlen</code> does not count the '\0' that terminates a string, while
<code>strcpy</code> copies it. So not enough space is allocated, and <code>strcpy</code> writes
past the end of the allocated space.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">What is the significance of the keyword “volatile” in C?</h2>
<div class="outline-text-2" id="text-9">
<p>
SOLUTION
Volatile informs the compiler that the value of the variable can
change from the outside, without any update done by the code.
Declaring a simple volatile variable:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span>;
<span style="color: #98fb98;">int</span> <span style="color: #00ffff;">volatile</span> <span style="color: #eedd82;">x</span>;
</pre>
</div>
<p>
Declaring a pointer variable for a volatile memory (only the pointer
address is volatile):
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> * <span style="color: #eedd82;">x</span>;
<span style="color: #98fb98;">int</span> <span style="color: #00ffff;">volatile</span> * <span style="color: #eedd82;">x</span>;
</pre>
</div>
<p>
Declaring a volatile pointer variable for a non-volatile memory (only
memory contained is volatile):
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> * <span style="color: #00ffff;">volatile</span> <span style="color: #eedd82;">x</span>;
</pre>
</div>
<p>
Declaring a volatile variable pointer for a volatile memory (both
pointer address and memory contained are volatile):
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">volatile</span> <span style="color: #98fb98;">int</span> * <span style="color: #00ffff;">volatile</span> <span style="color: #eedd82;">x</span>;
<span style="color: #98fb98;">int</span> <span style="color: #00ffff;">volatile</span> * <span style="color: #00ffff;">volatile</span> <span style="color: #eedd82;">x</span>;
</pre>
</div>
<p>
Volatile variables are not optimized, but this can actually be useful.
Imagine this function:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">opt</span> = 1;
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Fn</span>(<span style="color: #98fb98;">void</span>) {

<span style="color: #7fffd4;">start</span>:

<span style="color: #00ffff;">if</span> (opt == 1) <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">start</span>;

<span style="color: #00ffff;">else</span> <span style="color: #00ffff;">break</span>;
}
</pre>
</div>
<p>
At first glance, our code appears to loop infinitely. The compiler
will try to optimize it to:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">Fn</span>(<span style="color: #98fb98;">void</span>) {

<span style="color: #7fffd4;">start</span>:

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">opt</span> = 1;

<span style="color: #00ffff;">if</span> (<span style="color: #7fffd4;">true</span>)

<span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">start</span>;
}
</pre>
</div>
<p>
This becomes an infinite loop. However, an external program might
write ‘0’ to the location of variable opt. Volatile variables are also
useful when multi-threaded programs have global variables and any
thread can modify these shared variables. Of course, we don’t want
optimization on them.
</p>

<p>
More:
</p>
<ul class="org-ul">
<li>Volatile: A programmer’s best friend:
<a href="http://www.drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766">http://www.drdobbs.com/cpp/volatile-the-multithreaded-programmers-b/184403766</a>
</li>

<li>Do not use volatile as a synchronization primitive:
<a href="https://www.securecoding.cert.org/confluence/display/cplusplus/CON01-CPP.+Do+not+use+volatile+as+a+synchronization+primitive">https://www.securecoding.cert.org/confluence/display/cplusplus/CON01-CPP.+Do+not+use+volatile+as+a+synchronization+primitive</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Scope rules in C</h2>
<div class="outline-text-2" id="text-10">
<p>
Block Scope: A Block is a set of statements enclosed within left and
right braces ({ and } respectively). Blocks may be nested in C (a
block may contain other blocks inside it). A variable declared in a
block is accessible in the block and all inner blocks of that block,
but not accessible outside the block.
</p>

<p>
Can variables of block be accessed in another subsequent block?
</p>

<p>
No, a variabled declared in a block can only be accessed inside the
block and all inner blocks of this block. For example, following
program produces compiler error.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  {
      <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = 10;
  }
  {
      printf(<span style="color: #ffa07a;">"%d"</span>, x);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Error: x is not accessible here</span>
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
Output:
<code>error: 'x' undeclared (first use in this function)</code>
</p>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">What are the default values of static variables in C?</h2>
<div class="outline-text-2" id="text-11">
<p>
In C, if an object that has static storage duration is not initialized explicitly, then:
</p>
<ul class="org-ul">
<li>if it has pointer type, it is initialized to a NULL pointer;
</li>
<li>if it has arithmetic type, it is initialized to (positive or unsigned) zero;
</li>
<li>if it is an aggregate, every member is initialized (recursively) according to these rules;
</li>
<li>if it is a union, the first named member is initialized (recursively) according to these rules.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Scansets in C</h2>
<div class="outline-text-2" id="text-12">
<p>
scanf family functions support scanset specifiers which are
represented by %[]. Inside scanset, we can specify single character or
range of characters. While processing scanset, scanf will process only
those characters which are part of scanset.
</p>
</div>

<div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">store only capital letters to character array ‘str’</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[128];

    printf(<span style="color: #ffa07a;">"Enter a string: "</span>);
    scanf(<span style="color: #ffa07a;">"%[A-Z]s"</span>, str);

    printf(<span style="color: #ffa07a;">"You entered: %s\n"</span>, str);

    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;"># </span><span style="color: #ff7f24;">./scan-set </span>
Enter a string: WIKI_aa
You entered: WIKI
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">stop reading</h3>
<div class="outline-text-3" id="text-12-2">
<p>
If first character of scanset is ‘<sup>’</sup>, then the specifier will stop
reading after first occurence of that character.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[128];

    printf(<span style="color: #ffa07a;">"Enter a string: "</span>);
    scanf(<span style="color: #ffa07a;">"%[^o]s"</span>, str);

    printf(<span style="color: #ffa07a;">"You entered: %s\n"</span>, str);

    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">./scan-set</span>
Enter a string: http://geeks for geeks
You entered: http://geeks f
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">What is use of %n in printf() ?</h2>
<div class="outline-text-2" id="text-13">
<p>
In C printf(), %n is a special format specifier which instead of
printing something causes printf() to load the variable pointed by the
corresponding argument with a value equal to the number of characters
that have been printed by printf() before the occurrence of %n.
</p>

<p>
More printf:
<a href="http://swoolley.org/man.cgi/3/printf">http://swoolley.org/man.cgi/3/printf</a>
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span>;
  printf(<span style="color: #ffa07a;">"geeks for %ngeeks "</span>, &amp;c);
  printf(<span style="color: #ffa07a;">"%d"</span>, c);
  getchar();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Precedence of postfix <del>+ and prefix +</del> in C/C++</h2>
<div class="outline-text-2" id="text-14">
<p>
In C/C++, precedence of Prefix <del>+ (or Prefix –) and dereference (*)
operators is same, and precedence of Postfix +</del> (or Postfix –) is
higher than both Prefix ++ and *.
</p>

<p>
If p is a pointer then *p++ is equivalent to *(p++) and <del>+*p is
equivalent to ++(*p) (both Prefix +</del> and * are right associative).
</p>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Modulus on Negative Numbers</h2>
<div class="outline-text-2" id="text-15">
<p>
he emphasis is, sign of left operand is appended to result in case of
modulus operator in C.
</p>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Variable length arguments for Macros</h2>
<div class="outline-text-2" id="text-16">
<p>
To support variable length arguments in macro, we must include
ellipses (…) in macro definition. There is also “_<sub>VA</sub><sub>ARGS</sub>_<sub>”</sub>
preprocessing identifier which takes care of variable length argument
substitutions which are provided to macro. Concatenation operator ##
(aka paste operator) is used to concatenate variable arguments.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">INFO</span>    1
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">ERR</span> 2
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">STD_OUT</span> stdout
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">STD_ERR</span> stderr

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">LOG_MESSAGE</span>(<span style="color: #eedd82;">prio</span>, <span style="color: #eedd82;">stream</span>, <span style="color: #eedd82;">msg</span>, ...) <span style="color: #00ffff;">do</span> {\
                        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>;\
                        <span style="color: #00ffff;">if</span> (prio == INFO)\
                            str = <span style="color: #ffa07a;">"INFO"</span>;\
                        <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (prio == ERR)\
                            str = <span style="color: #ffa07a;">"ERR"</span>;\
                        fprintf(stream, <span style="color: #ffa07a;">"[%s] : %s : %d : "</span>msg<span style="color: #ffa07a;">" \n"</span>, \
                                str, __FILE__, __LINE__, ##__VA_ARGS__);\
                    } <span style="color: #00ffff;">while</span> (0)

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>(<span style="color: #98fb98;">void</span>)
{
    <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">s</span> = <span style="color: #ffa07a;">"Hello"</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">display normal message </span><span style="color: #ff7f24;">*/</span>
    LOG_MESSAGE(ERR, STD_ERR, <span style="color: #ffa07a;">"Failed to open file"</span>);

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">provide string as argument </span><span style="color: #ff7f24;">*/</span>
    LOG_MESSAGE(INFO, STD_OUT, <span style="color: #ffa07a;">"%s Geeks for Geeks"</span>, s);

    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">provide integer as arguments </span><span style="color: #ff7f24;">*/</span>
    LOG_MESSAGE(INFO, STD_OUT, <span style="color: #ffa07a;">"%d + %d = %d"</span>, 10, 20, (10 + 20));

    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-sh">[narendra@/media/partition/GFG]$ ./variable_length 
 [ERR] : variable_length.c : 26 : Failed to open file 
 [INFO] : variable_length.c : 27 : Hello Geeks for Geeks 
 [INFO] : variable_length.c : 28 : 10 + <span style="color: #eedd82;">20</span> = 30 
 [narendra@/media/partition/GFG]$
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">CRASH() macro – interpretation</h2>
<div class="outline-text-2" id="text-17">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> __cplusplus

<span style="color: #00ffff;">typedef</span> <span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">BoolenTag</span>
{
   <span style="color: #7fffd4;">false</span>,
   <span style="color: #7fffd4;">true</span>
} <span style="color: #98fb98;">bool</span>;

<span style="color: #b0c4de;">#endif</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">CRASH</span>() <span style="color: #00ffff;">do</span> { \
      ((<span style="color: #98fb98;">void</span>(*)())0)(); \
   } <span style="color: #00ffff;">while</span>(<span style="color: #7fffd4;">false</span>)

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
   CRASH();
   <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
The statement while(false) is meant only for testing purpose. Consider the following operation,
</p>

<p>
((void(*)())0)();
It can be achieved as follows,
</p>
<div class="org-src-container">

<pre class="src src-sh">0;                      /* literal zero */
(0); ( ()0 );                /* 0 being casted to some type */
( (*) 0 );              /* 0 casted some pointer type */
( (*)() 0 );            /* 0 casted as pointer to some <span style="color: #00ffff;">function</span> */
( void (*)(void) 0 );   /* Interpret 0 as address of <span style="color: #00ffff;">function</span> 
 taking nothing and returning nothing */
( void (*)(void) 0 )(); /* Invoke the <span style="color: #00ffff;">function</span> */
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">The OFFSETOF() macro</h2>
<div class="outline-text-2" id="text-18">
<p>
<code>#define OFFSETOF(TYPE, ELEMENT) ((size_t)&amp;(((TYPE *)0)-&gt;ELEMENT))</code>
</p>

<p>
Zero is casted to type of structure and required element’s address is
accessed, which is casted to size<sub>t</sub>. As per standard size<sub>t</sub> is of type
unsigned int. The overall expression results in the number of bytes
after which the ELEMENT being placed in the structure.
</p>

<p>
For example, the following code returns 16 bytes (padding is
considered on 32 bit machine) as displacement of the character
variable c in the structure Pod.
</p>
</div>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">Are array members deeply copied?</h2>
<div class="outline-text-2" id="text-19">
<p>
struct variable st1 contains pointer to dynamically allocated memory.
When we assign st1 to st2, str pointer of st2 also start pointing to
same memory location. This kind of copying is called Shallow Copy.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

using <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">std</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">test</span>
{
  <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">str</span>;
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">test</span> <span style="color: #eedd82;">st1</span>, <span style="color: #eedd82;">st2</span>;

  st1.str = new <span style="color: #98fb98;">char</span>[20];
  strcpy(st1.str, <span style="color: #ffa07a;">"GeeksforGeeks"</span>);

  st2 = st1;

  st1.str[0] = <span style="color: #ffa07a;">'X'</span>;
  st1.str[1] = <span style="color: #ffa07a;">'Y'</span>;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Since copy was shallow, both strings are same </span><span style="color: #ff7f24;">*/</span>
  cout &lt;&lt; <span style="color: #ffa07a;">"st1's str = "</span> &lt;&lt; st1.str &lt;&lt; endl;
  cout &lt;&lt; <span style="color: #ffa07a;">"st2's str = "</span> &lt;&lt; st2.str &lt;&lt; endl;

  <span style="color: #00ffff;">return</span> 0;
}
Output:
st1&#8242;s str = XYeksforGeeks
st2&#8242;s str = XYeksforGeeks
</pre>
</div>

<p>
what about arrays? The point to note is that the array members are not
shallow copied, compiler automatically performs Deep Copy for array
members.. In the following program, struct test contains array member
str[]. When we assign st1 to st2, st2 has a new copy of the array. So
st2 is not changed when we change str[] of st1.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;iostream&gt;</span>
<span style="color: #b0c4de;"># include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

using <span style="color: #98fb98;">namespace</span> <span style="color: #eedd82;">std</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">test</span>
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[20];
};

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">test</span> <span style="color: #eedd82;">st1</span>, <span style="color: #eedd82;">st2</span>;

  strcpy(st1.str, <span style="color: #ffa07a;">"GeeksforGeeks"</span>);

  st2 = st1;

  st1.str[0] = <span style="color: #ffa07a;">'X'</span>;
  st1.str[1] = <span style="color: #ffa07a;">'Y'</span>;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Since copy was Deep, both arrays are different </span><span style="color: #ff7f24;">*/</span>
  cout &lt;&lt; <span style="color: #ffa07a;">"st1's str = "</span> &lt;&lt; st1.str &lt;&lt; endl;
  cout &lt;&lt; <span style="color: #ffa07a;">"st2's str = "</span> &lt;&lt; st2.str &lt;&lt; endl;

  <span style="color: #00ffff;">return</span> 0;
}
Output:
st1&#8242;s str = XYeksforGeeks
st2&#8242;s str = GeeksforGeeks
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">Functions that are executed before and after main() in C</h2>
<div class="outline-text-2" id="text-20">
<p>
With GCC family of C compilers, we can mark some functions to execute
before and after main(). So some startup code can be executed before
main() starts, and some cleanup code can be executed after main()
ends. For example, in the following program, myStartupFun() is called
before main() and myCleanupFun() is called after main().
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span><span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Apply the constructor attribute to myStartupFun() so that it</span>
<span style="color: #ff7f24;">    is executed before main() </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">myStartupFun</span> (<span style="color: #98fb98;">void</span>) <span style="color: #00ffff;">__attribute__</span> ((<span style="color: #98fb98;">constructor</span>));


<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Apply the destructor attribute to myCleanupFun() so that it</span>
<span style="color: #ff7f24;">   is executed after main() </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">myCleanupFun</span> (<span style="color: #98fb98;">void</span>) <span style="color: #00ffff;">__attribute__</span> ((<span style="color: #98fb98;">destructor</span>));


<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation of myStartupFun </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">myStartupFun</span> (<span style="color: #98fb98;">void</span>)
{
    printf (<span style="color: #ffa07a;">"startup code before main()\n"</span>);
}

<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">implementation of myCleanupFun </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">myCleanupFun</span> (<span style="color: #98fb98;">void</span>)
{
    printf (<span style="color: #ffa07a;">"cleanup code after main()\n"</span>);
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span> (<span style="color: #98fb98;">void</span>)
{
    printf (<span style="color: #ffa07a;">"hello\n"</span>);
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
<p>
Like the above feature, GCC has added many other interesting features
to standard C language. See this for more details.
<a href="http://www.drdobbs.com/gnus-c-language-extensions/184401956">http://www.drdobbs.com/gnus-c-language-extensions/184401956</a>
</p>
</div>
</div>

<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21">How to Count Variable Numbers of Arguments in C?</h2>
<div class="outline-text-2" id="text-21">
<p>
C supports variable numbers of arguments. But there is no language
provided way for finding out total number of arguments passed. User
has to handle this in one of the following ways:
</p>

<ol class="org-ol">
<li>By passing first argument as count of arguments.
</li>
<li>By passing last argument as NULL (or 0).
</li>
<li>Using some printf (or scanf) like mechanism where first argument
has placeholders for rest of the arguments.
</li>
</ol>

<p>
Following is an example that uses first argument arg<sub>count</sub> to hold
count of other arguments.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">this function returns minimum of integer numbers passed.  First </span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">argument is count of numbers.</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">min</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">arg_count</span>, ...)
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min</span>, <span style="color: #eedd82;">a</span>;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">va_list is a type to hold information about variable arguments</span>
  <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">ap</span>; 

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">va_start must be called before accessing variable argument list</span>
  va_start(ap, arg_count); 

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Now arguments can be accessed one by one using va_arg macro</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Initialize min as first argument in list   </span>
  min = va_arg(ap, <span style="color: #98fb98;">int</span>);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">traverse rest of the arguments to find out minimum</span>
  <span style="color: #00ffff;">for</span>(i = 2; i &lt;= arg_count; i++) {
    <span style="color: #00ffff;">if</span>((a = va_arg(ap, <span style="color: #98fb98;">int</span>)) &lt; min)
      min = a;
  }   

  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">va_end should be executed before the function returns whenever</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">va_start has been previously used in that function </span>
  va_end(ap);   

  <span style="color: #00ffff;">return</span> min;
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
   <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">count</span> = 5;

   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Find minimum of 5 numbers: (12, 67, 6, 7, 100)</span>
   printf(<span style="color: #ffa07a;">"Minimum value is %d"</span>, min(count, 12, 67, 6, 7, 100));
   getchar();
   <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22">exit(), abort()</h2>
<div class="outline-text-2" id="text-22">
</div><div id="outline-container-sec-22-1" class="outline-3">
<h3 id="sec-22-1">exit()</h3>
<div class="outline-text-3" id="text-22-1">
<p>
<code>void exit ( int status );</code>
exit() terminates the process normally. 
status: Status value returned to the parent process. Generally, a status value of 0 or EXIT<sub>SUCCESS</sub> indicates success, and any other value or the constant EXIT<sub>FAILURE</sub> is used to indicate an error. exit() performs following operations.
</p>
<ul class="org-ul">
<li>Flushes unwritten buffered data.
</li>
<li>Closes all open files.
</li>
<li>Removes temporary files.
</li>
<li>Returns an integer exit status to the operating system.
</li>
</ul>

<p>
The C standard atexit()<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> function can be used to customize exit() to
perform additional actions at program termination.
</p>
</div>
</div>
<div id="outline-container-sec-22-2" class="outline-3">
<h3 id="sec-22-2">abort()</h3>
<div class="outline-text-3" id="text-22-2">
<p>
void abort ( void );
Unlike exit() function, abort() may not close files that are open. It may also not delete temporary files and may not flush stream buffer. Also, it does not call functions registered with atexit().
</p>

<p>
This function actually terminates the process by raising a SIGABRT
signal, and your program can include a handler to intercept this
signal<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<p>
If we want to make sure that data is written to files and/or buffers
are flushed then we should either use exit() or include a signal
handler for SIGABRT.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23">Struct Hack</h2>
<div class="outline-text-2" id="text-23">
<p>
What will be the size of following structure?
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">employee</span>
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">emp_id</span>;
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">name_len</span>;
    <span style="color: #98fb98;">char</span>    <span style="color: #eedd82;">name</span>[0];
};
</pre>
</div>
<p>
4 + 4 + 0 = 8 bytes.
</p>

<p>
And what about size of “name[0 ]“. In gcc, when we create an array
of zero length, it is considered as array of incomplete type that’s
why gcc reports its size as “0″ bytes. This technique is known as
“Stuct Hack”. When we create array of zero length inside structure,
it must be (and only) last member of structure. Shortly we will see
how to use it.
</p>

<p>
“Struct Hack” technique is used to create variable length member in
a structure. In the above structure, string length of “name” is not
fixed, so we can use “name” as variable length array.
</p>

<p>
Let us see below memory allocation.
</p>

<p>
struct employee *e = malloc(sizeof(*e) + sizeof(char) * 128); 
is equivalent to
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">employee</span>
{
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">emp_id</span>;
    <span style="color: #98fb98;">int</span>     <span style="color: #eedd82;">name_len</span>;
    <span style="color: #98fb98;">char</span>    <span style="color: #eedd82;">name</span>[128]; <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">character array of size 128 </span><span style="color: #ff7f24;">*/</span>
};
</pre>
</div>

<p>
Now we can use “name” same as pointer. e.g.
</p>
<div class="org-src-container">

<pre class="src src-c">e-&gt;emp_id       = 100;
e-&gt;name_len     = strlen(<span style="color: #ffa07a;">"Geeks For Geeks"</span>);
strncpy(e-&gt;name, <span style="color: #ffa07a;">"Geeks For Geeks"</span>, e-&gt;name_len);
</pre>
</div>
<p>
When we allocate memory as given above, compiler will allocate memory to store “emp<sub>id”</sub> and “name<sub>len”</sub> plus contiguous memory to store “name”. When we use this technique, gcc guaranties that, “name” will get contiguous memory.
Obviously there are other ways to solve problem, one is we can use character pointer. But there is no guarantee that character pointer will get contiguous memory, and we can take advantage of this contiguous memory. For example, by using this technique, we can allocate and deallocate memory by using single malloc and free call (because memory is contagious). Other advantage of this is, suppose if we want to write data, we can write whole data by using single “write()” call. e.g.
</p>
<div class="org-src-container">

<pre class="src src-c">write(fd, e, <span style="color: #00ffff;">sizeof</span>(*e) + name_len); <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">write emp_id + name_len + name </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
If we use character pointer, then we need 2 write calls to write data. e.g.
</p>
<div class="org-src-container">

<pre class="src src-c">write(fd, e, <span style="color: #00ffff;">sizeof</span>(*e));               <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">write emp_id + name_len </span><span style="color: #ff7f24;">*/</span>
write(fd, e-&gt;name, e-&gt;name_len);        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">write name </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24">fseek() vs rewind() in C<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup></h2>
<div class="outline-text-2" id="text-24">
<p>
In C, fseek() should be preferred over rewind().
</p>

<p>
Note the following text C99 standard:
The rewind function sets the file position indicator for the stream pointed to by stream to the beginning of the file. It is equivalent to
</p>

<p>
<code>(void)fseek(stream, 0L, SEEK_SET)</code>
except that the error indicator for the stream is also cleared. But
there is no way to check whether the rewind() was successful.
</p>

<p>
fseek() can be used instead of rewind() to see if the operation
succeeded. Following lines of code can be used in place of rewind(fp);
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">if</span> ( fseek(fp, 0L, SEEK_SET) != 0 ) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Handle repositioning error </span><span style="color: #ff7f24;">*/</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25">EOF, getc() and feof() in C</h2>
<div class="outline-text-2" id="text-25">
<p>
n C/C++, getc() returns EOF when end of file is reached. getc() also
returns EOF when it fails. So, only comparing the value returned by
getc() with EOF is not sufficient to check for actual end of file. To
solve this problem, C provides feof() which returns non-zero value
only if end of file has reached, otherwise it returns 0.
</p>

<p>
In the program, returned value of getc() is compared with EOF first,
then there is another check using feof(). By putting this check, we
make sure that the program prints “End of file reached” only if end
of file is reached. And if getc() returns EOF due to any other reason,
then the program prints “Something went wrong”
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">FILE</span> *<span style="color: #eedd82;">fp</span> = fopen(<span style="color: #ffa07a;">"test.txt"</span>, <span style="color: #ffa07a;">"r"</span>);
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ch</span> = getc(fp);
  <span style="color: #00ffff;">while</span> (ch != EOF) 
  {
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">display contents of file on screen </span><span style="color: #ff7f24;">*/</span>
    putchar(ch); 

    ch = getc(fp);
  }

  <span style="color: #00ffff;">if</span> (feof(fp))
     printf(<span style="color: #ffa07a;">"\n End of file reached."</span>);
  <span style="color: #00ffff;">else</span>
     printf(<span style="color: #ffa07a;">"\n Something went wrong."</span>);
  fclose(fp);

  getchar();
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26">Implement Your Own sizeof</h2>
<div class="outline-text-2" id="text-26">
<p>
<code>#define my_sizeof(type) (char *)(&amp;type+1)-(char*)(&amp;type)</code>
</p>
</div>
</div>
<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27">Complicated declarations in C</h2>
<div class="outline-text-2" id="text-27">
<p>
Most of the times declarations are simple to read, but it is hard to read some declarations which involve pointer to functions. For example, consider the following declaration from “signal.h”.
</p>

<p>
<code>void (*bsd_signal(int, void (*)(int)))(int);</code>
Let us see the steps to read complicated declarations.
</p>

<ol class="org-ol">
<li>Convert C declaration to postfix format and read from left to right.
</li>
<li>To convert experssion to postfix, start from innermost parenthesis, If innermost parenthesis is not present then start from declarations name and go right first. When first ending parenthesis encounters then go left. Once whole parenthesis is parsed then come out from parenthesis.
</li>
<li>Continue until complete declaration has been parsed.
</li>
</ol>

<p>
Let us start with simple example. Below examples are from “K &amp; R” book.
</p>

<ol class="org-ol">
<li>int (*fp) ();
</li>
</ol>
<p>
Let us convert above expression to postfix format. For the above example, there is no innermost parenthesis, that’s why, we will print declaration name i.e. “fp”. Next step is, go to right side of expression, but there is nothing on right side of “fp” to parse, that’s why go to left side. On left side we found “*”, now print “*” and come out of parenthesis. We will get postfix expression as below.
</p>

<p>
  fp  *  ()  int
Now read postfix expression from left to right. e.g. fp is pointer to function returning int
</p>

<p>
Let us see some more examples.
</p>

<ol class="org-ol">
<li><code>int (*daytab)[13]</code>
</li>
</ol>
<p>
Postfix : <code>daytab * [13] int</code>
Meaning : daytab is pointer to array of 13 integers.
</p>

<ol class="org-ol">
<li><code>void (*f[10]) (int, int)</code>
</li>
</ol>
<p>
Postfix : <code>f[10] * (int, int) void</code>
Meaning : f is an array of 10 of pointer to function(which takes 2 arguments of type int) returning void
</p>

<ol class="org-ol">
<li>char (*(*x())[]) ()
</li>
</ol>
<p>
Postfix : x () * [] * () char
Meaning : x is a function returning pointer to array of pointers to function returnging char
</p>

<ol class="org-ol">
<li><code>char (*(*x[3])())[5]</code>
</li>
</ol>
<p>
Postfix : <code>x[3] * () * [5] char</code>
Meaning : x is an array of 3 pointers to function returning pointer to array of 5 char’s
</p>

<ol class="org-ol">
<li><code>int *(*(*arr[5])()) ()</code>
</li>
</ol>
<p>
Postfix : <code>arr[5] * () * () * int</code>
Meaning : arr is an array of 5 pointers to functions returning pointer to function returning pointer to integer
</p>

<ol class="org-ol">
<li>void (*bsd<sub>signal</sub>(int sig, void (*func)(int)))(int);
</li>
</ol>
<p>
Postfix : bsd<sub>signal</sub>(int sig, void(*func)(int)) * (int) void
Meaning : bsd<sub>signal</sub> is a function that takes integer &amp; a pointer to a
function(that takes integer as argument and returns void) and returns
pointer to a function(that take integer as argument and returns void)
</p>
</div>
</div>

<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28">How Linkers Resolve Multiply Defined Global Symbols?<sup><a id="fnr.6" name="fnr.6" class="footref" href="#fn.6">6</a></sup></h2>
<div class="outline-text-2" id="text-28">
<p>
Given this notion of strong and weak symbols, Unix linkers use the following rules for dealing with multiply defined symbols:
</p>

<p>
Rule 1: Multiple strong symbols are not allowed.
Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol.
Rule 3: Given multiple weak symbols, choose any of the weak symbols.
</p>
</div>
</div>
<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29">Use of bool in C</h2>
<div class="outline-text-2" id="text-29">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdbool.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
  <span style="color: #98fb98;">bool</span> <span style="color: #eedd82;">arr</span>[2] = {<span style="color: #7fffd4;">true</span>, <span style="color: #7fffd4;">false</span>};
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30">Little and Big Endian Mystery</h2>
<div class="outline-text-2" id="text-30">
</div><div id="outline-container-sec-30-1" class="outline-3">
<h3 id="sec-30-1">Is there a quick way to determine endianness of your machine?</h3>
<div class="outline-text-3" id="text-30-1">
<p>
There are n no. of ways for determining endianness of your machine.
Here is one quick way of doing the same.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() 
{
   <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1;
   <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">c</span> = (<span style="color: #98fb98;">char</span>*)&amp;i;
   <span style="color: #00ffff;">if</span> (*c)    
       printf(<span style="color: #ffa07a;">"Little endian"</span>);
   <span style="color: #00ffff;">else</span>
       printf(<span style="color: #ffa07a;">"Big endian"</span>);
   getchar();
   <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-30-2" class="outline-3">
<h3 id="sec-30-2">Does endianness matter for programmers?</h3>
<div class="outline-text-3" id="text-30-2">
<p>
Most of the times compiler takes care of endianness, however,
endianness becomes an issue in following cases.
</p>

<p>
It matters in network programming: Suppose you write integers to file
on a little endian machine and you transfer this file to a big endian
machine. Unless there is little andian to big endian transformation,
big endian machine will read the file in reverse order. You can find
such a practical example here.
</p>

<p>
Standard byte order for networks is big endian, also known as network
byte order. Before transferring data on network, data is first
converted to network byte order (big endian).
</p>

<p>
Sometimes it matters when you are using type casting, below program is
an example.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>()
{
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">arr</span>[2] = {0x01, 0x00};
    <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">x</span> = *(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span> <span style="color: #98fb98;">int</span> *) arr;
    printf(<span style="color: #ffa07a;">"%d"</span>, x);
    getchar();
    <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://blog.csdn.net/carry1314lele/article/details/2191113">http://blog.csdn.net/carry1314lele/article/details/2191113</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
The Practice of Programming page 14
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="http://www.cplusplus.com/reference/cstdlib/atexit/">http://www.cplusplus.com/reference/cstdlib/atexit/</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="http://msdn.microsoft.com/en-us/library/xdkz3x12(VS.80).aspx">http://msdn.microsoft.com/en-us/library/xdkz3x12(VS.80).aspx</a>
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
<a href="https://www.securecoding.cert.org/confluence/display/seccode/FIO07-C.+Prefer+fseek()+to+rewind()">https://www.securecoding.cert.org/confluence/display/seccode/FIO07-C.+Prefer+fseek()+to+rewind()</a>
</p></div>

<div class="footdef"><sup><a id="fn.6" name="fn.6" class="footnum" href="#fnr.6">6</a></sup> <p class="footpara">
<a href="http://www.geeksforgeeks.org/how-linkers-resolve-multiply-defined-global-symbols/">http://www.geeksforgeeks.org/how-linkers-resolve-multiply-defined-global-symbols/</a>
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2015-03-05 Thu 23:21</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
