<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C FAQ Notes</title>
<!-- 2015-03-05 Thu 23:21 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link href="../../assets/bootstrap.min.css" rel="stylesheet" media="screen">
<link href="../../assets/bootstrap-responsive.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script src="assets/js/bootstrap.min.js"></script>

<script type="text/javascript" src="assets/js/org-info.js">
/**
 *
 * @source: assets/js/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in assets/js/org-info.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in assets/js/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "#dddddd");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">C FAQ Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Declarations and Initializations</a>
<ul>
<li><a href="#sec-1-1">Q1.1 How should I decide which integer type to use?</a></li>
<li><a href="#sec-1-2">Q1.3 You no longer have to define your own typedefs, because the Standard header &lt;inttypes.h&gt; contains a complete set.</a></li>
<li><a href="#sec-1-3">Q1.10 Do all declarations for the same static function or variable have to include the storage class static?</a></li>
<li><a href="#sec-1-4">Q1.20b What does it mean for a function parameter to be const? What do the two const's in</a></li>
<li><a href="#sec-1-5">Q1.21  How do I construct declarations of complicated types such as ``array of N pointers to functions returning pointers to functions returning pointers to char'', or figure out what similarly complicated declarations mean?</a></li>
<li><a href="#sec-1-6">Q1.29 How can I determine which identifiers are safe for me to use and which are reserved?</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Structures, Unions, and Enumerations</a>
<ul>
<li><a href="#sec-2-1">Q2.6  I came across some code that declared a structure like this:</a></li>
<li><a href="#sec-2-2">Q2.10 How can I pass constant values to functions which accept structure arguments? How can I create nameless, immediate, constant structure values?</a></li>
<li><a href="#sec-2-3">Q2.11 How can I read/write structures from/to data files?</a></li>
<li><a href="#sec-2-4">Q2.12 Why is my compiler leaving holes in structures, wasting space and preventing ``binary'' I/O to external data files? Can I turn this off, or otherwise control the alignment of structure fields?</a></li>
<li><a href="#sec-2-5">Q2.14 How can I determine the byte offset of a field within a structure?</a></li>
<li><a href="#sec-2-6">Q2.21 Is there an automatic way to keep track of which field of a union is in use?</a></li>
<li><a href="#sec-2-7">Q2.25 I came across some structure declarations with colons and numbers next to certain fields, like this:</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Expressions</a>
<ul>
<li><a href="#sec-3-1">Q3.4 Can I use explicit parentheses to force the order of evaluation I want, and control these side effects? Even if I don't, doesn't precedence dictate it?</a></li>
<li><a href="#sec-3-2">Q3.14 Why doesn't the code</a></li>
<li><a href="#sec-3-3">Q3.16 I have a complicated expression which I have to assign to one of two variables, depending on a condition. Can I use code like this?</a></li>
<li><a href="#sec-3-4">Q3.19 What's the difference between the ``unsigned preserving'' and ``value preserving'' rules?</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Pointers</a>
<ul>
<li><a href="#sec-4-1">Q4.5 I have a char * pointer that happens to point to some ints, and I want to step it over them. Why doesn't</a></li>
<li><a href="#sec-4-2">Q4.9 Suppose I want to write a function that takes a generic pointer as an argument and I want to simulate passing it by reference.</a></li>
<li><a href="#sec-4-3">Q4.10 I have a function</a></li>
<li><a href="#sec-4-4">Q4.12 I've seen different syntax used for calling functions via pointers. What's the story?</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Null Pointers</a>
<ul>
<li><a href="#sec-5-1">Q5.2 How do I get a null pointer in my programs?</a></li>
<li><a href="#sec-5-2">Q5.3 Is the abbreviated pointer comparison ``if(p)'' to test for non-null pointers valid? What if the internal representation for null pointers is nonzero?</a></li>
<li><a href="#sec-5-3">Q5.5  How should NULL be defined on a machine which uses a nonzero bit pattern as the internal representation of a null pointer?</a></li>
<li><a href="#sec-5-4">Q5.15 I'm confused. I just can't understand all this null pointer stuff.</a></li>
<li><a href="#sec-5-5">Q5.18 Is a run-time integral value of 0, cast to a pointer, guaranteed to be a null pointer?</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Arrays and Pointers</a>
<ul>
<li><a href="#sec-6-1">Q6.5 Why can't I do something like this?</a></li>
<li><a href="#sec-6-2">Q6.7 How can an array be an lvalue, if you can't assign to it?</a></li>
<li><a href="#sec-6-3">Q6.8 Practically speaking, what is the difference between arrays and pointers?</a></li>
<li><a href="#sec-6-4">Q6.11 I came across some ``joke'' code containing the ``expression'' 5["abcdef"] . How can this be legal C?</a></li>
<li><a href="#sec-6-5">Q6.13 How do I declare a pointer to an array?</a></li>
<li><a href="#sec-6-6">Q6.16 How can I dynamically allocate a multidimensional array?</a></li>
<li><a href="#sec-6-7">Q6.20 How can I use statically- and dynamically-allocated multidimensional arrays interchangeably when passing them to functions?</a></li>
<li><a href="#sec-6-8">Q6.23 I want to know how many elements are in an array, but sizeof yields the size in bytes.</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Memory Allocation</a>
<ul>
<li><a href="#sec-7-1">Q7.5a and Q7.5b</a></li>
<li><a href="#sec-7-2">Q7.14 I've heard that some operating systems don't actually allocate malloc'ed memory until the program tries to use it. Is this legal?</a></li>
<li><a href="#sec-7-3">Q7.28 Why doesn't sizeof tell me the size of the block of memory pointed to by a pointer?</a></li>
<li><a href="#sec-7-4">Q7.29 Having dynamically allocated an array (as in question 6.14), can I change its size?</a></li>
</ul>
</li>
<li><a href="#sec-8">8. Characters and Strings</a>
<ul>
<li><a href="#sec-8-1">Q8.1 Why doesn't</a></li>
<li><a href="#sec-8-2">Q8.8 I'm reading strings typed by the user into an array, and then printing them out later. When the user types a sequence like \n, why isn't it being handled properly?</a></li>
<li><a href="#sec-8-3">Q8.9 I think something's wrong with my compiler: I just noticed that <code>sizeof('a')</code> is 2, not 1 (i.e. not <code>sizeof(char)</code>).</a></li>
</ul>
</li>
<li><a href="#sec-9">10. C Preprocessor</a>
<ul>
<li><a href="#sec-9-1">Q10.3 How can I write a generic macro to swap two values?</a></li>
<li><a href="#sec-9-2">Q10.4 What's the best way to write a multi-statement macro?</a></li>
<li><a href="#sec-9-3">Q10.5b What's the difference between</a></li>
<li><a href="#sec-9-4">Q10.7 Is it acceptable for one header file to #include another?</a></li>
<li><a href="#sec-9-5">Q10.12 How can I construct preprocessor #if expressions which compare strings?</a></li>
<li><a href="#sec-9-6">Q10.13 Does the sizeof operator work in preprocessor #if directives?</a></li>
<li><a href="#sec-9-7">Q10.15 Is there anything like an #ifdef for typedefs?</a></li>
<li><a href="#sec-9-8">Q10.16 How can I use a preprocessor #if expression to tell whether a machine's byte order is big-endian or little-endian?</a></li>
<li><a href="#sec-9-9">Q10.19 How can I list all of the predefined identifiers?</a></li>
<li><a href="#sec-9-10">Q10.20 I have some old code that tries to construct identifiers with a macro like</a></li>
<li><a href="#sec-9-11">Q10.27 How can I include expansions of the <span class="underline"><span class="underline">FILE</span></span> and <span class="underline"><span class="underline">LINE</span></span> macros in a general-purpose debugging macro?</a></li>
</ul>
</li>
<li><a href="#sec-10">11. ANSI/ISO Standard C</a>
<ul>
<li><a href="#sec-10-1">Q11.8 I don't understand why I can't use const values in initializers and array dimensions, as in</a></li>
<li><a href="#sec-10-2">Q11.9 What's the difference between const char *p, char const *p, and char * const p?</a></li>
<li><a href="#sec-10-3">Q11.10 Why can't I pass a char <b>* to a function which expects a const char *</b>?</a></li>
<li><a href="#sec-10-4">Q11.11 I've got the declarations</a></li>
<li><a href="#sec-10-5">Q11.16  Is exit(status) truly equivalent to returning the same status from main?</a></li>
<li><a href="#sec-10-6">Q11.17 I'm trying to use the ANSI ``stringizing'' preprocessing operator `#' to insert the value of a symbolic constant into a message, but it keeps stringizing the macro's name rather than its value.</a></li>
<li><a href="#sec-10-7">Q11.18 What does the message ``warning: macro replacement within a string literal'' mean?</a></li>
<li><a href="#sec-10-8">Q11.20 What are #pragmas and what are they good for?</a></li>
<li><a href="#sec-10-9">Q11.25 What's the difference between <code>memcpy</code> and <code>memmove</code>?</a></li>
<li><a href="#sec-10-10">Q11.26 What should malloc(0) do? Return a null pointer or a pointer to 0 bytes?</a></li>
<li><a href="#sec-10-11">Q11.33 People seem to make a point of distinguishing between implementation-defined, unspecified, and undefined behavior. What do these mean?</a></li>
<li><a href="#sec-10-12">Q11.33b  What does it really mean for a program to be ``legal'' or ``valid'' or ``conforming''?</a></li>
</ul>
</li>
<li><a href="#sec-11">12. Stdio</a>
<ul>
<li><a href="#sec-11-1">Q12.2</a></li>
<li><a href="#sec-11-2">Q12.5 How can I read one character at a time, without waiting for the RETURN key?</a></li>
<li><a href="#sec-11-3">12.9b What printf format should I use for a typedef like size<sub>t</sub> when I don't know whether it's long or some other type?</a></li>
</ul>
</li>
<li><a href="#sec-12">18. Tools and Resources</a>
<ul>
<li><a href="#sec-12-1">C development tools</a></li>
<li><a href="#sec-12-2">track down malloc problems tools</a></li>
<li><a href="#sec-12-3">C tutorials</a></li>
<li><a href="#sec-12-4">some good code examples to study</a></li>
<li><a href="#sec-12-5">Numerical Recipes</a></li>
<li><a href="#sec-12-6">The GNU C Library (glibc)</a></li>
<li><a href="#sec-12-7">parse and evaluate expressions(packages are ``defunc,'')</a></li>
<li><a href="#sec-12-8">Ian Hay's recommended book list</a></li>
<li><a href="#sec-12-9">code fragments and examples</a></li>
</ul>
</li>
<li><a href="#sec-13">strok</a></li>
<li><a href="#sec-14">qsort</a></li>
</ul>
</div>
</div>
<p>
Offical Site: <a href="http://c-faq.com/">http://c-faq.com/</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">1. Declarations and Initializations</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Q1.1 How should I decide which integer type to use?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Under ANSI C, the maximum and minimum values for a particular machine
can be found in the header file &lt;limits.h&gt;; here is a summary:
</p>
<div class="org-src-container">

<pre class="src src-c">Base type       <span style="color: #98fb98;">Minimum</span> <span style="color: #87cefa;">size</span> (<span style="color: #98fb98;">bits</span>)     <span style="color: #98fb98;">Minimum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">signed</span>)  <span style="color: #98fb98;">Maximum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">signed</span>)  <span style="color: #98fb98;">Maximum</span> <span style="color: #87cefa;">value</span> (<span style="color: #98fb98;">unsigned</span>)
<span style="color: #98fb98;">char</span>    8       -127    127     255
<span style="color: #98fb98;">short</span>   16      -32,767 32,767  65,535
<span style="color: #98fb98;">int</span>     16      -32,767 32,767  65,535
<span style="color: #98fb98;">long</span>    32      -2,147,483,647  2,147,483,647   4,294,967,295

<span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">char</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">short</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span>) &lt;= <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">long</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Q1.3 You no longer have to define your own typedefs, because the Standard header &lt;inttypes.h&gt; contains a complete set.</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The file path: <code>/usr/include/inttypes.h</code>.
</p>

<p>
The <code>inttypes.h</code> file is a C header file that is part of the C standard
library and API. It was added with the 1999 version of the ISO C
standard (known as C99). It includes the stdint.h header and defines a
number of macros for using it with the <code>printf</code> and <code>scanf</code> family of
functions, as well as functions for working with the intmax<sub>t</sub> type.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-2-1" name="sec-1-2-1"></a>Naming Convention and format specifiers for Macros<br  /><div class="outline-text-4" id="text-1-2-1">
<p>
The macros defined in inttypes.h follow a regular pattern to simplify
usage. The pattern followed is as follows:
</p>

<ul class="org-ul">
<li>First three characters
<ul class="org-ul">
<li>PRI for output format (printf, fwprintf, wprintf, etc.)
</li>
<li>SCN for input format (scanf, fwscanf, etc.)
</li>
</ul>
</li>
<li>Fourth character
<ul class="org-ul">
<li>d for decimal formatting
</li>
<li>x for hexadecimal formatting
</li>
<li>o for octal formatting
</li>
<li>u for unsigned int formatting
</li>
<li>i for integer formatting
</li>
</ul>
</li>
<li>Remaining Characters
<ul class="org-ul">
<li>N for N bit size assignment to the data type (Eg. 32 for 32-bit size for integer, 16 for 16-bit size for unsigned int and so on)
</li>
<li>PTR for pointer
</li>
<li>MAX for maximum supported bit size
</li>
<li>FAST, whose meaning is not clearly defined and is left to the implementation to decide what is meant by a "fast" integer data type.
</li>
</ul>
</li>
</ul>






<p>
Question 2.25
bit-fields; 
<a href="http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html">http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html</a>
<a href="http://www.linuxforu.com/2012/01/joy-of-programming-understanding-bit-fields-c/">http://www.linuxforu.com/2012/01/joy-of-programming-understanding-bit-fields-c/</a>
<a href="http://en.wikipedia.org/wiki/Single_precision">http://en.wikipedia.org/wiki/Single_precision</a>
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Q1.10 Do all declarations for the same static function or variable have to include the storage class static?</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Additional links: An <a href="http://c-faq.com/decl/static.jd.html">article by Jutta Degener</a> explaining the subtly
different rules for static variables versus static functions.
</p>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">object </span><span style="color: #ff7f24;">*/</span>      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function </span><span style="color: #ff7f24;">*/</span>

<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o1</span>;           <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f1</span>();             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">external linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o2</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f2</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">internal linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o3</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f3</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">internal linkage </span><span style="color: #ff7f24;">*/</span>

<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o1</span>;    <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f1</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ERROR, both have external linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o2</span>;                                 <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ERROR, o2 has internal linkage </span><span style="color: #ff7f24;">*/</span>
                  <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f2</span>();             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">OK, picks up internal linkage </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">o3</span>;    <span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">f3</span>();      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">OK, both pick up internal linkage </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
The difference is case (2); where functions do pick up a previous
linkage even without "extern", objects don't.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Q1.20b What does it mean for a function parameter to be const? What do the two const's in</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<code>int f(const * const p)</code> mean?
</p>

<p>
The first of the two const's is perfectly appropriate and quite
useful; many functions declare parameters which are pointers to const
data, and doing so documents (and tends to enforce) the function's
promise that it won't modify the pointed-to data in the caller. The
second const, on the other hand, is almost useless; all it says is
that the function won't alter its own copy of the pointer, even though
it wouldn't cause the caller or the function any problems if it did,
nor is this anything the caller should care about in any case. The
situation is the same as if a function declared an ordinary
(non-pointer) parameter as const:
</p>

<p>
        <code>int f2(const int x)</code>
This says that nowhere in the body of f2() will the function assign a
different value to x. 
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Q1.21  How do I construct declarations of complicated types such as ``array of N pointers to functions returning pointers to functions returning pointers to char'', or figure out what similarly complicated declarations mean?</h3>
<div class="outline-text-3" id="text-1-5">
<ol class="org-ol">
<li><code>char *(*(*a[N])())();</code>
</li>
</ol>
<p>
Build the declaration up incrementally, using <code>typedefs</code>:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">char</span> *<span style="color: #98fb98;">pc</span>;       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to char </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pc</span> <span style="color: #98fb98;">fpc</span>();       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function returning pointer to char </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">fpc</span> *<span style="color: #98fb98;">pfpc</span>;      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to above </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">pfpc</span> <span style="color: #98fb98;">fpfpc</span>();   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">function returning... </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">fpfpc</span> *<span style="color: #98fb98;">pfpfpc</span>;  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to... </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">pfpfpc</span> <span style="color: #eedd82;">a</span>[N];            <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">array of... </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
Use the <b>cdecl</b> program, which turns English into C and vice versa.
You provide a longhand description of the type you want, and cdecl
responds with the equivalent C declaration:
</p>
<div class="org-src-container">

<pre class="src src-sh">cdecl&gt; declare a as array of pointer to <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">returning</span>
        pointer to <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">returning</span> pointer to char

char *(*(*a[])())()
</pre>
</div>
<p>
 <b>cdecl</b> can also explain complicated declarations (you give it a
complicated declaration and it responds with an English description),
help with casts, and indicate which set of parentheses the parameters
go in (for complicated function definitions, like the one above).
</p>

<p>
One way to make sense of complicated C declarations is by reading them
``inside out,'' remembering that [] and () bind more tightly than *.
For example, given
</p>

<p>
<code>char *(*pfpc)();</code>
</p>

<p>
we can see that pfpc is a pointer (the inner *) to a function (the ())
to a pointer (the outer *) to char. When we later use pfpc, the
expression *(*pfpc)() (the value pointed to by the return value of a
function pointed to by pfpc) will be a char.
</p>

<p>
Another way of analyzing these declarations is to decompose the
declarator while composing the description, maintaining the
``declaration mimics use'' relationship: 
</p>
<div class="org-src-container">

<pre class="src src-c">*(*pfpc)()      is a    <span style="color: #98fb98;">char</span>
(*<span style="color: #87cefa;">pfpc</span>)()       is a    pointer to <span style="color: #98fb98;">char</span>
(*<span style="color: #eedd82;">pfpc</span>) is a    function returning pointer to <span style="color: #98fb98;">char</span>
<span style="color: #eedd82;">pfpc</span>    is a    pointer to function returning pointer to <span style="color: #98fb98;">char</span>
</pre>
</div>
<p>
If you'd like to make things clearer when declaring complicated types
        like these, you can make the analysis explicit by using a
        chain of typedefs as in option 2 above.
 <b>Additional links:</b>
David Anderson's <a href="http://c-faq.com/decl/spiral.anderson.html">``Clockwise/Spiral Rule''</a>
</p>

<p>
There is a technique known as the ``Clockwise/Spiral Rule'' which
enables any C programmer to parse in their head any C declaration!
</p>

<p>
There are three simple steps to follow:
</p>

<ol class="org-ol">
<li>Starting with the unknown element, move in a spiral/clockwise direction; when ecountering the following elements replace them with the corresponding english statements:
</li>
</ol>
<p>
[X] or []
=&gt; Array X size of&#x2026; or Array undefined size of&#x2026;
(type1, type2)
<code>&gt; function passing type1 and type2 returning...
=*</code>
=&gt; pointer(s) to&#x2026;
</p>
<ol class="org-ol">
<li>Keep doing this in a spiral/clockwise direction until all tokens have been covered.
</li>
<li>Always resolve anything in parenthesis first!
<b>Example #1: Simple declaration</b>
</li>
</ol>
<div class="org-src-container">

<pre class="src src-sh">     +-------+
     | +-+   |
     | ^ |   |
char *str[10];
 ^   ^   |   |
 |   +---+   |
 +-----------+
</pre>
</div>
<p>
Question we ask ourselves: What is str?
</p>

<p>
``str is an&#x2026;
</p>
<ul class="org-ul">
<li>We move in a spiral clockwise direction starting with `str' and the first character we see is a `[' so, that means we have an array, so&#x2026;
</li>
</ul>
<p>
``str is an array 10 of&#x2026;
</p>
<ul class="org-ul">
<li>Continue in a spiral clockwise direction, and the next thing we encounter is the `*' so, that means we have pointers, so&#x2026;
</li>
</ul>
<p>
``str is an array 10 of pointers to&#x2026;
</p>
<ul class="org-ul">
<li>Continue in a spiral direction and we see the end of the line (the `;'), so keep going and we get to the type `char', so&#x2026;
</li>
</ul>
<p>
``str is an array 10 of pointers to char''
</p>
<ul class="org-ul">
<li>We have now ``visited'' every token; therefore we are done!
<b>Example #2: Pointer to Function declaration</b>
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c">     +--------------------+
     | +---+              |
     | |+-+|              |
     | |^ ||              |
<span style="color: #98fb98;">char</span> *(*fp)( <span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">float</span> *);
 ^   ^ ^  ||              |
 |   | +--+|              |
 |   +-----+              |
 +------------------------+
</pre>
</div>
<p>
Question we ask ourselves: What is fp?
</p>

<p>
``fp is a&#x2026;
</p>
<ul class="org-ul">
<li>Moving in a spiral clockwise direction, the first thing we see is a `)'; therefore, fp is inside parenthesis, so we continue the spiral inside the parenthesis and the next character seen is the `*', so&#x2026;
</li>
</ul>
<p>
``fp is a pointer to&#x2026;
</p>
<ul class="org-ul">
<li>We are now out of the parenthesis and continuing in a spiral clockwise direction, we see the `('; therefore, we have a function, so&#x2026;
</li>
</ul>
<p>
``fp is a pointer to a function passing an int and a pointer to float returning&#x2026;
</p>
<ul class="org-ul">
<li>Continuing in a spiral fashion, we then see the `*' character, so&#x2026;
</li>
</ul>
<p>
``fp is a pointer to a function passing an int and a pointer to float returning a pointer to&#x2026;
</p>
<ul class="org-ul">
<li>Continuing in a spiral fashion we see the `;', but we haven't visited all tokens, so we continue and finally get to the type `char', so&#x2026;
</li>
</ul>
<p>
``fp is a pointer to a function passing an int and a pointer to float returning a pointer to a char''
 *Example #3: The ``Ultimate''*
</p>
<div class="org-src-container">

<pre class="src src-c">      +-----------------------------+
      |                  +---+      |
      |  +---+           |+-+|      |
      |  ^   |           |^ ||      |
<span style="color: #98fb98;">void</span> (*signal(<span style="color: #98fb98;">int</span>, <span style="color: #98fb98;">void</span> (*<span style="color: #eedd82;">fp</span>)(<span style="color: #98fb98;">int</span>)))(<span style="color: #98fb98;">int</span>);
 ^    ^      |      ^    ^  ||      |
 |    +------+      |    +--+|      |
 |                  +--------+      |
 +----------------------------------+
</pre>
</div>
<p>
Question we ask ourselves: What is `signal'?
</p>

<p>
Notice that signal is inside parenthesis, so we must resolve this first!
</p>

<ul class="org-ul">
<li>Moving in a clockwise direction we see `(' so we have&#x2026;
``signal is a function passing an int and a&#x2026;
</li>
<li>Hmmm, we can use this same rule on `fp', so&#x2026; What is fp? fp is also inside parenthesis so continuing we see an `*', so&#x2026;
fp is a pointer to&#x2026;
</li>
<li>Continue in a spiral clockwise direction and we get to `(', so&#x2026;
``fp is a pointer to a function passing int returning&#x2026;''
</li>
<li>Now we continue out of the function parenthesis and we see void, so&#x2026;
``fp is a pointer to a function passing int returning nothing (void)''
</li>
<li>We have finished with fp so let's catch up with `signal', we now have&#x2026;
``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning&#x2026;
</li>
<li>We are still inside parenthesis so the next character seen is a `*', so&#x2026;
``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to&#x2026;
</li>
<li>We have now resolved the items within parenthesis, so continuing clockwise, we then see another `(', so&#x2026;
``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning&#x2026;
</li>
<li>Finally we continue and the only thing left is the word `void', so the final complete definition for signal is:
``signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning nothing (void)''
</li>
</ul>

<p>
The same rule is applied for const and volatile. For Example:
</p>

<p>
<code>const char *chptr;</code>
</p>
<ul class="org-ul">
<li>Now, what is chptr??
</li>
</ul>
<p>
``chptr is a pointer to a char constant''
</p>

<p>
How about this one:
</p>

<p>
char * const chptr;
</p>
<ul class="org-ul">
<li>Now, what is chptr??
</li>
</ul>
<p>
``chptr is a constant pointer to char''
</p>

<p>
Finally:
</p>

<p>
volatile char * const chptr;
</p>
<ul class="org-ul">
<li>Now, what is chptr??
</li>
</ul>
<p>
``chptr is a constant pointer to a char volatile.''
</p>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Q1.29 How can I determine which identifiers are safe for me to use and which are reserved?</h3>
<div class="outline-text-3" id="text-1-6">
<p>
What do the above rules really mean? If you want to be on the safe side:
</p>

<p>
1,2. Don't give anything a name with a leading underscore.
</p>
<ol class="org-ol">
<li>Don't give anything a name which is already a standard macro (including the ``future directions'' patterns).
</li>
<li>Don't give any functions or global variables names which are already taken by functions or variables in the standard library, or which match any of the ``future directions'' patterns. (Strictly speaking, ``matching'' means matching in the first six characters, without regard to case; see question 11.27.)
</li>
<li>Don't redefine standard typedef or tag names.
</li>
</ol>

<p>
In fact, the preceding subparagraphs are overly conservative. If you wish, you may remember the following exceptions:
</p>

<p>
1,2. You may use identifiers consisting of an underscore followed by a digit or lower case letter for labels and structure/union members.
1,2. You may use identifiers consisting of an underscore followed by a digit or lower case letter at function, block, or prototype scope.
</p>
<ol class="org-ol">
<li>You may use names matching standard macro names if you don't #include any header files which #define them.
</li>
<li>You may use names of standard library routines as static or local variables (strictly speaking, as identifiers with internal or no linkage).
</li>
<li>You may use standard typedef and tag names if you don't #include any header files which declare them.
</li>
</ol>

<p>
However, before making use of any of these exceptions, recognize that
some of them are pretty risky (especially exceptions 3 and 5, since
you could accidentally #include the relevant header file at a later
time, perhaps through a chain of nested #include files), and others
(especially the ones labeled 1,2) represent sort of a ``no man's
land'' between the user namespaces and the namespaces reserved to the
implementation.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">2. Structures, Unions, and Enumerations</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Q2.6  I came across some code that declared a structure like this:</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">namestr</span>[1];
};
</pre>
</div>
<p>
and then did some tricky allocation to make the <code>namestr</code> array act like
        it had several elements, with the number recorded by namelen.
        How does this work? Is it legal or portable?
</p>

<p>
An implementation of the technique might look something like this:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> =
                malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>)-1 + strlen(newname)+1);
                                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">-1 for initial [1]; +1 for \0 </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                strcpy(ret-&gt;namestr, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>
</div>
<p>
This function allocates an instance of the name structure with the
size adjusted so that the namestr field can hold the requested name
(not just one character, as the structure declaration would suggest).
</p>

<p>
Another possibility is to declare the variable-size element very
large, rather than very small. The above example could be rewritten
like this:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">MAXSIZE</span> 100

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">namestr</span>[MAXSIZE];
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> =
                malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>)-MAXSIZE+strlen(newname)+1);
                                                                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">+1 for \0 </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                strcpy(ret-&gt;namestr, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>
</div>
<p>
where MAXSIZE is larger than any name which will be stored. 
</p>

<p>
Of course, to be truly safe, the right thing to do is use a character
pointer instead of an array:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> {
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">namelen</span>;
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">namep</span>;
};

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #87cefa;">makename</span>(<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">newname</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span> *<span style="color: #eedd82;">ret</span> = malloc(<span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">name</span>));
        <span style="color: #00ffff;">if</span>(ret != <span style="color: #7fffd4;">NULL</span>) {
                ret-&gt;namelen = strlen(newname);
                ret-&gt;namep = malloc(ret-&gt;namelen + 1);
                <span style="color: #00ffff;">if</span>(ret-&gt;namep == <span style="color: #7fffd4;">NULL</span>) {
                        free(ret);
                        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
                }
                strcpy(ret-&gt;namep, newname);
        }

        <span style="color: #00ffff;">return</span> ret;
}
</pre>
</div>
<p>
(Obviously, the ``convenience'' of having the length and the string
stored in the same block of memory has now been lost, and freeing
instances of this structure will require two calls to free; see
question 7.23.)
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Q2.10 How can I pass constant values to functions which accept structure arguments? How can I create nameless, immediate, constant structure values?</h3>
<div class="outline-text-3" id="text-2-2">
<p>
C99 introduces ``compound literals'', one form of which provides for structure constants. For example, to pass a constant coordinate pair to a hypothetical plotpoint function which expects a struct point, you can call
</p>

<p>
<code>plotpoint((struct point){1, 2});</code>
Combined with ``designated initializers'' (another C99 feature), it is also possible to specify member values by name:
<code>plotpoint((struct point){.x=1, .y=2});</code>
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Q2.11 How can I read/write structures from/to data files?</h3>
<div class="outline-text-3" id="text-2-3">
<p>
It is relatively straightforward to write a structure out using fwrite:
</p>

<p>
        <code>fwrite(&amp;somestruct, sizeof somestruct, 1, fp);</code>
and a corresponding <code>fread</code> invocation can read it back in. What happens
here is that <code>fwrite</code> receives a pointer to the structure, and writes
(or <code>fread</code> correspondingly reads) the memory image of the structure as
a stream of bytes. The sizeof operator determines how many bytes the
structure occupies.
</p>

<p>
However, data files written as memory images in this way will not be
portable, particularly if they contain floating-point fields or
pointers. The memory layout of structures is machine and compiler
dependent. Different compilers may use different amounts of padding
(see question 2.12), and the sizes and byte orders of fundamental
types vary across machines.
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Q2.12 Why is my compiler leaving holes in structures, wasting space and preventing ``binary'' I/O to external data files? Can I turn this off, or otherwise control the alignment of structure fields?</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Additional <a href="http://c-faq.com/struct/align.esr.html">ideas on working with alignment and padding</a> by Eric Raymond, couched in the form of six new FAQ list questions 
</p>

<p>
Corrections to the above from <a href="http://c-faq.com/struct/align.esr2.html">Norm Diamond</a> and <a href="http://c-faq.com/struct/align.esr3.html">Clive Feather</a>
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Q2.14 How can I determine the byte offset of a field within a structure?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
ANSI C defines the <code>offsetof()</code> macro in <code>&lt;stddef.h&gt;</code>, which lets you
compute the offset of field f in struct s as offsetof(struct s, f).
If for some reason you have to code this sort of thing yourself, one
possibility is
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">offsetof</span>(<span style="color: #eedd82;">type</span>, <span style="color: #eedd82;">f</span>) ((<span style="color: #98fb98;">size_t</span>) \
        ((<span style="color: #98fb98;">char</span> *)&amp;((<span style="color: #98fb98;">type</span> *)0)-&gt;f - (<span style="color: #98fb98;">char</span> *)(<span style="color: #98fb98;">type</span> *)0))
</pre>
</div>
<p>
This implementation is not 100% portable; some compilers may
legitimately refuse to accept it.
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Q2.21 Is there an automatic way to keep track of which field of a union is in use?</h3>
<div class="outline-text-3" id="text-2-6">
<p>
No. You can implement an explicitly ``tagged'' union yourself:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">taggedunion</span> {
        <span style="color: #00ffff;">enum</span> {<span style="color: #eedd82;">UNKNOWN</span>, <span style="color: #98fb98;">INT</span>, <span style="color: #98fb98;">LONG</span>, <span style="color: #98fb98;">DOUBLE</span>, <span style="color: #eedd82;">POINTER</span>} <span style="color: #eedd82;">code</span>;
        <span style="color: #00ffff;">union</span> {
                <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
                <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">l</span>;
                <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">d</span>;
                <span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">p</span>;
        } <span style="color: #eedd82;">u</span>;
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Q2.25 I came across some structure declarations with colons and numbers next to certain fields, like this:</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">record</span> {
        <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">name</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">refcount</span> : 4;
        <span style="color: #98fb98;">unsigned</span> <span style="color: #eedd82;">dirty</span> : 1;
};
</pre>
</div>
<p>
What gives?
</p>

<p>
Those are bit-fields; the number gives the exact size of the field,
in bits.
</p>
</div>

<ul class="org-ul"><li><a id="sec-2-7-1" name="sec-2-7-1"></a>Example 1<br  /><div class="outline-text-4" id="text-2-7-1">
<p>
Consider the example of reading the components of a floating-point number. A 4-byte floating-point number in the IEEE 754 standard consists of the following:
</p>

<p>
= The first bit is reserved for the sign bit  it is 1 if the number is negative and 0 if it is positive.
</p>
<ul class="org-ul">
<li>The next 8 bits are used to store the exponent in the unsigned form. When treated as a signed exponent, this exponent value ranges from -127 to +128. When treated as an unsigned value, its value ranges from 0 to 255.
</li>
<li>The remaining 23 bits are used to store the mantissa.
</li>
</ul>

<p>
Here is a program to print the value of a floating-point number into
its constituents:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">FP</span> {
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">the order of the members depends on the</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">endian scheme of the underlying machine</span>
      <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">mantissa</span> : 23;
     <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">exponent</span> : 8;
      <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">sign</span> : 1;
} *<span style="color: #eedd82;">fp</span>;

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
       <span style="color: #98fb98;">float</span> <span style="color: #eedd82;">f</span> = -1.0f;
       fp = (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">FP</span> *)&amp;f;

printf(<span style="color: #ffc0cb; font-weight: bold;">"</span><span style="color: #ffa07a;"> sign = %s, biased exponent = %u,</span>
<span style="color: #ffa07a;">mantissa = %u "</span>, fp-&gt;sign ? <span style="color: #ffa07a;">"negative"</span> : <span style="color: #ffa07a;">"positive"</span>,
fp-&gt;exponent, fp-&gt;mantissa);
}
</pre>
</div>
<p>
For the floating-point number -1.0, this program prints:
</p>

<p>
<code>sign = negative, biased exponent = 127, mantissa = 0</code>
</p>

<p>
Since the sign of the floating-point number is negative, the value of
the sign bit is 1. Since the exponent is actual 0, in unsigned
exponent format, it is represented as 127, and hence that value is
printed. The mantissa in this case is 0, and hence it is printed as it
is.
</p>

<p>
To understand how floating-point arithmetic works, see this <a href="http://en.wikipedia.org/wiki/Single_precision">Wikipedia article</a>.
</p>
</div>
</li>
<li><a id="sec-2-7-2" name="sec-2-7-2"></a>Example 2<br  /><div class="outline-text-4" id="text-2-7-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">bitfield</span> {
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">bit</span> : 1;
} <span style="color: #eedd82;">BIT</span>;
<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span>() {
   BIT.bit = 1;
   printf(<span style="color: #ffa07a;">" sizeof BIT is = %d\n"</span>, <span style="color: #00ffff;">sizeof</span>(BIT));
   printf(<span style="color: #ffa07a;">" value of bit is = %d "</span>, BIT.bit);

}
</pre>
</div>
<p>
It prints:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">sizeof</span> BIT is = 4
value of bit is = -1
</pre>
</div>
<p>
Note that we declared bit as int bit : 1; where the compiler treated the bit to be a signed integer of one bit size. Now, what is the range of a 1-bit signed integer?
</p>

<p>
It is from 0 to -1 (not 0 and 1, which is a common mistake). Remember
the formula for finding out the range of signed integers: 2<sup>(n-1)</sup> to
2<sup>(n-1)</sup>-1 where N is the number of bits. For example, if N is 8 (number
of bits in a byte), i.e., the range of a signed integer of size 8 is
-2<sup>(8-1)</sup> to 2<sup>(8-1)</sup>-1, which is -128 to +127. Now, when N is 1, i.e.,
the range of a signed integer of size 1, it is -2<sup>(1-1)</sup> to 2<sup>(1-1)</sup>-1,
which is -1 to 0!
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">3. Expressions</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Q3.4 Can I use explicit parentheses to force the order of evaluation I want, and control these side effects? Even if I don't, doesn't precedence dictate it?</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Not in general.
</p>

<p>
Operator precedence and explicit parentheses impose only a partial ordering on the evaluation of an expression. In the expression
</p>

<p>
<code>f() + g() * h()</code>
</p>

<p>
although we know that the multiplication will happen before the addition, there is no telling which of the three functions will be called first. In other words, precedence only partially specifies order of evaluation, where ``partially'' emphatically does not cover evaluation of operands.
Parentheses tell the compiler which operands go with which operators; they do not force the compiler to evaluate everything within the parentheses first. Adding explicit parentheses to the above expression to make it
</p>

<p>
<code>f() + (g() * h())</code>
</p>

<p>
would make no difference in the order of the function calls.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Q3.14 Why doesn't the code</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span> = 1000, <span style="color: #eedd82;">b</span> = 1000;
<span style="color: #98fb98;">long</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">c</span> = a * b;
</pre>
</div>
<p>
work?
</p>

<p>
Under C's integral promotion rules, the multiplication is carried out
using int arithmetic, and the result may overflow or be truncated
before being promoted and assigned to the long int left-hand side. Use
an explicit cast on at least one of the operands to force long
arithmetic:
</p>

<p>
<code>long int c = (long int)a * b;</code>
</p>

<p>
or perhaps
</p>

<p>
<code>long int c = (long int)a * (long int)b;</code>
</p>

<p>
(both forms are equivalent).
Notice that the expression <code>(long int)(a * b)</code> would not have the
desired effect. An explicit cast of this form (i.e. applied to the
result of the multiplication) is equivalent to the implicit conversion
which would occur anyway when the value is assigned to the long int
left-hand side, and like the implicit conversion, it happens too late,
after the damage has been done.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Q3.16 I have a complicated expression which I have to assign to one of two variables, depending on a condition. Can I use code like this?</h3>
<div class="outline-text-3" id="text-3-3">
<p>
<code>((condition) ? a : b) = complicated_expression;</code>
</p>

<p>
No. The ?: operator, like most operators, yields a value, and you can't assign to a value. (In other words, ?: does not yield an lvalue.) If you really want to, you can try something like
</p>

<p>
<code>*((condition) ? &amp;a : &amp;b) = complicated_expression;</code>
</p>

<p>
although this is admittedly not as pretty.
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Q3.19 What's the difference between the ``unsigned preserving'' and ``value preserving'' rules?</h3>
<div class="outline-text-3" id="text-3-4">
<p>
These rules concern the behavior when an unsigned type must be
promoted to a ``larger'' type. Should it be promoted to a larger
signed or unsigned type? (To foreshadow the answer, it may depend on
whether the larger type is truly larger.)
</p>

<p>
Under the unsigned preserving (also called ``sign preserving'') rules,
the promoted type is always unsigned. This rule has the virtue of
simplicity, but it can lead to surprises (see the first example
below).
</p>

<p>
Under the value preserving rules, the conversion depends on the actual
sizes of the original and promoted types. If the promoted type is
truly larger&#x2013;which means that it can represent all the values of the
original, unsigned type as signed values&#x2013;then the promoted type is
signed. If the two types are actually the same size, then the promoted
type is unsigned (as for the unsigned preserving rules).
</p>

<p>
Since the actual sizes of the types are used in making the
determination, the results will vary from machine to machine. On some
machines, short int is smaller than int, but on some machines, they're
the same size. On some machines, int is smaller than long int, but on
some machines, they're the same size.
</p>

<p>
In practice, the difference between the unsigned and value preserving
rules matters most often when one operand of a binary operator is (or
promotes to) int and the other one might, depending on the promotion
rules, be either int or unsigned int. If one operand is unsigned int,
the other will be converted to that type&#x2013;almost certainly causing an
undesired result if its value was negative (again, see the first
example below). When the ANSI C Standard was established, the value
preserving rules were chosen, to reduce the number of cases where
these surprising results occur. (On the other hand, the value
preserving rules also reduce the number of predictable cases, because
portable programs cannot depend on a machine's type sizes and hence
cannot know which way the value preserving rules will fall.)
</p>

<p>
Here is a contrived example showing the sort of surprise that can
occur under the unsigned preserving rules:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">short</span> <span style="color: #eedd82;">us</span> = 10;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = -5;
<span style="color: #00ffff;">if</span>(i &gt; us)
        printf(<span style="color: #ffa07a;">"whoops!\n"</span>);
</pre>
</div>
<p>
The important issue is how the expression <code>i &gt; us</code> is evaluated. Under
        the unsigned preserving rules (and under the value preserving
        rules on a machine where short integers and plain integers are
        the same size), us is promoted to unsigned int. The usual
        integral conversions say that when types unsigned int and int
        meet across a binary operator, both operands are converted to
        unsigned, so i is converted to unsigned int, as well. The old
        value of i, -5, is converted to some large unsigned value
        (65,531 on a 16-bit machine). This converted value is greater
        than 10, so the code prints ``whoops!''
</p>

<p>
Under the value preserving rules, on a machine where plain integers
are larger than short integers, us is converted to a plain int (and
retains its value, 10), and i remains a plain int. The expression is
not true, and the code prints nothing. (To see why the values can be
preserved only when the signed type is larger, remember that a value
like 40,000 can be represented as an unsigned 16-bit integer but not
as a signed one.)
</p>


<p>
Unfortunately, the value preserving rules do not prevent all
surprises. The example just presented still prints ``whoops'' on a
machine where short and plain integers are the same size. The value
preserving rules may also inject a few surprises of their
own&#x2013;consider the code:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">uc</span> = 0x80;
<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span> <span style="color: #eedd82;">ul</span> = 0;
ul |= uc &lt;&lt; 8;
printf(<span style="color: #ffa07a;">"0x%lx\n"</span>, ul);
</pre>
</div>
<p>
Before being left-shifted, uc is promoted. Under the unsigned
        preserving rules, it is promoted to an unsigned int, and the
        code goes on to print 0x8000, as expected. Under the value
        preserving rules, however, uc is promoted to a signed int (as
        long as int's are larger than char's, which is usually the
        case). The intermediate result uc &lt;&lt; 8 goes on to meet ul,
        which is unsigned long. The signed, intermediate result must
        therefore be promoted as well, and if int is smaller than
        long, the intermediate result is sign-extended, becoming
        0xffff8000 on a machine with 32-bit longs. On such a machine,
        the code prints 0xffff8000, which is probably not what was
        expected. (On machines where int and long are the same size,
        the code prints 0x8000 under either set of rules.)
</p>

<p>
To avoid surprises (under either set of rules, or due to an unexpected
        change of rules), it's best to avoid mixing signed and
        unsigned types in the same expression, although as the second
        example shows, this rule is not always sufficient. You can
        always use explicit casts to indicate, unambiguously, exactly
        where and how you want conversions performed; see questions
        12.42 and 16.7 for examples. (Some compilers attempt to warn
        you when they detect ambiguous cases or expressions which
        would have behaved differently under the unsigned preserving
        rules, although sometimes these warnings fire too often; see
        also question 3.18.)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">4. Pointers</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Q4.5 I have a char * pointer that happens to point to some ints, and I want to step it over them. Why doesn't</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<code>((int *)p)++;</code>
</p>

<p>
work?
</p>

<p>
In C, a cast operator does not mean ``pretend these bits have a
different type, and treat them accordingly''; it is a conversion
operator, and by definition it yields an rvalue, which cannot be
assigned to, or incremented with ++. (It is either an accident or a
deliberate but nonstandard extension if a particular compiler accepts
expressions such as the above.) Say what you mean: use
</p>

<p>
<code>p = (char *)((int *)p + 1);</code>
</p>

<p>
or (since p is a char *) simply
</p>

<p>
<code>p += sizeof(int);</code>
</p>

<p>
or (to be really explicit)
</p>

<p>
<code>int *ip = (int *)p;</code>
</p>

<p>
<code>p = (char *)(ip + 1);</code> 
</p>

<p>
When possible, however, you should choose appropriate pointer types in
the first place, rather than trying to treat one type as another.
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Q4.9 Suppose I want to write a function that takes a generic pointer as an argument and I want to simulate passing it by reference.</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Can I give the formal parameter type <code>void **</code>, and do something like this?
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f</span>(<span style="color: #98fb98;">void</span> **);
<span style="color: #98fb98;">double</span> *<span style="color: #eedd82;">dp</span>;
f((<span style="color: #98fb98;">void</span> **)&amp;dp);
</pre>
</div>

<p>
Not portably. Code like this may work and is sometimes recommended,
but it relies on all pointer types having the same internal
representation (which is common, but not universal; see question
5.17).
</p>

<p>
There is no generic pointer-to-pointer type in C. <code>void *</code> acts as a
generic pointer only because conversions (if necessary) are applied
automatically when other pointer types are assigned to and from <code>void</code>
*'s; these conversions cannot be performed if an attempt is made to
indirect upon a <code>void **</code> value which points at a pointer type other
than <code>void *</code>. When you make use of a <code>void **</code> pointer value (for
instance, when you use the * operator to access the <code>void *</code> value to
which the void ** points), the compiler has no way of knowing whether
that void * value was once converted from some other pointer type. It
must assume that it is nothing more than a <code>void *</code>; it cannot perform
any implicit conversions.
</p>

<p>
In other words, any <code>void **</code> value you play with must be the address of
an actual <code>void *</code> value somewhere; casts like <code>(void **)&amp;dp</code>, though they
may shut the compiler up, are nonportable (and may not even do what
you want; see also question 13.9). If the pointer that the <code>void **</code>
points to is not a <code>void *</code>, and if it has a different size or
representation than a <code>void *</code>, then the compiler isn't going to be able
to access it correctly.
</p>

<p>
To make the code fragment above work, you'd have to use an
intermediate <code>void *</code> variable:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">double</span> *<span style="color: #eedd82;">dp</span>;
<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">vp</span> = dp;
f(&amp;vp);
dp = vp;
</pre>
</div>
<p>
The assignments to and from vp give the compiler the opportunity to
perform any conversions, if necessary.
</p>

<p>
Again, the discussion so far assumes that different pointer types
might have different sizes or representations, which is rare today,
but not unheard of. To appreciate the problem with void ** more
clearly, compare the situation to an analogous one involving, say,
types int and double, which probably have different sizes and
certainly have different representations. If we have a function
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">incme</span>(<span style="color: #98fb98;">double</span> *<span style="color: #eedd82;">p</span>)
{
        *p += 1;
}
</pre>
</div>
<p>
then we can do something like
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">d</span> = i;
incme(&amp;d);
i = d;
</pre>
</div>
<p>
and <code>i</code> will be incremented by 1. (This is analogous to the correct
void ** code involving the auxiliary vp.) If, on the other hand, we
were to attempt something like
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 1;
incme((<span style="color: #98fb98;">double</span> *)&amp;i);    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">WRONG </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
(this code is analogous to the fragment in the question), it would be
highly unlikely to work.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Q4.10 I have a function</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<code>extern int f(int *);</code>
which accepts a pointer to an int. How can I pass a constant by reference? A call like
<code>f(&amp;5);</code>
doesn't seem to work.
</p>

<p>
In C99, you can use a ``compound literal'':
</p>

<p>
<code>f((int[]){5});</code>
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Q4.12 I've seen different syntax used for calling functions via pointers. What's the story?</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Originally, a pointer to a function had to be ``turned into'' a
``real'' function, with the * operator, before calling:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">r</span>, (*<span style="color: #87cefa;">fp</span>)(), <span style="color: #87cefa;">func</span>();
fp = func;
r = (*fp)();
</pre>
</div>
<p>
The interpretation of the last line is clear: fp is a pointer to
        function, so *fp is the function; append an argument list in
        parentheses (and extra parentheses around *fp to get the
        precedence right), and you've got a function call.
</p>

<p>
It can also be argued that functions are always called via pointers,
and that ``real'' function names always decay implicitly into pointers.
This reasoning means that
</p>


<p>
        <code>r = fp();</code>
is legal and works correctly, whether fp is the name of a function or
a pointer to one. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">5. Null Pointers</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Q5.2 How do I get a null pointer in my programs?</h3>
<div class="outline-text-3" id="text-5-1">
<p>
With a null pointer constant.
</p>

<p>
null pointer constant
</p>

<p>
n. An integral constant expression with value 0 (or such an expression
cast to void *), used to request a null pointer.
</p>

<p>
According to the language definition, an ``integral constant
expression with the value 0'' in a pointer context is converted into a
null pointer at compile time. That is, in an initialization,
assignment, or comparison when one side is a variable or expression of
pointer type, the compiler can tell that a constant 0 on the other
side requests a null pointer, and generate the correctly-typed null
pointer value. Therefore, the following fragments are perfectly legal:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p</span> = 0;
<span style="color: #00ffff;">if</span>(p != 0)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Q5.3 Is the abbreviated pointer comparison ``if(p)'' to test for non-null pointers valid? What if the internal representation for null pointers is nonzero?</h3>
<div class="outline-text-3" id="text-5-2">
<p>
It is always valid.
</p>

<p>
When C requires the Boolean value of an expression, a false value is
inferred when the expression compares equal to zero, and a true value
otherwise. That is, whenever one writes
</p>


<p>
        <code>if(expr)</code>
where ``expr'' is any expression at all, the compiler essentially acts
as if it had been written as
</p>

<p>
        <code>if((expr) != 0)</code>
Substituting the trivial pointer expression ``p'' for ``expr'', we have
        <code>if(p)	is equivalent to	if(p != 0)</code>
and this is a comparison context, so the compiler can tell that the
(implicit) 0 is actually a null pointer constant, and use the correct
null pointer value. There is no trickery involved here; compilers do
work this way, and generate identical code for both constructs. The
internal representation of a null pointer does not matter.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Q5.5  How should NULL be defined on a machine which uses a nonzero bit pattern as the internal representation of a null pointer?</h3>
<div class="outline-text-3" id="text-5-3">
<p>
The same as on any other machine: as 0 (or some version of 0; see
question 5.4).
</p>

<p>
Whenever a programmer requests a null pointer, either by writing ``0''
or ``NULL'', it is the compiler's responsibility to generate whatever
bit pattern the machine uses for that null pointer. (Again, the
compiler can tell that an unadorned 0 requests a null pointer when the
0 is in a pointer context; see question 5.2.) Therefore, #defining
<code>NULL</code> as 0 on a machine for which internal null pointers are nonzero is
as valid as on any other: the compiler must always be able to generate
the machine's correct null pointers in response to unadorned 0's seen
in pointer contexts. A constant 0 is a null pointer constant; NULL is
just a convenient name for it (see also question 5.13).
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Q5.15 I'm confused. I just can't understand all this null pointer stuff.</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Here are two simple rules you can follow:
</p>

<ol class="org-ol">
<li>When you want a null pointer constant in source code, use ``0'' or ``NULL''.
</li>
<li>If the usage of ``0'' or ``NULL'' is an argument in a function
call, cast it to the pointer type expected by the function being
called. Strictly speaking, casts on pointer arguments are only
required in function calls without prototypes in scope, and in the
variable-length part of variable-length argument lists.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Q5.18 Is a run-time integral value of 0, cast to a pointer, guaranteed to be a null pointer?</h3>
<div class="outline-text-3" id="text-5-5">
<p>
No. Only <i>constant</i> integral expressions with value 0 are guaranteed to
indicate null pointers. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">6. Arrays and Pointers</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Q6.5 Why can't I do something like this?</h3>
<div class="outline-text-3" id="text-6-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">extern</span> <span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">getpass</span>();
<span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[10];
str = getpass(<span style="color: #ffa07a;">"Enter password: "</span>);
</pre>
</div>

<p>
Arrays are ``second-class citizens'' in C; one upshot of this
prejudice is that you cannot assign to them . When you need to copy
the contents of one array to another, you must do so explicitly. In
the case of char arrays, the strcpy routine is usually appropriate:
</p>

<p>
<code>strcpy(str, getpass("Enter password: "));</code>
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Q6.7 How can an array be an lvalue, if you can't assign to it?</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The term ``lvalue'' doesn't quite mean ``something you can assign
to''; a better definition is ``something that has a location (in
memory).'' The ANSI/ISO C Standard goes on to define a
``modifiable lvalue''; an array is not a modifiable lvalue
</p>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Q6.8 Practically speaking, what is the difference between arrays and pointers?</h3>
<div class="outline-text-3" id="text-6-3">
<p>
An array is a single, preallocated chunk of contiguous elements (all
of the same type), fixed in size and location. A pointer is a
reference to any data element (of a particular type) anywhere. A
pointer must be assigned to point to space allocated elsewhere, but it
can be reassigned (and the space, if derived from malloc, can be
resized) at any time. A pointer can point to an array, and can
simulate (along with malloc) a dynamically allocated array, but a
pointer is a much more general data structure.
</p>

<p>
Due to the so-called equivalence of arrays and pointers, arrays and
pointers often seem interchangeable, and in particular a pointer to a
block of memory assigned by malloc is frequently treated (and can be
referenced using []) exactly as if it were a true array. 
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Q6.11 I came across some ``joke'' code containing the ``expression'' 5["abcdef"] . How can this be legal C?</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Yes, Virginia, array subscripting is commutative in C.  This curious
fact follows from the pointer definition of array subscripting, namely
that <code>a[e]</code> is identical to <code>*((a)+(e))</code>, for any two expressions a and e,
as long as one of them is a pointer expression and one is integral.
The ``proof'' looks like
</p>
<div class="org-src-container">

<pre class="src src-c">a[e]
*((a) + (e))    (<span style="color: #98fb98;">by</span> <span style="color: #eedd82;">definition</span>)
*((e) + (a))    (<span style="color: #98fb98;">by</span> commutativity <span style="color: #98fb98;">of</span> <span style="color: #eedd82;">addition</span>)
e[a]            (<span style="color: #98fb98;">by</span> <span style="color: #eedd82;">definition</span>)
</pre>
</div>
<p>
This unsuspected commutativity is often mentioned in C texts as if it
were something to be proud of, but it finds no useful application
outside of the Obfuscated C Contest.
</p>

<p>
Since strings in C are arrays of char, the expression "abcdef"[ 5] is
perfectly legal, and evaluates to the character 'f'. You can think of
it as a shorthand for 
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">tmpptr</span> = <span style="color: #ffa07a;">"abcdef"</span>;
... tmpptr[5] ...
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Q6.13 How do I declare a pointer to an array?</h3>
<div class="outline-text-3" id="text-6-5">
<p>
If you really need to declare a pointer to an entire array, use
something like ``int (*ap)[N];'' where N is the size of the array.
If the size of the array is unknown, N can in principle be omitted,
but the resulting type, ``pointer to array of unknown size,'' is
useless.
</p>

<p>
Here is an example showing the difference between simple pointers and
pointers to arrays. Given the declarations
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a1</span>[3] = {0, 1, 2};
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a2</span>[2][3] = {{3, 4, 5}, {6, 7, 8}};
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">ip</span>;                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to int </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">ap</span>)[3];           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">pointer to array [3] of int </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
you could use the simple pointer-to-int, ip, to access the one-dimensional array a1:
</p>
<div class="org-src-container">

<pre class="src src-c">        ip = a1;
        printf(<span style="color: #ffa07a;">"%d "</span>, *ip);
        ip++;
        printf(<span style="color: #ffa07a;">"%d\n"</span>, *ip);

This fragment <span style="color: #98fb98;">would</span> <span style="color: #eedd82;">print</span>
        0 1
</pre>
</div>
<p>
An attempt to use a pointer-to-array, ap, on a1:
</p>
<div class="org-src-container">

<pre class="src src-c">ap = &amp;a1;
printf(<span style="color: #ffa07a;">"%d\n"</span>, **ap);
ap++;                           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">WRONG </span><span style="color: #ff7f24;">*/</span>
printf(<span style="color: #ffa07a;">"%d\n"</span>, **ap);           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">undefined </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
would print 0 on the first line and something undefined on the second
(and might crash). The pointer-to-array would only be at all useful in
accessing an array of arrays, such as a2:
</p>

<div class="org-src-container">

<pre class="src src-c">        ap = a2;
        printf(<span style="color: #ffa07a;">"%d %d\n"</span>, (*ap)[0], (*ap)[1]);
        ap++;           <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">steps over entire (sub)array </span><span style="color: #ff7f24;">*/</span>
        printf(<span style="color: #ffa07a;">"%d %d\n"</span>, (*ap)[0], (*ap)[1]);

This last fragment <span style="color: #98fb98;">would</span> <span style="color: #eedd82;">print</span>
        3 4
        6 7
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">Q6.16 How can I dynamically allocate a multidimensional array?</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The traditional solution is to allocate an array [footnote] of
pointers to pointers, and then initialize each pointer to a
dynamically-allocated ``row.'' Here is a two-dimensional example:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array1</span> = malloc(nrows * <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span> *));
<span style="color: #00ffff;">for</span>(i = 0; i &lt; nrows; i++)
        array1[i] = malloc(ncolumns * <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
</pre>
</div>
<p>
(In real code, of course, all of malloc's return values would be
        checked. You can also use <code>sizeof(*array1)</code> and <code>sizeof(**array1)</code>
        instead of <code>sizeof(int *)</code> and <code>sizeof(int)</code>;)
</p>

<p>
You can keep the array's contents contiguous, at the cost of making
later reallocation of individual rows more difficult, with a bit of
explicit pointer arithmetic:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array2</span> = malloc(nrows * <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span> *));
array2[0] = malloc(nrows * ncolumns * <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
<span style="color: #00ffff;">for</span>(i = 1; i &lt; nrows; i++)
        array2[i] = array2[0] + i * ncolumns;
</pre>
</div>
<p>
In either case (i.e for array1 or array2), the elements of the dynamic
        array can be accessed with normal-looking array subscripts:
        <code>arrayx[i][j]</code> (for 0 &lt;= i &lt; nrows and 0 &lt;= j &lt; ncolumns). Here
        is a schematic illustration of the layout of array1 and
        array2: 
<i>array1.gif</i>
<i>array2.gif</i>
</p>

<p>
If the double indirection implied by the above schemes is for some
reason unacceptable,[footnote] you can simulate a two-dimensional
array with a single, dynamically-allocated one-dimensional array:
</p>

<p>
<code>int *array3 = malloc(nrows * ncolumns * sizeof(int));</code>
</p>

<p>
However, you must now perform subscript calculations manually, accessing the i,jth element with the expression
</p>

<p>
<code>array3[i * ncolumns + j]</code>
and this array cannot necessarily be passed to functions which expect
multidimensional arrays. (A macro such as
</p>

<p>
<code>#define Arrayaccess(a, i, j) ((a)[(i) * ncolumns + (j)])</code>
</p>

<p>
could hide the explicit calculation, but invoking it would require
parentheses and commas which wouldn't look exactly like conventional C
multidimensional array syntax, and the macro would need access to at
least one of the dimensions, as well.)
</p>

<p>
Yet another option is to use pointers to arrays:
</p>

<p>
<code>int (*array4)[NCOLUMNS] = malloc(nrows * sizeof(*array4));</code>
</p>

<p>
or even
        <code>int (*array5)[NROWS][NCOLUMNS] = malloc(sizeof(*array5));</code>
</p>

<p>
but the syntax starts getting horrific (accesses to array5 look like
<code>(*array5)[i][j])</code>, and at most one dimension may be specified at run
time.
</p>

<p>
With all of these techniques, you may of course need to remember to
free the arrays when they are no longer needed; in the case of array1
and array2 this takes several steps:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">for</span>(i = 0; i &lt; nrows; i++)
        free((<span style="color: #98fb98;">void</span> *)array1[i]);
free((<span style="color: #98fb98;">void</span> *)array1);

free((<span style="color: #98fb98;">void</span> *)array2[0]);
free((<span style="color: #98fb98;">void</span> *)array2);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7">Q6.20 How can I use statically- and dynamically-allocated multidimensional arrays interchangeably when passing them to functions?</h3>
<div class="outline-text-3" id="text-6-7">
<p>
There is no single perfect method. Given the declarations
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[NROWS][NCOLUMNS];
<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array1</span>;                   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">ragged </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">array2</span>;                   <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">contiguous </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">array3</span>;                    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">"flattened" </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">array4</span>)[NCOLUMNS];

<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">array5</span>)[NROWS][NCOLUMNS];
</pre>
</div>
<p>
with the pointers initialized as in the code fragments in question
6.16, and functions declared as
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f1a</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[][NCOLUMNS], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nrows</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ncolumns</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f1b</span>(<span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">a</span>)[NCOLUMNS], <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nrows</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ncolumns</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f2</span>(<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">aryp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nrows</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ncolumns</span>);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">f3</span>(<span style="color: #98fb98;">int</span> **<span style="color: #eedd82;">pp</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">nrows</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ncolumns</span>);
</pre>
</div>
<p>
where f1a and f1b accept conventional two-dimensional arrays, f2
accepts a ``flattened'' two-dimensional array, and f3 accepts a
pointer-to-pointer, simulated array, the following calls should work
as expected:
</p>
<div class="org-src-container">

<pre class="src src-c">f1a(array, NROWS, NCOLUMNS);
f1b(array, NROWS, NCOLUMNS);
f1a(array4, nrows, NCOLUMNS);
f1b(array4, nrows, NCOLUMNS);

f1(*array5, NROWS, NCOLUMNS);

f2(&amp;array[0][0], NROWS, NCOLUMNS);
f2(*array, NROWS, NCOLUMNS);
f2(*array2, nrows, ncolumns);
f2(array3, nrows, ncolumns);
f2(*array4, nrows, NCOLUMNS);

f2(**array5, NROWS, NCOLUMNS);

f3(array1, nrows, ncolumns);
f3(array2, nrows, ncolumns);
</pre>
</div>
<p>
The following calls would probably work on most systems, but involve
        questionable casts, and work only if the dynamic ncolumns
        matches the static NCOLUMNS:
</p>
<div class="org-src-container">

<pre class="src src-c">f1a((<span style="color: #98fb98;">int</span> (*)[NCOLUMNS])(*array2), nrows, ncolumns);
f1a((<span style="color: #98fb98;">int</span> (*)[NCOLUMNS])(*array2), nrows, ncolumns);
f1b((<span style="color: #98fb98;">int</span> (*)[NCOLUMNS])array3, nrows, ncolumns);
f1b((<span style="color: #98fb98;">int</span> (*)[NCOLUMNS])array3, nrows, ncolumns);
</pre>
</div>
<p>
It will be noticed that only f2 can conveniently be made to work with
        both statically- and dynamically-allocated arrays, though it
        will not work with the traditional ``ragged'' array
        implementation, array1. However, it must also be noted that
        passing <code>&amp;array[0][0]</code> (or, equivalently, *array) to f2 is not
        strictly conforming; see question 6.19.
</p>

<p>
If you can understand why all of the above calls work and are written
as they are, and if you understand why the combinations that are not
listed would not work, then you have a very good understanding of
arrays and pointers in C.
</p>
</div>
</div>

<div id="outline-container-sec-6-8" class="outline-3">
<h3 id="sec-6-8">Q6.23 I want to know how many elements are in an array, but sizeof yields the size in bytes.</h3>
<div class="outline-text-3" id="text-6-8">
<p>
Simply divide the size of the entire array by the size of one element:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">array</span>[] = {1, 2, 3};
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">narray</span> = <span style="color: #00ffff;">sizeof</span>(array) / <span style="color: #00ffff;">sizeof</span>(array[0]);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">7. Memory Allocation</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Q7.5a and Q7.5b</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The difference between:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">itoa</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
{
        <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">retbuf</span>[20];                <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">WRONG </span><span style="color: #ff7f24;">*/</span>
        sprintf(retbuf, <span style="color: #ffa07a;">"%d"</span>, n);
        <span style="color: #00ffff;">return</span> retbuf;                  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">WRONG </span><span style="color: #ff7f24;">*/</span>
}
</pre>
</div>
<p>
and
</p>
<div class="org-src-container">

<pre class="src src-c">        <span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">itoa</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>)
        {
                <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">retbuf</span> = malloc(20);
                <span style="color: #00ffff;">if</span>(retbuf != <span style="color: #7fffd4;">NULL</span>)
                        sprintf(retbuf, <span style="color: #ffa07a;">"%d"</span>, n);
                <span style="color: #00ffff;">return</span> retbuf;
        }
...
        <span style="color: #98fb98;">char</span> *str = itoa(123);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Q7.14 I've heard that some operating systems don't actually allocate malloc'ed memory until the program tries to use it. Is this legal?</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Lazy initialization
</p>

<p>
Allocate-on-flush (also called delayed allocation) is a computer file
system feature implemented in the HFS+, XFS, Reiser4, ZFS, Btrfs
and ext4 file systems. The feature also closely resembles an older
technique that Berkeley's UFS called "block reallocation".<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>

<p>
This has the effect of batching together allocations into larger runs.
Such delayed processing reduces CPU usage, and tends to reduce disk
fragmentation, especially for files which grow slowly. It can also
help in keeping allocations contiguous when there are several files
growing at the same time. When used in conjunction with copy on write
as it is in ZFS, it can convert slow random writes into fast
sequential writes.
</p>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">Q7.28 Why doesn't sizeof tell me the size of the block of memory pointed to by a pointer?</h3>
<div class="outline-text-3" id="text-7-3">
<p>
sizeof tells you the size of the pointer. There is no portable way to
find out the size of a malloc'ed block. (Remember, too, that sizeof
operates at compile time).
</p>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Q7.29 Having dynamically allocated an array (as in question 6.14), can I change its size?</h3>
<div class="outline-text-3" id="text-7-4">
<p>
If <code>realloc</code> cannot find enough space at all, it returns a null pointer,
and leaves the previous region allocated. [footnote] Therefore, you
usually don't want to immediately assign the new pointer to the old
variable. Instead, use a temporary pointer:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>

<span style="color: #98fb98;">int</span> *<span style="color: #eedd82;">newarray</span> = (<span style="color: #98fb98;">int</span> *)realloc((<span style="color: #98fb98;">void</span> *)dynarray, 20 * <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>));
<span style="color: #00ffff;">if</span>(newarray != <span style="color: #7fffd4;">NULL</span>)
        dynarray = newarray;
<span style="color: #00ffff;">else</span> {
        fprintf(stderr, <span style="color: #ffa07a;">"Can't reallocate memory\n"</span>);
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">dynarray remains allocated </span><span style="color: #ff7f24;">*/</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">8. Characters and Strings</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Q8.1 Why doesn't</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<code>strcat(string, '!');</code>
work?
</p>

<p>
There is a very real difference between characters and strings, and
strcat concatenates strings
</p>

<p>
<code>strcat(string, "!");</code>
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Q8.8 I'm reading strings typed by the user into an array, and then printing them out later. When the user types a sequence like \n, why isn't it being handled properly?</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Character sequences like \n are interpreted at compile time. When a
backslash and an adjacent n appear in a character constant or string
literal, they are translated immediately into a single newline
character. (Analogous translations occur, of course, for the other
character escape sequences.) When you're reading strings from the user
or a file, however, no interpretation like this is performed: a
backslash is read and printed just like any other character, with no
particular interpretation.
</p>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Q8.9 I think something's wrong with my compiler: I just noticed that <code>sizeof('a')</code> is 2, not 1 (i.e. not <code>sizeof(char)</code>).</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Perhaps surprisingly, character constants in C are of type int, so
<code>sizeof('a')</code> is <code>sizeof(int)</code> (though this is another area where C++
differs).
</p>

<p>
The point is that character constants are not of type char!
sizeof(char) is 1, while sizeof(int) is 2 or 4 on most machines. Now,
a constant like 'a', even though it looks like a character, is
actually an integer as far as the compiler is concerned, so
sizeof('a') == sizeof(int). 
</p>

<p>
It's only confusing if you assume that character constants are chars.
It makes perfect sense if you know the rule that ``character constants
are of type int'', even if that rule doesn't seem to make much sense
in itself.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">10. C Preprocessor</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Q10.3 How can I write a generic macro to swap two values?</h3>
<div class="outline-text-3" id="text-9-1">
<p>
If you believe you have found a better solution to this problem, ask yourself:
</p>
<ul class="org-ul">
<li>Will it work on operands which are variables stored in registers? (That is, does it attempt to take the address of either of its operands?)
</li>
<li>If it uses a temporary variable, what if the name of the temporary variable matches the name of one of the operands (or matches in the first 32 characters)?
</li>
<li>Will it work if the operands are lvalue expressions (e.g. a[i])?
</li>
<li>If it works on operands of only one type (or if it requires the caller to specify the type) is it truly generic?
</li>
<li>Will it work in the limiting case of trying to swap something with itself?
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">Q10.4 What's the best way to write a multi-statement macro?</h3>
<div class="outline-text-3" id="text-9-2">
<p>
The traditional solution, therefore, is to use
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">MACRO</span>(<span style="color: #eedd82;">arg1</span>, <span style="color: #eedd82;">arg2</span>) <span style="color: #00ffff;">do</span> {  \
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">declarations </span><span style="color: #ff7f24;">*/</span>      \
        stmt1;                  \
        stmt2;                  \
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">... </span><span style="color: #ff7f24;">*/</span>               \
        } <span style="color: #00ffff;">while</span>(0)      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">(no trailing ; ) </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
When the caller appends a semicolon, this expansion becomes a single
statement regardless of context.
</p>
</div>
</div>

<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Q10.5b What's the difference between</h3>
<div class="outline-text-3" id="text-9-3">
<p>
<code>const MAXSIZE = 100;</code>
and
<code>#define MAXSIZE 100</code>
</p>

<p>
A preprocessor <code>#define</code> gives you a true compile-time constant. In C,
const gives you a run-time object which you're not supposed to try to
modify; ``const'' really means ``readonly''.
</p>
</div>
</div>

<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">Q10.7 Is it acceptable for one header file to #include another?</h3>
<div class="outline-text-3" id="text-9-4">
<p>
a popular trick along the lines of:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#if</span><span style="color: #b0c4de;">n</span><span style="color: #b0c4de;">def</span> HFILENAME_USED
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">HFILENAME_USED</span>
...header file contents...
<span style="color: #b0c4de;">#endif</span>
</pre>
</div>
<p>
(where a different bracketing macro name is used for each header file)
makes a header file ``idempotent'' so that it can safely be #included
multiple times; 
</p>
</div>
</div>





<div id="outline-container-sec-9-5" class="outline-3">
<h3 id="sec-9-5">Q10.12 How can I construct preprocessor #if expressions which compare strings?</h3>
<div class="outline-text-3" id="text-9-5">
<p>
You can't do it directly; <b>preprocessor #if arithmetic uses only
integers</b>. An alternative is to #define several macros with symbolic
names and distinct integer values, and implement conditionals on
those:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">RED</span>     1
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">BLUE</span>    2
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">GREEN</span>   3

<span style="color: #b0c4de;">#if</span> COLOR == RED
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">red case </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;">#if</span> COLOR == BLUE
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">blue case </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #b0c4de;">#if</span> COLOR == GREEN
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">green case </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#else</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">default case </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#endif</span>
</pre>
</div>
<p>
(Standard C specifies a new #elif directive which makes if/else chains
like these a bit cleaner.)
</p>
</div>
</div>

<div id="outline-container-sec-9-6" class="outline-3">
<h3 id="sec-9-6">Q10.13 Does the sizeof operator work in preprocessor #if directives?</h3>
<div class="outline-text-3" id="text-9-6">
<p>
   No. Preprocessing happens during an earlier phase of compilation,
before type names have been parsed. Instead of sizeof, consider using
the predefined constants in ANSI's <code>&lt;limits.h&gt;</code>, if applicable, or
perhaps a ``configure'' script.
</p>

<p>
The C89 standard divides translation into eight ``phases''. C99 keeps
the same phases and just adds Unicode and the like. I will quote an
old C99 draft below (with some small edits for text representation).
Read <a href="#phases">footnote</a> carefully, and then consider the fact that ``#if''
happens in phase 4, but pp-tokens are not converted to regular tokens
until phase 7. Since the ``sizeof'' keyword is a regular token rather
than a pp-token, that makes it impossible for ``#if'' to recognize it.
In fact, the line:
</p>

<p>
<code># if ((sizeof aszColors / sizeof *aszColors) != COLOR_NB)</code>
</p>

<p>
must (in the absence of various #defines) behave as if it read:
</p>

<p>
<code># if ((0 0 / 0 *0) != 0)</code>
</p>

<p>
so a diagnostic is required (because ``0 0'' is a syntax error).
</p>

<p>
#<a id="phases" name="phases"></a> 
The precedence among the syntax rules of translation is specified by
the following phases.
</p>

<p>
<code>1.</code>
Physical source file multibyte characters are mapped to the source
character set (introducing new-line characters for end-of-line
indicators) if necessary. Any multibyte source file character not in
the basic source character set is replaced by the
universal-character-name that designates that multibyte character.<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>
Then, trigraph sequences are replaced by corresponding
single-character internal representations.
</p>

<p>
<code>2.</code>
Each instance of a backslash character immediately followed by a newline character is deleted, splicing physical source lines to form logical source lines. Only the last backslash on any physical source line shall be eligible for being part of such a splice. A source file that is not empty shall end in a new-line character, which shall not be immediately preceded by a backslash character before any such splicing takes place.
</p>

<p>
<code>3.</code> 
The source file is decomposed into preprocessing tokens<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup> and sequences of white-space characters (including comments). A source file shall not end in a partial preprocessing token or comment. Each comment is replaced by one space character. New-line characters are retained. Whether each nonempty sequence of white-space characters other than new-line is retained or replaced by one space character is implementation-defined.
</p>

<p>
<code>4.</code>
Preprocessing directives are executed, macro invocations are expanded, and pragma unary operator expressions are executed. If a character sequence that matches the syntax of a universal-character-name is produced by token concatenation (6.8.3.3), the behavior is undefined. A #include preprocessing directive causes the named header or source file to be processed from phase 1 through phase 4, recursively. All preprocessing directives are then deleted.
</p>

<p>
<code>5.</code>
Each source character set member, escape sequence, and universal-character-name in character constants and string literals is converted to a member of the execution character set.
</p>

<p>
<code>6.</code>
Adjacent character string literal tokens are concatenated and adjacent wide string literal tokens are concatenated.
</p>

<p>
<code>7.</code>
White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.
</p>

<p>
<code>9.</code>
All external object and function references are resolved. Library components are linked to satisfy external references to functions and objects not defined in the current translation. All such translator output is collected into a program image which contains information needed for execution in its execution environment.
</p>

<p>
_________<sub>[footnotes</sub> 5 through 7]
</p>

<p>
<code>5.</code>
Implementations must behave as if these separate phases occur, even though many are typically folded together in practice.
</p>

<p>
<code>6.</code>
The process of handling extended characters is specified in terms of mapping to an encoding that uses only the basic source character set, and, in the case of character literals and strings, further mapping to the execution character set. In practical terms, however, any internal encoding may be used, so long as an actual extended character encountered in the input, and the same extended character expressed in the input as a universal-character-name (i.e., using the \U or \u notation), are handled equivalently.
</p>

<p>
<code>7.</code>
As described in 6.1, the process of dividing a source file's
characters into preprocessing tokens is context-dependent. For
example, see the handling of &lt; within a #include preprocessing
directive.
</p>
</div>
</div>

<div id="outline-container-sec-9-7" class="outline-3">
<h3 id="sec-9-7">Q10.15 Is there anything like an #ifdef for typedefs?</h3>
<div class="outline-text-3" id="text-9-7">
<p>
Unfortunately, no. (There can't be, because types and typedefs haven't
been parsed at preprocessing time.) You may have to keep sets of
preprocessor macros (e.g. MY<sub>TYPE</sub><sub>DEFINED</sub>) recording whether certain
typedefs have been declared.
</p>
</div>
</div>
<div id="outline-container-sec-9-8" class="outline-3">
<h3 id="sec-9-8">Q10.16 How can I use a preprocessor #if expression to tell whether a machine's byte order is big-endian or little-endian?</h3>
<div class="outline-text-3" id="text-9-8">
<p>
You probably can't. The usual techniques for detecting endianness
involve pointers or arrays of char, or maybe unions, but preprocessor
arithmetic uses only long integers, and there is no concept of
addressing. Another tempting possibility is something like
</p>

<p>
<code>#if 'ABCD' == 0x41424344</code>
</p>

<p>
but this isn't reliable, either. At any rate, the integer formats used
in preprocessor #if expressions are not necessarily the same as those
that will be used at run time.
</p>
</div>
</div>
<div id="outline-container-sec-9-9" class="outline-3">
<h3 id="sec-9-9">Q10.19 How can I list all of the predefined identifiers?</h3>
<div class="outline-text-3" id="text-9-9">
<p>
There's no standard way, although it is a common need. <code>gcc</code> provides a
<code>-dM</code> option which works with <code>-E</code>.
</p>

<p>
Here is what I believe is what Gisbert Selke described as ``Cave
Newt's shell script `defines' which undertakes a valiant approach at
finding out.
</p>

<p>
<a href="./what-defs.sh">what-defs.sh</a>
</p>
</div>
</div>
<div id="outline-container-sec-9-10" class="outline-3">
<h3 id="sec-9-10">Q10.20 I have some old code that tries to construct identifiers with a macro like</h3>
<div class="outline-text-3" id="text-9-10">
<p>
<code>#define Paste(a, b) a/**/b</code>
but it doesn't work any more.
</p>

<p>
However, since the need for pasting tokens was demonstrated and real, ANSI introduced a well-defined token-pasting operator, ##, which can be used like this:
</p>

<p>
<code>#define Paste(a, b) a##b</code>
</p>
</div>
</div>
<div id="outline-container-sec-9-11" class="outline-3">
<h3 id="sec-9-11">Q10.27 How can I include expansions of the <span class="underline"><span class="underline">FILE</span></span> and <span class="underline"><span class="underline">LINE</span></span> macros in a general-purpose debugging macro?</h3>
<div class="outline-text-3" id="text-9-11">
<p>
One solution involves writing your debug macro in terms of a varargs
function, and an auxiliary function which stashes the values of
<span class="underline"><span class="underline">FILE</span></span> and <span class="underline"><span class="underline">LINE</span></span> away in static variables, as in:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdarg.h&gt;</span>

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">debug</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *, ...);
<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dbginfo</span>(<span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *);
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">DEBUG</span> dbginfo(__LINE__, __FILE__), debug

<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dbgfile</span>;
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">dbgline</span>;

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">dbginfo</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">line</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">file</span>)
{
        dbgfile = file;
        dbgline = line;
}

<span style="color: #98fb98;">void</span> <span style="color: #87cefa;">debug</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">fmt</span>, ...)
{
        <span style="color: #98fb98;">va_list</span> <span style="color: #eedd82;">argp</span>;
        fprintf(stderr, <span style="color: #ffa07a;">"DEBUG: \"%s\", line %d: "</span>, dbgfile, dbgline);
        va_start(argp, fmt);
        vfprintf(stderr, fmt, argp);
        va_end(argp);
        fprintf(stderr, <span style="color: #ffa07a;">"\n"</span>);
}
</pre>
</div>
<p>
With this machinery in place, a call to
</p>
<div class="org-src-container">

<pre class="src src-c">DEBUG(<span style="color: #ffa07a;">"i is %d"</span>, i);
</pre>
</div>
<p>
expands to
</p>
<div class="org-src-container">

<pre class="src src-c">dbginfo(__LINE__, __FILE__), debug(<span style="color: #ffa07a;">"i is %d"</span>, i);
</pre>
</div>
<p>
and prints something like
</p>
<div class="org-src-container">

<pre class="src src-sh">DEBUG: <span style="color: #ffa07a;">"x.c"</span>, line 10: i is 42
</pre>
</div>
<p>
A cunning improvement is the idea of having the stashing function
return a pointer to the bona-fide varargs function:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">debug</span>(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *, ...);
<span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">dbginfo</span>(<span style="color: #98fb98;">int</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *))(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *, ...);
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">DEBUG</span> (*dbginfo(__LINE__, __FILE__))

<span style="color: #98fb98;">void</span> (*<span style="color: #87cefa;">dbginfo</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">line</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">file</span>))(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> *, ...)
{
        dbgfile = file;
        dbgline = line;
        <span style="color: #00ffff;">return</span> debug;
}
</pre>
</div>
<p>
With these definitions,
</p>
<div class="org-src-container">

<pre class="src src-c">DEBUG(<span style="color: #ffa07a;">"i is %d"</span>, i);
</pre>
</div>
<p>
gets expanded to
</p>
<div class="org-src-container">

<pre class="src src-c">(*dbginfo(__LINE__, __FILE__))(<span style="color: #ffa07a;">"i is %d"</span>, i);
</pre>
</div>
<p>
Another, perhaps easier way might simply be to
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">DEBUG</span> printf(<span style="color: #ffa07a;">"DEBUG: \"%s\", line %d: "</span>, \
        __FILE__,__LINE__),printf
</pre>
</div>
<p>
Now,
        <code>DEBUG("i is %d", i);</code>
simply expands to
</p>
<div class="org-src-container">

<pre class="src src-c">printf(<span style="color: #ffa07a;">"DEBUG: \"%s\", line %d: "</span>,
        __FILE__,__LINE__),printf(<span style="color: #ffa07a;">"i is %d"</span>, i);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">11. ANSI/ISO Standard C</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Q11.8 I don't understand why I can't use const values in initializers and array dimensions, as in</h3>
<div class="outline-text-3" id="text-10-1">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span> = 5;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">a</span>[n];
</pre>
</div>

<p>
The <code>const</code> qualifier really means ``read-only''; an object so qualified
is a run-time object which cannot (normally) be assigned to. The value
of a const-qualified object is therefore not a constant expression in
the full sense of the term, and cannot be used for array dimensions,
case labels, and the like. (C is unlike C++ in this regard.) When you
need a true compile-time constant, use a preprocessor #define (or
perhaps an enum).
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">Q11.9 What's the difference between const char *p, char const *p, and char * const p?</h3>
<div class="outline-text-3" id="text-10-2">
<p>
The first two are interchangeable; they declare a pointer to a
constant character (you can't change any pointed-to characters).
<code>char * const p</code> declares a constant pointer to a (variable) character
(i.e. you can't change the pointer).
</p>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">Q11.10 Why can't I pass a char <b>* to a function which expects a const char *</b>?</h3>
<div class="outline-text-3" id="text-10-3">
<p>
You can use a pointer-to-T (for any type T) where a
pointer-to-const-T is expected. However, the rule (an explicit
exception) which permits slight mismatches in qualified pointer types
is not applied recursively, but only at the top level. (const char **
is pointer-to-pointer-to-const-char, and the exception therefore does
not apply.)
</p>

<p>
The reason that you cannot assign a char <b>* value to a const char *</b>
pointer is somewhat obscure. Given that the const qualifier exists at
all, the compiler would like to help you keep your promises not to
modify const values. That's why you can assign a char * to a const
char *, but not the other way around: it's clearly safe to ``add''
const-ness to a simple pointer, but it would be dangerous to take it
away. However, suppose you performed the following more complicated
series of assignments:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">c</span> = <span style="color: #ffa07a;">'x'</span>;             <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">1 </span><span style="color: #ff7f24;">*/</span>
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">p1</span>;                       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">2 </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">char</span> **<span style="color: #eedd82;">p2</span> = &amp;p1;          <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">3 </span><span style="color: #ff7f24;">*/</span>
*p2 = &amp;c;                       <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">4 </span><span style="color: #ff7f24;">*/</span>
*p1 = <span style="color: #ffa07a;">'X'</span>;                      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">5 </span><span style="color: #ff7f24;">*/</span>
</pre>
</div>
<p>
In line 3, we assign a <code>char **</code> to a <code>const char **</code>. (The compiler
should complain.) In line 4, we assign a <code>const char *</code> to a <code>const
char *</code>; this is clearly legal. In line 5, we modify what a <code>char *</code> points
to&#x2013;this is supposed to be legal. However, p1 ends up pointing to c,
which is const. This came about in line 4, because <code>*p2</code> was really <code>p1</code>.
This was set up in line 3, which is an assignment of a form that is
disallowed, and this is exactly why line 3 is disallowed.
</p>

<p>
Assigning a <code>char **</code> to a <code>const char **</code> (as in line 3, and in the
original question) is not immediately dangerous. But it sets up a
situation in which p2's promise&#x2013;that the ultimately-pointed-to value
won't be modified&#x2013;cannot be kept.
</p>

<p>
(C++ has more complicated rules for assigning const-qualified pointers
which let you make more kinds of assignments without incurring
warnings, but still protect against inadvertent attempts to modify
const values. C++ would still not allow assigning a char <b>* to a const
char *</b>, but it would let you get away with assigning a char ** to a
const char * const *.)
</p>

<p>
In C, if you must assign or pass pointers which have qualifier
mismatches at other than the first level of indirection, you must use
explicit casts (e.g. (const char **) in this case), although as
always, the need for such a cast may indicate a deeper problem which
the cast doesn't really fix.
</p>
</div>
</div>

<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">Q11.11 I've got the declarations</h3>
<div class="outline-text-3" id="text-10-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">char</span> *<span style="color: #98fb98;">charp</span>;
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">charp</span> <span style="color: #eedd82;">p</span>;
</pre>
</div>
<p>
Why is p turning out const, instead of the characters pointed to?
</p>

<p>
typedef substitutions are not purely textual. (This is one of the
advantages of typedefs; see question 1.13.) In the declaration
</p>

<p>
<code>const charp p;</code>
</p>

<p>
p is const for the same reason that <code>const int i</code> declares i as const.
The typedef'ed declaration of p does not ``look inside'' the typedef
to see that there is a pointer involved.
</p>
</div>
</div>

<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">Q11.16  Is exit(status) truly equivalent to returning the same status from main?</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Yes and no. The Standard says that a return from the initial call to
main is equivalent to calling exit. However, a return from main
cannot be expected to work if data local to main might be needed
during cleanup. A few very old, nonconforming
systems may once have had problems with one or the other form.
(Finally, the two forms are obviously not equivalent in a recursive
call to main.)
</p>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6">Q11.17 I'm trying to use the ANSI ``stringizing'' preprocessing operator `#' to insert the value of a symbolic constant into a message, but it keeps stringizing the macro's name rather than its value.</h3>
<div class="outline-text-3" id="text-10-6">
<p>
It turns out that the definition of # says that it's supposed to stringize a macro argument immediately, without further expanding it (if the argument happens to be the name of another macro). You can use something like the following two-step procedure to force a macro to be expanded as well as stringized:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">Str</span>(<span style="color: #eedd82;">x</span>) #x
<span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">Xstr</span>(<span style="color: #eedd82;">x</span>) Str(x)
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">OP</span> plus
<span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">opname</span> = Xstr(OP);
</pre>
</div>
<p>
This code sets opname to "plus" rather than "OP". (It works because
the Xstr() macro expands its argument, and then Str() stringizes it.)
</p>

<p>
An equivalent circumlocution is necessary with the token-pasting
operator ## when the values (rather than the names) of two macros are
to be concatenated.
</p>

<p>
Note that both # and ## operate only during preprocessor macro
expansion. You cannot use them in normal source code, but only in
macro definitions.
</p>
</div>
</div>
<div id="outline-container-sec-10-7" class="outline-3">
<h3 id="sec-10-7">Q11.18 What does the message ``warning: macro replacement within a string literal'' mean?</h3>
<div class="outline-text-3" id="text-10-7">
<p>
When you do want to turn macro arguments into strings, you can use the
new # preprocessing operator, along with string literal concatenation
(another new ANSI feature):
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #87cefa;">TRACE</span>(<span style="color: #eedd82;">var</span>, <span style="color: #eedd82;">fmt</span>) \
        printf(<span style="color: #ffa07a;">"TRACE: "</span> #var <span style="color: #ffa07a;">" = "</span> #fmt <span style="color: #ffa07a;">"\n"</span>, var)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10-8" class="outline-3">
<h3 id="sec-10-8">Q11.20 What are #pragmas and what are they good for?</h3>
<div class="outline-text-3" id="text-10-8">
<p>
The #pragma directive provides a single, well-defined ``escape hatch''
which can be used for all sorts of (nonportable)
implementation-specific controls and extensions: source listing
control, structure packing, warning suppression (like lint's old <i>*
NOTREACHED *</i> comments), etc.
</p>
</div>
</div>
<div id="outline-container-sec-10-9" class="outline-3">
<h3 id="sec-10-9">Q11.25 What's the difference between <code>memcpy</code> and <code>memmove</code>?</h3>
<div class="outline-text-3" id="text-10-9">
<p>
memmove offers guaranteed behavior if the memory regions pointed to
by the source and destination arguments overlap. memcpy makes no such
guarantee, and may therefore be more efficiently implementable. When
in doubt, it's safer to use memmove.
</p>

<p>
It seems simple enough to implement memmove; the overlap guarantee
apparently requires only an additional test:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> *<span style="color: #87cefa;">memmove</span>(<span style="color: #98fb98;">void</span> *<span style="color: #eedd82;">dest</span>, <span style="color: #98fb98;">void</span> <span style="color: #00ffff;">const</span> *<span style="color: #eedd82;">src</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">n</span>)
{
        <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">dp</span> = dest;
        <span style="color: #00ffff;">register</span> <span style="color: #98fb98;">char</span> <span style="color: #00ffff;">const</span> *<span style="color: #eedd82;">sp</span> = src;
        <span style="color: #00ffff;">if</span>(dp &lt; sp) {
                <span style="color: #00ffff;">while</span>(n-- &gt; 0)
                        *dp++ = *sp++;
        } <span style="color: #00ffff;">else</span> {
                dp += n;
                sp += n;
                <span style="color: #00ffff;">while</span>(n-- &gt; 0)
                        *--dp = *--sp;
        }

        <span style="color: #00ffff;">return</span> dest;
}
</pre>
</div>
<p>
The problem with this code is in that additional test: the comparison
(dp &lt; sp) is not quite portable (it compares two pointers which do not
necessarily point within the same object) and may not be as cheap as
it looks. On some machines (particularly segmented architectures), it
may be tricky and significantly less efficient [footnote] to
implement.
</p>
</div>
</div>

<div id="outline-container-sec-10-10" class="outline-3">
<h3 id="sec-10-10">Q11.26 What should malloc(0) do? Return a null pointer or a pointer to 0 bytes?</h3>
<div class="outline-text-3" id="text-10-10">
<p>
The ANSI/ISO Standard says that it may do either; the behavior is
implementation-defined . Portable code must
either take care not to call malloc(0), or be prepared for the
possibility of a null return.
</p>
</div>
</div>
<div id="outline-container-sec-10-11" class="outline-3">
<h3 id="sec-10-11">Q11.33 People seem to make a point of distinguishing between implementation-defined, unspecified, and undefined behavior. What do these mean?</h3>
<div class="outline-text-3" id="text-10-11">
<p>
First of all, all three of these represent areas in which the C
Standard does not specify exactly what a particular construct, or a
program which uses it, must do. This looseness in C's definition is
traditional and deliberate: it permits compiler writers to (a) make
choices which allow efficient code to be generated by arranging that
various constructs are implemented as ``however the hardware does
them'', and (b) ignore (that is, avoid
worrying about generating correct code for) certain marginal
constructs which are too difficult to define precisely and which
probably aren't useful to well-written programs anyway.
</p>

<p>
These three variations on ``not precisely defined by the standard'' are defined as:
</p>

<p>
<b>implementation-defined:</b> The implementation must pick some behavior; it may not fail to compile the program. (The program using the construct is not incorrect.) The choice must be documented. The Standard may specify a set of allowable behaviors from which to choose, or it may impose no particular requirements.
</p>

<p>
<b>unspecified:</b> Like implementation-defined, except that the choice need not be documented.
</p>

<p>
 <b>undefined:</b> Anything at all can happen; the Standard imposes no
requirements. The program may fail to compile, or it may execute
incorrectly (either crashing or silently generating incorrect
results), or it may fortuitously do exactly what the programmer
intended.
</p>
</div>
</div>

<div id="outline-container-sec-10-12" class="outline-3">
<h3 id="sec-10-12">Q11.33b  What does it really mean for a program to be ``legal'' or ``valid'' or ``conforming''?</h3>
<div class="outline-text-3" id="text-10-12">
<p>
Simply stated, the Standard talks about three kinds of conformance: conforming programs, strictly conforming programs, and conforming implementations.
</p>

<p>
A <code>conforming program</code> is one that is accepted by a conforming implementation.
</p>

<p>
A <code>strictly conforming program</code> is one that does not depend on any implementation-defined, unspecified, or undefined behavior, that does not exceed any implementation limits, and that otherwise uses only the features of the language and library as specified in the Standard.
</p>

<p>
A <code>conforming implementation</code> is one that does everything the Standard says it's supposed to. (The way the Standard says this is that a conforming implementation ``shall accept any strictly conforming program''.) There are two kinds of conforming implementation: hosted and freestanding. A hosted implementation is intended for use with conventional application programs; a freestanding implementation is intended for use with embedded systems and the like, and is not required to supply all of the standard library functions.
</p>

<p>
Unfortunately, neither of the definitions relating to conforming programs are as practically useful as one might wish. There are very few realistic, useful, strictly conforming programs. On the other hand, a merely conforming program can make use of any compiler-specific extension it wants to.
</p>

<p>
Other words you may hear are ``compliant'' and ``conformant'' which
are basically just synonyms for ``conforming''.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">12. Stdio</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Q12.2</h3>
<div class="outline-text-3" id="text-11-1">
<p>
Why does the simple line-copying loop <code>while(!feof(infp)) { fgets(buf,
MAXLINE, infp); fputs(buf, outfp); }</code> copy the last line twice?
</p>

<p>
In C, end-of-file is only indicated after an input routine has tried to read, and failed. (In other words, C's I/O is not like Pascal's.) Usually, you should just check the return value of the input routine:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">while</span>(fgets(buf, MAXLINE, infp) != <span style="color: #7fffd4;">NULL</span>)
        fputs(buf, outfp);
</pre>
</div>
<p>
In virtually all cases, there's no need to use <code>feof</code> at all. (feof, or
more likely ferror, may be useful after a stdio call has returned EOF
or NULL, to distinguish between an end-of-file condition and a read
error.)
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">Q12.5 How can I read one character at a time, without waiting for the RETURN key?</h3>
<div class="outline-text-3" id="text-11-2">
<p>
See question 19.1.
</p>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">12.9b What printf format should I use for a typedef like size<sub>t</sub> when I don't know whether it's long or some other type?</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Use a cast to convert the value to a known, conservatively-sized type, then use the printf format matching that type. For example, to print the size of a type, you might use
</p>

<div class="org-src-container">

<pre class="src src-c">printf(<span style="color: #ffa07a;">"%lu"</span>, (<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">long</span>)<span style="color: #00ffff;">sizeof</span>(thetype));
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">18. Tools and Resources</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">C development tools</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>a C cross-reference generator
cflow, cxref, calls, cscope, xscope, or ixfw
</li>
<li>a C beautifier/pretty-printer
cb, indent, GNU indent, or vgrind
</li>
<li>a revision control or configuration management tool
CVS, RCS, or SCCS
</li>
<li>a C source obfuscator (shrouder)
obfus, shroud, or opqcp
</li>
<li>a ``make'' dependency generator
makedepend, or try cc -M or cpp -M
</li>
<li>tools to compute code metrics
ccount, Metre, lcount, or csize; there is also a package sold by McCabe and Associates
</li>
<li>a C lines-of-source counter
this can be done very crudely with the standard Unix utility wc, and somewhat better with grep -c ";"
</li>
<li>a C declaration aid (cdecl)
check volume 14 of comp.sources.unix (see question 18.16) and K&amp;R2
</li>
<li>a prototype generator
see question 11.31
</li>
<li>a tool to track down malloc problems
see question 18.2
</li>
<li>a ``selective'' C preprocessor
see question 10.18
</li>
<li>language translation tools
see questions 11.31 and 20.26
</li>
<li>C verifiers (lint)
see question 18.7
</li>
<li>a C compiler!
see question 18.3
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">track down malloc problems tools</h3>
<div class="outline-text-3" id="text-12-2">
<p>
one popular one is Conor P. Cahill's ``dbmalloc'', posted to
comp.sources.misc in 1992, volume 32. Others are ``leak'', available
in volume 27 of the comp.sources.unix archives; JMalloc.c and
JMalloc.h in the ``Snippets'' collection; MEMDEBUG from ftp.crpht.lu
in pub/sources/memdebug ; and Electric Fence.
</p>
</div>
</div>
<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3">C tutorials</h3>
<div class="outline-text-3" id="text-12-3">
<ul class="org-ul">
<li>Tom Torfs has a nice tutorial at <a href="http://cprog.tomsweb.net">http://cprog.tomsweb.net</a>.
</li>

<li>``Notes for C programmers,'' by Christopher Sawtell, are available
by ftp from svr-ftp.eng.cam.ac.uk and garbo.uwasa.fi, or on the web
at www.fi.uib.no .
</li>

<li>Tim Love's ``C for Programmers'' is available by ftp from
svr-ftp.eng.cam.ac.uk in the misc directory. An html version is at
<a href="http://www-h.eng.cam.ac.uk/help/tpl/languages/C/teaching_C/teaching_C.html">http://www-h.eng.cam.ac.uk/help/tpl/languages/C/teaching_C/teaching_C.html</a>.
</li>

<li>The Coronado Enterprises C tutorials are available on Simtel mirrors
in pub/msdos/c or on the web at
<a href="http://www.coronadoenterprises.com/tutorials/c/index.html">http://www.coronadoenterprises.com/tutorials/c/index.html</a>.
</li>

<li>There is a web-based course by Steve Holmes at <a href="http://www.strath.ac.uk/IT/Docs/Ccourse/">http://www.strath.ac.uk/IT/Docs/Ccourse/</a>.
</li>

<li>Martin Brown has C course material on the web at <a href="http://www-isis.ecs.soton.ac.uk/computing/c/Welcome.html">http://www-isis.ecs.soton.ac.uk/computing/c/Welcome.html</a>.
</li>

<li>On some Unix machines you can try typing ``learn c'' at the shell prompt (but the lessons may be quite dated).
</li>

<li>Finally, the author of this FAQ list once taught a couple of C
classes and has placed their notes on the web; they are at
<a href="http://www.eskimo.com/~scs/cclass/cclass.html">http://www.eskimo.com/~scs/cclass/cclass.html</a>.
</li>

<li>Several of these tutorials, plus a great deal of other information
about C, are accessible via the web at <a href="http://www.quut.com/c/">http://www.quut.com/c/</a>.
</li>

<li>Vinit Carpenter maintains a list of resources for learning C and
C++; it is posted to comp.lang.c and comp.lang.c++, and archived
where this FAQ list is (see question 20.40), or on the web at <a href="http://www.cyberdiem.com/vin/learn.html">http://www.cyberdiem.com/vin/learn.html</a>.
</li>

<li>a list:  <a href="http://www.cyberdiem.com/vin/tutorials/">http://www.cyberdiem.com/vin/tutorials/</a>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4">some good code examples to study</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li><a href="http://www.eskimo.com/~scs/src/">http://www.eskimo.com/~scs/src/</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5">Numerical Recipes</h3>
<div class="outline-text-3" id="text-12-5">
<p>
<a href="http://www.numerical-recipes.com/public-domain.html">http://www.numerical-recipes.com/public-domain.html</a>
</p>
</div>
</div>
<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6">The GNU C Library (glibc)</h3>
<div class="outline-text-3" id="text-12-6">
<p>
<a href="http://www.gnu.org/software/libc/">http://www.gnu.org/software/libc/</a>
</p>
</div>
</div>
<div id="outline-container-sec-12-7" class="outline-3">
<h3 id="sec-12-7">parse and evaluate expressions(packages are ``defunc,'')</h3>
<div class="outline-text-3" id="text-12-7">
<p>
available from sunsite.unc.edu in
pub/packages/development/libraries/defunc-1.3.tar.Z
</p>

<p>
<a href="ftp://sunsite.unc.edu/pub/packages/development/libraries/">ftp://sunsite.unc.edu/pub/packages/development/libraries/</a>
</p>
</div>
</div>
<div id="outline-container-sec-12-8" class="outline-3">
<h3 id="sec-12-8">Ian Hay's recommended book list<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup></h3>
<div class="outline-text-3" id="text-12-8">
<p>
GENERAL INTRODUCTION/TUTORIAL: 
</p>

<ol class="org-ol">
<li>For real beginners looking for a solid introduction: 
</li>
</ol>

<p>
C Programming: A Modern Approach. 
K.N.King. 
W.W.Norton &amp; Company, 1996. 
ISBN 0-393-96945-2 
</p>

<ol class="org-ol">
<li>For somewhat more experienced users looking for a solid introduction: 
</li>
</ol>

<p>
The C Programming Language, 2nd Ed. 
Kernigan &amp; Ritchie. 
Prentice Hall, 1988. 
ISBN 0-13-110362-8 
</p>

<ol class="org-ol">
<li>Other recommended introductory books: 
</li>
</ol>

<p>
C: How to Program, 2nd Ed. 
Deitel, H.M. &amp; Deitel, P.J. 
Prentice Hall, 1994. 
ISBN: 0-13-226119-7 
</p>


<p>
REFERENCES: 
</p>

<p>
C : A Reference Manual, 4th Ed. 
Harbison &amp; Steele. 
Prentice Hall, 1995. 
ISBN 0-13-326224-3 
</p>

<p>
The Standard C Library. 
P.J.Plauger. 
Prentice Hall, 1992. 
ISBN 0-13-131509-9 
</p>

<p>
C Programming FAQs 
Steve Summit 
Addison-Wesley, 1996. 
ISBN 0-201-84519-9 
</p>



<p>
ADVANCED TOPICS / FUTHER EXPLORATION: 
</p>

<p>
C Traps and Pitfalls. 
Andrew Koenig. 
Addison-Wesley, 1989. 
ISBN 0-201-17928-8 
</p>

<p>
Expert C Programming: Deep C Secrets 
Peter Van Der Linden 
Prentice Hall, 1994. 
ISBN 0-13-177429-8 
</p>

<p>
Practical C Programming. 
Steve Oualline. 
O'Reilly &amp; Associates, 1993. 
ISBN 1-56592-035-X 
</p>

<p>
Problem Solving And Program Design In C, 2nd Ed. 
Hanly &amp; Koffman. 
Addison-Wesley, 1996. 
ISBN 0-201-59063-8 
</p>

<p>
Algorithms in C, 3rd Ed. 
Robert Sedgewick 
Addison-Wesley, 1998. 
ISBN 0-201-31452-5
</p>
</div>
</div>
<div id="outline-container-sec-12-9" class="outline-3">
<h3 id="sec-12-9">code fragments and examples</h3>
<div class="outline-text-3" id="text-12-9">
<p>
Bob Stout's popular ``SNIPPETS'' collection is available from
ftp.brokersys.com in directory pub/snippets or on the web at
<a href="http://www.brokersys.com/snippets/">http://www.brokersys.com/snippets/</a>.
</p>

<p>
Lars Wirzenius's ``publib'' library is available from ftp.funet.fi in
directory pub/languages/C/Publib/.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">strok</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;string.h&gt;</span>

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span> ()
{
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">str</span>[] =<span style="color: #ffa07a;">"- This, a sample string."</span>;
  <span style="color: #98fb98;">char</span> * <span style="color: #eedd82;">pch</span>;
  printf (<span style="color: #ffa07a;">"Splitting string \"%s\" into tokens:\n"</span>,str);
  pch = strtok (str,<span style="color: #ffa07a;">" ,.-"</span>);
  <span style="color: #00ffff;">while</span> (pch != <span style="color: #7fffd4;">NULL</span>)
  {
    printf (<span style="color: #ffa07a;">"%s\n"</span>,pch);
    pch = strtok (<span style="color: #7fffd4;">NULL</span>, <span style="color: #ffa07a;">" ,.-"</span>);
  }
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">qsort</h2>
<div class="outline-text-2" id="text-14">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">qsort</span> (<span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">base</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">num</span>, <span style="color: #98fb98;">size_t</span> <span style="color: #eedd82;">size</span>,
            <span style="color: #98fb98;">int</span> (*<span style="color: #eedd82;">compar</span>)(<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span>*,<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span>*));

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compar</span> (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">p1</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span>* <span style="color: #eedd82;">p2</span>);

<span style="color: #00ffff;">return</span> value    meaning
&lt;0      The element pointed by p1 goes before the element pointed by p2
0       The element pointed by p1 is equivalent to the element pointed by p2
&gt;0      The element pointed by p1 goes after the element pointed by p2

<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdio.h&gt;</span>      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">printf </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#include</span> <span style="color: #ffa07a;">&lt;stdlib.h&gt;</span>     <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">qsort </span><span style="color: #ff7f24;">*/</span>

<span style="color: #98fb98;">int</span> values[] = { 40, 10, 100, 90, 20, 25 };

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">compare</span> (<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> * <span style="color: #eedd82;">a</span>, <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">void</span> * <span style="color: #eedd82;">b</span>)
{
  <span style="color: #00ffff;">return</span> ( *(<span style="color: #98fb98;">int</span>*)a - *(<span style="color: #98fb98;">int</span>*)b );
}

<span style="color: #98fb98;">int</span> <span style="color: #87cefa;">main</span> ()
{
  <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">n</span>;
  qsort (values, 6, <span style="color: #00ffff;">sizeof</span>(<span style="color: #98fb98;">int</span>), compare);
  <span style="color: #00ffff;">for</span> (n=0; n&lt;6; n++)
     printf (<span style="color: #ffa07a;">"%d "</span>,values[n]);
  <span style="color: #00ffff;">return</span> 0;
}
</pre>
</div>

<p>
<a href="http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/">http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/</a>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="http://en.wikibooks.org/wiki/C_Programming/C_Reference/inttypes.h#cite_note-2">http://en.wikibooks.org/wiki/C_Programming/C_Reference/inttypes.h#cite_note-2</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://en.wikipedia.org/wiki/Delayed_allocation">http://en.wikipedia.org/wiki/Delayed_allocation</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p>DEFINITION NOT FOUND.</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p>DEFINITION NOT FOUND.</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2015-03-05 Thu 23:21</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
