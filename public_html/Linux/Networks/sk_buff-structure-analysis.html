<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>socket buffer结构解析</title>
<!-- 2014-11-07 Fri 23:23 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Shi Shougang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../assets/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">socket buffer结构解析</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">socket buffer</a></li>
<li><a href="#sec-2">Using Socket Buffers</a>
<ul>
<li><a href="#sec-2-1">Operations on socket buffers</a></li>
</ul>
</li>
<li><a href="#sec-3">Management Data of Socket Buffers</a>
<ul>
<li><a href="#sec-3-1"><code>dev</code></a></li>
<li><a href="#sec-3-2"><code>h</code> , <code>nh</code> and <code>mac</code></a></li>
<li><a href="#sec-3-3"><code>cloned</code></a></li>
<li><a href="#sec-3-4"><code>pkt_type</code></a></li>
<li><a href="#sec-3-5"><code>protocol</code></a></li>
</ul>
</li>
<li><a href="#sec-4">reference</a>
<ul>
<li><a href="#sec-4-1"><code>__alloc_skb</code></a></li>
<li><a href="#sec-4-2"><code>__kfree_skb</code></a></li>
<li><a href="#sec-4-3"><code>skb_realloc_headroom</code></a></li>
</ul>
</li>
<li><a href="#sec-5">cc</a></li>
</ul>
</div>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">socket buffer</h2>
<div class="outline-text-2" id="text-1">
<p>
当网络包被内核分析时,底层协议的数据被传送更高层.当数据传送时过程反过来.由不同协议产生的数据(包括头和负载)不断往下层传递直到它们最终被发送.因为这些操作的速度对于网络层的表现至关重要,内核使用一个特定的结构叫
<code>socket buffer</code> ,定义如下.Socket buffer被用来在网络实现层交换数据而 <b>不用拷贝来或去数据包</b> &#x2013;这显著获得速度收益.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">include/linux/skbuff.h </span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> {
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">These two members must be first. </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">next</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">prev</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sock</span> *<span style="color: #eedd82;">sk</span>;
  <span style="color: #98fb98;">ktime_t</span> <span style="color: #eedd82;">tstamp</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">net_device</span> *<span style="color: #eedd82;">dev</span>;
  <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">dst_entry</span> *<span style="color: #eedd82;">dst</span>;
  <span style="color: #98fb98;">char</span> <span style="color: #eedd82;">cb</span>[48];
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>,
    <span style="color: #eedd82;">data_len</span>;
  <span style="color: #98fb98;">__u16</span> <span style="color: #eedd82;">mac_len</span>,
    <span style="color: #eedd82;">hdr_len</span>;
  <span style="color: #00ffff;">union</span> {
    <span style="color: #98fb98;">__wsum</span> <span style="color: #eedd82;">csum</span>;
    <span style="color: #00ffff;">struct</span> {
      <span style="color: #98fb98;">__u16</span> <span style="color: #eedd82;">csum_start</span>;
      <span style="color: #98fb98;">__u16</span> <span style="color: #eedd82;">csum_offset</span>;
    };
  };
  <span style="color: #98fb98;">__u32</span> <span style="color: #eedd82;">priority</span>;
  <span style="color: #98fb98;">__u8</span> <span style="color: #eedd82;">local_df</span>:1,
    <span style="color: #eedd82;">cloned</span>:1,
    <span style="color: #eedd82;">ip_summed</span>:2,
    <span style="color: #eedd82;">nohdr</span>:1,
    <span style="color: #eedd82;">nfctinfo</span>:3;
  <span style="color: #98fb98;">__u8</span> <span style="color: #eedd82;">pkt_type</span>:3,
    <span style="color: #eedd82;">fclone</span>:2,
    <span style="color: #eedd82;">ipvs_property</span>:1;
 nf_trace:1;
  <span style="color: #98fb98;">__be16</span> <span style="color: #eedd82;">protocol</span>;
  ...
  <span style="color: #98fb98;">void</span> (*destructor)(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>);
  ...
  <span style="color: #98fb98;">int</span> iif;
  ...
  sk_buff_data_t transport_header;
  <span style="color: #98fb98;">sk_buff_data_t</span> <span style="color: #eedd82;">network_header</span>;
  <span style="color: #98fb98;">sk_buff_data_t</span> <span style="color: #eedd82;">mac_header</span>;
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">These elements must be at the end, see alloc_skb() for details. </span><span style="color: #ff7f24;">*/</span>
  <span style="color: #98fb98;">sk_buff_data_t</span> <span style="color: #eedd82;">tail</span>;
  <span style="color: #98fb98;">sk_buff_data_t</span> <span style="color: #eedd82;">end</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">head</span>,
    *<span style="color: #eedd82;">data</span>;
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">truesize</span>;
  <span style="color: #98fb98;">atomic_t</span> <span style="color: #eedd82;">users</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Using Socket Buffers</h2>
<div class="outline-text-2" id="text-2">
<p>
Socket buffers 由许多指针链接而成,如下图.图中假设32位系统,在64位机器上
socket buffer的结构稍微有点不同.
<img src="./Files/link-socket-buff.jpeg" alt="link-socket-buff.jpeg" />
</p>

<p>
socket buffer的基本理念是通过操作不同的指针来添加或取出协议的头部.
</p>
<ul class="org-ul">
<li>head和end指向数据缓存区域的start和end.
</li>
<li>data和tail指向实际协议数据区域的start和end.
</li>
<li><code>mac_header</code> 指向MAC头的start, <code>network_header</code> 和
<code>transport_header</code> 分别指向network和transport层的数据头.在32位的系统中,用来定义上面变量的数据类型 <code>sk_buff_data_t</code> 仅仅是一个简单的指针:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">&lt;skbuff.h&gt;</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #98fb98;">sk_buff_data_t</span>;
</pre>
</div>
<p>
使得kernel对于不同的协议类型都能使用socket buffer.简单的类型转换对于正确解析数据是必要的.比如一个socket buffer包含TCP包,TCP头如何从这个
socket buffer获得:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">&lt;tcp.h&gt;</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tcphdr</span> *<span style="color: #87cefa;">tcp_hdr</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
  <span style="color: #00ffff;">return</span> (<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">tcphdr</span> *)skb_transport_header(skb);
}
</pre>
</div>
<p>
其他类似的转换的函数以 <code>xxx_hdr</code> 形式.
</p>
</li>
</ul>

<p>
因为对于网络层来说,低内存占用和高处理速度是必要的,所以对于 <code>struct
sk_buff</code> 来说,希望这个结构尽可能的小.在64位系统中,使用小技巧来节省一些空间. <code>sk_buff_data_t</code> 定义变成一个整型变量:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">&lt;skbuff.h&gt;</span>
<span style="color: #00ffff;">typedef</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #98fb98;">sk_buff_data_t</span>;
</pre>
</div>
<p>
因为整型只需要指针内存的一半(4取代8字节)在一些系统架构上,那么这个结构节省20字节.data和head仍然是普通指针,其他 <code>sk_buff_data_t</code> 元素现在被解析成相对这些指针的偏移量.指向transport头的起始指针现在如下计算:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">skb_transport_header</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
  <span style="color: #00ffff;">return</span> skb-&gt;head + skb-&gt;transport_header;
}
</pre>
</div>
<p>
用这个方法是可行的,因为4字节足够表示4G的内存空间,而一个socket buffer永远不会超过这个大小.
</p>

<p>
data和tail使得数据在不同协议层间传递不用显示的拷贝操作,如下图.显示包如何处理.
</p>

<p>
当一个新包产生,TCP 层先在用户空间分配内存来存储包的数据(包括头和负载).比数据更多的足够的空间被预留使得底层能加入更多的头部数据.head和end指向预留空间的start和end,而TCP 数据在data和tail之间.
</p>

<p>
当socket buffer传递到IP 层,新的协议头要加入其中,其他指针不变,除了data
现在指向IP 头的起始处.同样的操作被之后的下层协议重复,直到完成的包被发送往网络.
</p>


<div class="figure">
<p><img src="./Files/manipulation-socket-buffer.jpeg" alt="manipulation-socket-buffer.jpeg" />
</p>
</div>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Operations on socket buffers</h3>
<div class="outline-text-3" id="text-2-1">
<p>
看 <code>include/linux/skbuff.h</code> 中ocket buffer的一些常用的操作:
</p>
</div>
<ul class="org-ul"><li><a id="sec-2-1-1" name="sec-2-1-1"></a>allocate <code>sk_buff</code><br  /><div class="outline-text-4" id="text-2-1-1">
<p>
<code>sk_buff</code> 有两部分组成: <code>sk_buff</code> (<code>skb_buff</code> 本身描述符 和 其中data内从空间) 和 <code>skb_share_info</code>.
</p>


<div class="figure">
<p><img src="./Files/skb-buff.png" alt="skb-buff.png" />
</p>
</div>

<p>
<code>alloc_skb</code> 调用了一个内部函数 <code>__alloc_skb</code> (详见<a href="#alloc_skb"><code>__alloc_skb</code></a>). 并且:
</p>
<ul class="org-ul">
<li>fclone=0 : 不从fclone cache分配skb的头, 从head cache中.
</li>
<li>node=-1: NUMA不使用.
</li>
</ul>

<p>
分配过程主要分为:
</p>
<ol class="org-ol">
<li>从cache中分配skb的本身描述符.
</li>
<li>优化对cache的对齐,对数据大小做algin操作: <code>size =
   SKB_DATA_ALIGN(size);</code> .
</li>
<li>分配data内存,包括size和 <code>skb_shared_info</code> 大小: <code>data = kmalloc_node_track_caller(size + sizeof(struct skb_shared_info),
   gfp_mask, node);</code>
</li>
<li>对skb字段做一些初始化,其中 <code>skb-&gt;truesize = size + sizeof(struct
   sk_buff);</code> 是总的大小.
</li>
<li>最后对 <code>skb_shared_info</code> 做一些初始化.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #87cefa;">alloc_skb</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>,
                                        <span style="color: #98fb98;">gfp_t</span> <span style="color: #eedd82;">priority</span>)
{
  <span style="color: #00ffff;">return</span> __alloc_skb(size, priority, 0, -1);
}
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">example</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skbn</span>;
<span style="color: #00ffff;">if</span> ((skbn = alloc_skb(len, GFP_ATOMIC)) == <span style="color: #7fffd4;">NULL</span>)
  <span style="color: #00ffff;">return</span>;
</pre>
</div>
</div>
</li>

<li><a id="sec-2-1-2" name="sec-2-1-2"></a>free <code>sk_buff</code><br  /><div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">void</span> <span style="color: #87cefa;">kfree_skb</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
  <span style="color: #00ffff;">if</span> (unlikely(!skb))
    <span style="color: #00ffff;">return</span>;
  <span style="color: #00ffff;">if</span> (likely(atomic_read(&amp;skb-&gt;users) == 1))
    smp_rmb();
  <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (likely(!atomic_dec_and_test(&amp;skb-&gt;users)))
    <span style="color: #00ffff;">return</span>;
  __kfree_skb(skb);
}
</pre>
</div>
<p>
稍微分析一下:
</p>
<ol class="org-ol">
<li>若skb是NULL,直接返回.
</li>
<li>如果 <code>skb-&gt;users = 1</code>, 那么说明没有其他代码在使用它,需要free,
<code>smp_rmb();</code> 是一个memory barrier, 防止内存乱序执行,防止的是多线程释放的情况,更多内容见<a href="http://dreamrunner.org/blog/2014/06/28/qian-tan-memory-reordering/">浅谈Memory Reordering</a>.
</li>
<li><code>atomic_dec_and_test(&amp;skb-&gt;users)</code> 减1后再次判断引用是否为0,上面已经判断不是1了,这里是否必要再次判断?是需要的, <code>if</code> 和 <code>else
   if</code> 间不是原子操作,其他进程在这之间可以插入free这个skb.所以原子减后需要再次判断是否能free.
</li>
</ol>

<p>
在<a href="#kfree_skb"> <code>__kfree_skb(skb);</code> </a>中release data时会判断 <code>!skb-&gt;cloned</code> 不是clone
的才会释放data空间.
</p>
</div>
</li>

<li><a id="sec-2-1-3" name="sec-2-1-3"></a>copy of <code>sk_buff</code><br  /><div class="outline-text-4" id="text-2-1-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #87cefa;">skb_copy</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">gfp_t</span> <span style="color: #eedd82;">gfp_mask</span>)
{
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">headerlen</span> = skb-&gt;data - skb-&gt;head;
        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         *      Allocate the copy buffer</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">n</span>;
<span style="color: #b0c4de;">#ifdef</span> NET_SKBUFF_DATA_USES_OFFSET
        n = alloc_skb(skb-&gt;end + skb-&gt;data_len, gfp_mask);
<span style="color: #b0c4de;">#else</span>
        n = alloc_skb(skb-&gt;end - skb-&gt;head + skb-&gt;data_len, gfp_mask);
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #00ffff;">if</span> (!n)
                <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set the data pointer </span><span style="color: #ff7f24;">*/</span>
        skb_reserve(n, headerlen);
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Set the tail pointer and length </span><span style="color: #ff7f24;">*/</span>
        skb_put(n, skb-&gt;len);

        <span style="color: #00ffff;">if</span> (skb_copy_bits(skb, -headerlen, n-&gt;head, headerlen + skb-&gt;len))
                BUG();

        copy_skb_header(n, skb);
        <span style="color: #00ffff;">return</span> n;
}
</pre>
</div>

<p>
拷贝整个 <code>skb_buff</code> 结构,包括描述符和数据缓存区.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">example</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skbn</span> = skb_copy(skb, GFP_ATOMIC);
</pre>
</div>
</div>
</li>
<li><a id="sec-2-1-4" name="sec-2-1-4"></a>clone of <code>sk_buff</code><br  /><div class="outline-text-4" id="text-2-1-4">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #87cefa;">skb_clone</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">gfp_t</span> <span style="color: #eedd82;">gfp_mask</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">n</span>;

        n = skb + 1;
        <span style="color: #00ffff;">if</span> (skb-&gt;fclone == SKB_FCLONE_ORIG &amp;&amp;
            n-&gt;fclone == SKB_FCLONE_UNAVAILABLE) {
                <span style="color: #98fb98;">atomic_t</span> *<span style="color: #eedd82;">fclone_ref</span> = (<span style="color: #98fb98;">atomic_t</span> *) (n + 1);
                n-&gt;fclone = SKB_FCLONE_CLONE;
                atomic_inc(fclone_ref);
        } <span style="color: #00ffff;">else</span> {
                n = kmem_cache_alloc(skbuff_head_cache, gfp_mask);
                <span style="color: #00ffff;">if</span> (!n)
                        <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">NULL</span>;
                n-&gt;fclone = SKB_FCLONE_UNAVAILABLE;
        }

        <span style="color: #00ffff;">return</span> __skb_clone(n, skb);
}
</pre>
</div>

<p>
clone和copy不一样,只生成新的 <code>sk_buff</code> 的描述符结构,数据缓存区直接指向旧的,基本步骤:
</p>
<ol class="org-ol">
<li>分配新的 <code>sk_buff</code> 结构体.
</li>
<li>拷贝结构体内容.
</li>
<li><code>atomic_set(&amp;n-&gt;users, 1);</code> :has a reference count of 1.
</li>
<li><code>skb-&gt;cloned = 1;</code> :设置clone位.
</li>
</ol>
</div>
</li>

<li><a id="sec-2-1-5" name="sec-2-1-5"></a><code>skb_put</code><br  /><div class="outline-text-4" id="text-2-1-5">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #87cefa;">skb_put</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">len</span>)
{
  <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">char</span> *<span style="color: #eedd82;">tmp</span> = skb_tail_pointer(skb);
  SKB_LINEAR_ASSERT(skb);
  skb-&gt;tail += len;
  skb-&gt;len  += len;
  <span style="color: #00ffff;">if</span> (unlikely(skb-&gt;tail &gt; skb-&gt;end))
    skb_over_panic(skb, len, current_text_addr());
  <span style="color: #00ffff;">return</span> tmp;
}
</pre>
</div>

<p>
扩展被使用的data区域.并返回准备存储data的起始位置的指针.
 <b>example:</b> 从ipbuf中拷贝16字节到 skb 中 data 的末尾处.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">example</span>
memcpy(skb_put(skb,16),ipbuf,16);
</pre>
</div>
</div>
</li>
<li><a id="sec-2-1-6" name="sec-2-1-6"></a><code>skb_tailroom</code> and  <code>skb_headroom</code><br  /><div class="outline-text-4" id="text-2-1-6">
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;">   *      skb_tailroom - bytes at buffer end</span>
<span style="color: #ffa07a;">   */</span>
  <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">skb_tailroom</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
  {
    <span style="color: #00ffff;">return</span> skb_is_nonlinear(skb) ? 0 : skb-&gt;end - skb-&gt;tail;
  }
  <span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">skb_is_nonlinear</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
  {
    <span style="color: #00ffff;">return</span> skb-&gt;data_len;
  }
<span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> *      skb_headroom - bytes at buffer head</span>
<span style="color: #ffa07a;">*/</span>
<span style="color: #00ffff;">static</span> <span style="color: #00ffff;">inline</span> <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #87cefa;">skb_headroom</span>(<span style="color: #00ffff;">const</span> <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
        <span style="color: #00ffff;">return</span> skb-&gt;data - skb-&gt;head;
}
</pre>
</div>
<ul class="org-ul">
<li><code>skb_headroom</code> 返回data缓存区前部分的空闲大小.
</li>
<li><code>skb_tailroom</code> 而返回data缓存区后部分空闲大小.
</li>
</ul>

<p>
<code>skb-&gt;data_len</code> 是分片内存中数据长度,通过它来判断skb的数据缓存区是否线程,不是线性,skb 尾部空的内存大小为0, 若线性的, 尾部空的内存空间是
<code>skb-&gt;end - skb-&gt;tail</code> .
</p>

<p>
<b>example:</b> 把skb的data扩展到区域大小扩展到 <code>min_frame_size</code> .
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">min_frame_size</span> = 62;
<span style="color: #00ffff;">if</span> (skb-&gt;len &lt; min_frame_size) {
  <span style="color: #00ffff;">if</span> ((skb-&gt;len + skb_tailroom(skb)) &lt; min_frame_size) {
    skb2 = skb_copy_expand(skb, 0,
                           min_frame_size - skb-&gt;truesize,
                           GFP_ATOMIC);
    dev_kfree_skb(skb);
    <span style="color: #00ffff;">if</span> (skb2 == <span style="color: #7fffd4;">NULL</span>) {
      priv-&gt;stats.tx_dropped++;
      <span style="color: #00ffff;">return</span> 0;
    }
    skb = skb2;
  }
  skb_put(skb, min_frame_size - skb-&gt;len);
}
</pre>
</div>
</div>
</li>
<li><a id="sec-2-1-7" name="sec-2-1-7"></a><code>skb_realloc_headroom</code><br  /></li>



<li><a id="sec-2-1-8" name="sec-2-1-8"></a><code>skb_reserve</code><br  /></li>

<li><a id="sec-2-1-9" name="sec-2-1-9"></a>transport/network/mac operation<br  /></li></ul>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Management Data of Socket Buffers</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><code>dev</code></h3>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><code>h</code> , <code>nh</code> and <code>mac</code></h3>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><code>cloned</code></h3>
<div class="outline-text-3" id="text-3-3">
<p>
当被设置时，表示这个结构是另一个sk<sub>buff的克隆</sub>
</p>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><code>pkt_type</code></h3>
<div class="outline-text-3" id="text-3-4">
<p>
这个变量表示帧的类型，分类是由L2的目的地址来决定的。这个值在网卡驱动程序中由函数eth<sub>type</sub><sub>trans通过判断目的以太网地址来确定。如果</sub> 目的地址是
FF:FF:FF:FF:FF:FF，则为广播地址，pkt<sub>type</sub> = PACKET<sub>BROADCAST；如果最高</sub>
位为1,则为组播地址，pkt<sub>type</sub> = PACKET<sub>MULTICAST；如果目的mac地址跟本机</sub>
mac地址不相等，则不是发给本机的数据报，pkt<sub>type</sub> = PACKET<sub>OTHERHOST；否</sub>
则就是缺省值PACKET<sub>HOST。</sub>
</p>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><code>protocol</code></h3>
<div class="outline-text-3" id="text-3-5">
<p>
这个变量是高层协议从二层设备的角度所看到的协议。典型的协议包括IP，IPV6
和ARP。完整的列表在 include/linux/if<sub>ether</sub>.h中。由于每个协议都有自己的协议处理函数来处理接收到的包，因此，这个域被设备驱动用于通知上层调用哪个协议处理函数。每个网络驱动都调用netif<sub>rx来通知上层网络协议的协议处理</sub>
函数，因此protocol变量必须在这些协议处理函数调用之前初始化。
</p>


<div class="org-src-container">

<pre class="src src-c"><span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PACKET_HOST</span>         0      
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PACKET_BROADCAST</span>    1      
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PACKET_MULTICAST</span>    2      
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PACKET_OTHERHOST</span>    3      
<span style="color: #b0c4de;">#define</span> <span style="color: #eedd82;">PACKET_OUTGOING</span>     4
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">reference</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><code>__alloc_skb</code></h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a id="alloc_skb" name="alloc_skb"></a>
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ffa07a;">/**</span>
<span style="color: #ffa07a;"> *      __alloc_skb     -       allocate a network buffer</span>
<span style="color: #ffa07a;"> *      </span><span style="color: #7fffd4;">@size</span><span style="color: #ffa07a;">: size to allocate</span>
<span style="color: #ffa07a;"> *      </span><span style="color: #7fffd4;">@gfp_mask</span><span style="color: #ffa07a;">: allocation mask</span>
<span style="color: #ffa07a;"> *      </span><span style="color: #7fffd4;">@fclone</span><span style="color: #ffa07a;">: allocate from fclone cache instead of head cache</span>
<span style="color: #ffa07a;"> *              and allocate a cloned (child) skb</span>
<span style="color: #ffa07a;"> *      </span><span style="color: #7fffd4;">@node</span><span style="color: #ffa07a;">: numa node to allocate memory on</span>
<span style="color: #ffa07a;"> */</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #87cefa;">__alloc_skb</span>(<span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">size</span>, <span style="color: #98fb98;">gfp_t</span> <span style="color: #eedd82;">gfp_mask</span>,
                            <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">fclone</span>, <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">node</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">kmem_cache</span> *<span style="color: #eedd82;">cache</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">skb_shared_info</span> *<span style="color: #eedd82;">shinfo</span>;
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>;
        <span style="color: #98fb98;">u8</span> *<span style="color: #eedd82;">data</span>;

        cache = fclone ? skbuff_fclone_cache : skbuff_head_cache;

        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">Get the HEAD </span><span style="color: #ff7f24;">*/</span>
        skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);
        <span style="color: #00ffff;">if</span> (!skb)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;

        size = SKB_DATA_ALIGN(size);
        data = kmalloc_node_track_caller(size + <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">skb_shared_info</span>),
                        gfp_mask, node);
        <span style="color: #00ffff;">if</span> (!data)
                <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">nodata</span>;

        <span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">         * See comment in sk_buff definition, just before the 'tail' member</span>
<span style="color: #ff7f24;">         </span><span style="color: #ff7f24;">*/</span>
        memset(skb, 0, offsetof(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span>, tail));
        skb-&gt;truesize = size + <span style="color: #00ffff;">sizeof</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span>);
        atomic_set(&amp;skb-&gt;users, 1);
        skb-&gt;head = data;
        skb-&gt;data = data;
        skb_reset_tail_pointer(skb);
        skb-&gt;end = skb-&gt;tail + size;
        <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">make sure we initialize shinfo sequentially </span><span style="color: #ff7f24;">*/</span>
        shinfo = skb_shinfo(skb);
        atomic_set(&amp;shinfo-&gt;dataref, 1);
        shinfo-&gt;nr_frags  = 0;
        shinfo-&gt;gso_size = 0;
        shinfo-&gt;gso_segs = 0;
        shinfo-&gt;gso_type = 0;
        shinfo-&gt;ip6_frag_id = 0;
        shinfo-&gt;frag_list = <span style="color: #7fffd4;">NULL</span>;

        <span style="color: #00ffff;">if</span> (fclone) {
                <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">child</span> = skb + 1;
                <span style="color: #98fb98;">atomic_t</span> *<span style="color: #eedd82;">fclone_ref</span> = (<span style="color: #98fb98;">atomic_t</span> *) (child + 1);

                skb-&gt;fclone = SKB_FCLONE_ORIG;
                atomic_set(fclone_ref, 1);

                child-&gt;fclone = SKB_FCLONE_UNAVAILABLE;
        }
<span style="color: #7fffd4;">out</span>:
        <span style="color: #00ffff;">return</span> skb;
<span style="color: #7fffd4;">nodata</span>:
        kmem_cache_free(cache, skb);
        skb = <span style="color: #7fffd4;">NULL</span>;
        <span style="color: #00ffff;">goto</span> <span style="color: #7fffd4;">out</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><code>__kfree_skb</code></h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a id="kfree_skb" name="kfree_skb"></a>
</p>
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">__kfree_skb</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
  {
    skb_release_all(skb);
    kfree_skbmem(skb);
  }
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">skb_release_all</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
        dst_release(skb-&gt;dst);
<span style="color: #b0c4de;">#ifdef</span> CONFIG_XFRM
        secpath_put(skb-&gt;sp);
<span style="color: #b0c4de;">#endif</span>
        <span style="color: #00ffff;">if</span> (skb-&gt;destructor) {
                WARN_ON(in_irq());
                skb-&gt;destructor(skb);
        }
<span style="color: #b0c4de;">#if</span> <span style="color: #b0c4de;">defined</span>(CONFIG_NF_CONNTRACK) || <span style="color: #b0c4de;">defined</span>(CONFIG_NF_CONNTRACK_MODULE)
        nf_conntrack_put(skb-&gt;nfct);
        nf_conntrack_put_reasm(skb-&gt;nfct_reasm);
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#ifdef</span> CONFIG_BRIDGE_NETFILTER
        nf_bridge_put(skb-&gt;nf_bridge);
<span style="color: #b0c4de;">#endif</span>
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">XXX: IS this still necessary? - JHS </span><span style="color: #ff7f24;">*/</span>
<span style="color: #b0c4de;">#ifdef</span> CONFIG_NET_SCHED
        skb-&gt;tc_index = 0;
<span style="color: #b0c4de;">#ifdef</span> CONFIG_NET_CLS_ACT
        skb-&gt;tc_verd = 0;
<span style="color: #b0c4de;">#endif</span>
<span style="color: #b0c4de;">#endif</span>
        skb_release_data(skb);
}
<span style="color: #00ffff;">static</span> <span style="color: #98fb98;">void</span> <span style="color: #87cefa;">skb_release_data</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>)
{
        <span style="color: #00ffff;">if</span> (!skb-&gt;cloned ||
            !atomic_sub_return(skb-&gt;nohdr ? (1 &lt;&lt; SKB_DATAREF_SHIFT) + 1 : 1,
                               &amp;skb_shinfo(skb)-&gt;dataref)) {
                <span style="color: #00ffff;">if</span> (skb_shinfo(skb)-&gt;nr_frags) {
                        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span>;
                        <span style="color: #00ffff;">for</span> (i = 0; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++)
                                put_page(skb_shinfo(skb)-&gt;frags[i].page);
                }

                <span style="color: #00ffff;">if</span> (skb_shinfo(skb)-&gt;frag_list)
                        skb_drop_fraglist(skb);

                kfree(skb-&gt;head);
        }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><code>skb_realloc_headroom</code></h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">

<pre class="src src-c"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #87cefa;">skb_realloc_headroom</span>(<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb</span>, <span style="color: #98fb98;">unsigned</span> <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">headroom</span>)
{
        <span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">sk_buff</span> *<span style="color: #eedd82;">skb2</span>;
        <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">delta</span> = headroom - skb_headroom(skb);

        <span style="color: #00ffff;">if</span> (delta &lt;= 0)
                skb2 = pskb_copy(skb, GFP_ATOMIC);
        <span style="color: #00ffff;">else</span> {
                skb2 = skb_clone(skb, GFP_ATOMIC);
                <span style="color: #00ffff;">if</span> (skb2 &amp;&amp; pskb_expand_head(skb2, SKB_DATA_ALIGN(delta), 0,
                                             GFP_ATOMIC)) {
                        kfree_skb(skb2);
                        skb2 = <span style="color: #7fffd4;">NULL</span>;
                }
        }
        <span style="color: #00ffff;">return</span> skb2;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">cc</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-c"></pre>
</div>


<div class="org-src-container">

<pre class="src src-sh"></pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shi Shougang</p>
<p class="date">Created: 2014-11-07 Fri 23:23</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
