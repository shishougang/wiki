#+SETUPFILE: ~/.emacs.d/src/org-templates/level-2.org
#+TITLE: C++11 multithreading programming
#+OPTIONS: num:nil H:2

* Overview
上一篇[[http://dreamrunner.org/blog/2014/08/07/C-multithreading-programming/][浅谈C++ Multithreading Programming]]主要介绍时下规范好的C++使用
Pthread库和Boost Thread库实现C++多线程编程.这里主要谈谈正在规范的C++11
引入的Thread库和Atomic库,终于自带的C++库能支持高效并可移植的
Multithreading编程.分为2篇,这里先谈谈C++11的[[http://en.cppreference.com/w/cpp/thread][Thread的库]], 后一篇谈谈
C++11的[[http://en.cppreference.com/w/cpp/atomic][Atomic操作的库]].

[[https://en.wikipedia.org/wiki/C++11][C++11]](之前被成为C++0x)是编程语言C++最新版本的标准.它由 [[https://en.wikipedia.org/wiki/International_Organization_for_Standardization][ISO ]]在2011年8月
12日被批准替代[[https://en.wikipedia.org/wiki/C%2B%2B03][C++03]]. C++11标准正在规范中,从[[https://isocpp.org/std/the-standard][ISO页面]] 可以知道如何获得进
行中的草稿:
+ [[https://isocpp.org/files/papers/N3690.pdf][下载最新进行的pdf版草稿(N3690)]]
+ [[https://github.com/cplusplus/draft][从Github获取草稿的源文件]]

所以本文:
+ 标准内容主要参考如上的N3690版本的C++11标准.
+ 使用的编译器是GCC4.8,[[https://gcc.gnu.org/gcc-4.8/cxx0x_status.html][关于GCC4.8支持C+11的情况]].
+ 源代码之类主要参考[[http://www.cplusplus.com/reference/multithreading/][cplusplus]] 和 [[http://en.cppreference.com/w/][cppreference]].

更多有关C++参考最后的[[reference][其他资料]].

* Compile
GCC编译支持C++11,使用编译选项 =-std=c++11= 或 =-std=gnu++11=, 前者关闭
GNU扩张支持.并加上 =-pthread= 选项.

#+begin_src sh
g++ program.o -o program -std=c++11 -pthread
#+end_src

如果漏掉 =-phtread= 选项,编译能通过,当运行出现如下错误:
#+begin_src sh
terminate called after throwing an instance of 'std::system_error'
  what():  Enable multithreading to use std::thread: Operation not permitted
#+end_src

* Threads
** =<thread>= 概要
头文件是 =<thread>=, 分为两部分: =thread= 类和在namespace
=this_thread= 用来管理当前thread的函数.具体见之后的[[thread_header][Header <thread> synopsis]].

** =thread::id= 类
=thread::id= 类型的对象为每个执行的线程提供唯一的标识,并为所有并不表示
线程执行(默认构造的线程对象)的所有线程对象提供一个唯一的值.

=thread::id= 类没有特别的东西,主要提供方便比较或打印等运算符重载.
#+begin_src c++
  namespace std {
  class thread::id {
   public:
    id() noexcept;
  };
  bool operator==(thread::id x, thread::id y) noexcept;
  bool operator!=(thread::id x, thread::id y) noexcept;
  bool operator<(thread::id x, thread::id y) noexcept;
  bool operator<=(thread::id x, thread::id y) noexcept;
  bool operator>(thread::id x, thread::id y) noexcept;
  bool operator>=(thread::id x, thread::id y) noexcept;
  template<class charT, class traits>
  basic_ostream<charT, traits>&
  operator<< (basic_ostream<charT, traits>& out, thread::id id);
  // Hash support
  template <class T> struct hash;
  template <typename T> <> struct hash<thread::id>;
  }
#+end_src
** =thread= 类
#+begin_src c++
  namespace std {
  class thread {
   public:
    // types:
    class id;
    typedef implementation-defined native_handle_type; // See 30.2.3
    // construct/copy/destroy:
    thread() noexcept;
    template <class F, class ...Args> explicit thread(F&& f, Args&&... args);
    ~thread();
    thread(const thread&) = delete;
    thread(thread&&) noexcept;
    thread& operator=(const thread&) = delete;
    thread& operator=(thread&&) noexcept;
    // members:
    void swap(thread&) noexcept;
    bool joinable() const noexcept;
    void join();
    void detach();
    id get_id() const noexcept;
    native_handle_type native_handle(); // See 30.2.3
    // static members:
    static unsigned hardware_concurrency() noexcept;
  };
  }
#+end_src

** Constructs a thread object
从如上的 =thread= 类知道, 构造thread对象:
1. 默认构造
   构造一个线程对象,但并不代表任何执行线程.
2. 移动构造
   从其他线程构造一个thread对象,并设置其他线程为默认构造状态.
3. 初始化构造
   创建一个新的thread对象并把它与执行线程相关联.复制/移动所有参数
   =args..= 到thread可访问的内存通过如下函数:
#+begin_src c++
template <class T>
typename decay<T>::type decay_copy(T&& v) {
    return std::forward<T>(v);
}
#+end_src
   求值和复制/移动参数过程丢出的任何exceptions仅在当前线程丢出,不在新
   线程中.
4. 复制构造
   复制构造被删除.线程不可被复制.

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <utility>
#include <thread>
#include <functional>

using std::cout;
using std::endl;

void Thread1Fun(int n) {
  for (int i = 0; i < n; ++i) {
    cout << "Thread 1 executing" << endl;
  }
}

void Thread2Fun(const int& n) {
  for (int i = 0; i < n; ++i) {
    std::cout << "Thread 2 executing\n";
  }
}

int main() {
  const int kLoops = 5;
  std::thread t1;  // t1 is not a thread
  std::thread t2(Thread1Fun, kLoops + 1);  // pass by value
  std::thread t3(Thread2Fun, std::ref(kLoops));  // pass by reference
  std::thread t4(std::move(t3));
  // t4 is now running f2(). t3 is no longer a thread
  t2.join();
  t4.join();
  return 0;
}
#+end_src
** joinable
用来检查一个线程对象是否是正在执行的线程.若是,返回 =true=. 所以默认构
造thread对象是不可joinable.

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>
#include <chrono>
using std::cout;
using std::endl;

void ThreadFun() {
  std::this_thread::sleep_for(std::chrono::seconds(1));
}

int main() {
  std::thread t;
  cout << "default construct, joinable: " << t.joinable() << endl;

  t = std::thread(ThreadFun);
  cout << "initial construct, joinable: " << t.joinable() << endl;
  t.join();
  return 0;
}
#+end_src

结果:
#+begin_src sh
default construct, joinable: 0
initial construct, joinable: 1
#+end_src
** =get_id=
返回thread对象的 =std::thread::id= 值.
实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>
#include <chrono>

using std::cout;
using std::endl;

void ThreadFun() {
  std::this_thread::sleep_for(std::chrono::seconds(1));
}

int main() {
  std::thread t1(ThreadFun);
  std::thread::id id_t1 = t1.get_id();
  cout << "thread1's id: " << id_t1 << endl;
  t1.join();
  return 0;
}
#+end_src

** =native_handle=
这个函数是implementation-defined. 它允许提供底层实现细节的访问.但实际
使用它是non-portable. 

实例: 使用 =native_handle= 打开在POSIX系统上C++线程的实时调度.
#+begin_src c++
#include <pthread.h>
#include <thread>
#include <mutex>
#include <iostream>  // NOLINT
#include <chrono>
#include <cstring>
using std::cout;
using std::endl;

std::mutex iomutex;
void ThreadFun(int thread_id) {
  std::this_thread::sleep_for(std::chrono::seconds(1));
  sched_param sch;
  int policy;
  pthread_getschedparam(pthread_self(), &policy, &sch);
  std::lock_guard<std::mutex> lk(iomutex);
  cout << "Thread " << thread_id << " is executing at priority "
       << sch.sched_priority << endl;
}

int main() {
  std::thread t1(ThreadFun, 1), t2(ThreadFun, 2);
  sched_param sch;
  int policy;
  pthread_getschedparam(t1.native_handle(), &policy, &sch);
  sch.sched_priority = 20;
  if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &sch)) {
    cout << "Failed to setschedparam: " << std::strerror(errno) << endl;
  }
  t1.join();
  t2.join();
  return 0;
}
#+end_src

暂时GCC4.8不支持,结果:
#+begin_src sh
Failed to setschedparam: Operation not permitted
Thread 1 is executing at priority 0
Thread 2 is executing at priority 0
#+end_src
** =hardware_concurrency= (static)
返回硬件支持的thread数.这个值仅作为参考.如果这个值不可计算或没有很多的
定义,那么实现返回0.

#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>

int main() {
    unsigned int num = std::thread::hardware_concurrency();
    std::cout << num << " concurrent threads are supported." << std::endl;
}
#+end_src
** swap
=swap= 操作用来交换2个线程对象的底层句柄.有2种可选,thread类的成员函数
和在std下的全局函数.

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>
#include <chrono>

void Thread1Fun() {
  std::this_thread::sleep_for(std::chrono::seconds(1));
}

void Thread2Fun() {
  std::this_thread::sleep_for(std::chrono::seconds(1));
}

int main() {
    std::thread t1(Thread1Fun);
    std::thread t2(Thread2Fun);
    std::cout << "thread 1 id: " << t1.get_id() << std::endl;
    std::cout << "thread 2 id: " << t2.get_id() << std::endl;

    std::swap(t1, t2);
    std::cout << "after std::swap(t1, t2):" << std::endl;
    std::cout << "thread 1 id: " << t1.get_id() << std::endl;
    std::cout << "thread 2 id: " << t2.get_id() << std::endl;

    t1.swap(t2);
    std::cout << "after t1.swap(t2):" << std::endl;
    std::cout << "thread 1 id: " << t1.get_id() << std::endl;
    std::cout << "thread 2 id: " << t2.get_id() << std::endl;
    t1.join();
    t2.join();
    return 0;
}
#+end_src
** 管理当前thread的函数
在thread的头文件中,加了一个新的namespace =this_thread= 用来包含一些管
理操作当前thread的一些函数.

#+begin_src c++
void yield();
#+end_src
重新调度线程的执行,让其他线程运行.具体行为依赖于实现,与OS的调度机制有
关.

#+begin_src c++
std::thread::id get_id();
#+end_src
返回当前线程的 =thread::id= 类型的对象.

#+begin_src c++
template< class Rep, class Period >
void sleep_for( const std::chrono::duration<Rep, Period>& sleep_duration );
#+end_src
阻塞当前线程的执行至少相对时间 =sleep_duration=.

#+begin_src c++
template< class Clock, class Duration >
void sleep_until( const std::chrono::time_point<Clock,Duration>& sleep_time );
#+end_src
阻塞当前线程的执行直到绝对时间 =sleep_time= 到达.

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>
#include <chrono>
#include <mutex>
#include <atomic>
#include <ctime>
using std::cout;
using std::endl;
using std::chrono::system_clock;

std::atomic<bool> ready(false);

void Thread1Fun() {
  while (!ready) {
    std::this_thread::yield();
  }
  std::thread::id id = std::this_thread::get_id();
  cout << "thread " << id << "go to sleep" << endl;
  std::this_thread::sleep_for(std::chrono::seconds(1));
}

void Thread2Fun() {
  std::thread::id id = std::this_thread::get_id();
  cout << "thread " << id << "is running" << endl;
  ready = true;

  std::time_t tt = system_clock::to_time_t(system_clock::now());
  struct std::tm *ptm = std::localtime(&tt);
  ptm->tm_sec += 2;
  std::this_thread::sleep_until(system_clock::from_time_t(mktime(ptm)));
}

int main() {
  std::thread t1(Thread1Fun);
  std::thread t2(Thread2Fun);
  t1.join();
  t2.join();
  return 0;
}
#+end_src
* Mutual exclusion
** =<mutex>= 概要
头文件 =<mutex>= 分为: mutexes,locks和一些特殊函数. 
具体见之后的[[mutex_header][Header <mutex> synopsis]].

+ *Mutexes* 是[[lockable_types][lockable types]],用来对关键区域代码访问保护: [[mutex_class][=mutex=]],
  [[recursive_mutex_class][=recursive_mutex=]], [[timed_mutex_class][=timed_mutex=]], [[recursive_timed_mutex_class][=recursive_timed_mutex=]].
+ *Locks* 是用来管理mutex的对象,并对mutex的lifetime自我管
  理:[[lock_guard_class][=lock_guard=]], [[unique_lock_class][=unique_lock=]].
+ *Functions* 可以同时锁多个mutexes([[try_lock_func][=try_lock=]], [[lock_func][=lock=]]),并使某个函数只
  被调用一次([[call_once_func][=call_once=]]).

** Lockable types
<<lockable_types>>
[[./Files/lockable_type.png]]

C++11为mutex定义了不同类型的要求,如上图的层次,往右要求逐渐加强.

*** BasicLockable
BasicLockable 概念描述了最少特性类型,也就是满足(若m是BasicLockable类型
):
+ =m.lock()=
+ =m.unlock()=

所以所有mutex都满足BasicLockable类型: =mutex=, =recursive_mutex=,
=timed_mutex=, =recursive_timed_mutex=, =unique_lock=.
*** Lockable
Lockable 概念扩展了 BasicLockable 概念,并支持 =try_lock=. 

所以这些mutex满足Lockable类型: =mutex=, =recursive_mutex=,
=timed_mutex=, =recursive_timed_mutex=.
*** TimedLockable
TimedLockable 概念扩展了 Lockable 概念,并支持 =try_lock_for= 和
=try_lock_until=. 

所以这些mutex满足TimedLockable类型: =timed_mutex=,
=recursive_timed_mutex=.

** =mutex= 类
<<mutex_class>>
=mutex= 类提供了一个不可递归的排它锁.基本接口可以从如下类中参考.
#+begin_src c++
  namespace std {
  class mutex {
   public:
    constexpr mutex() noexcept;
    ~mutex();
    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;
    void lock();
    bool try_lock();
    void unlock();
    typedef implementation-defined native_handle_type; // See 30.2.3
    native_handle_type native_handle(); // See 30.2.3
  };
  }
#+end_src

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <vector>
#include <thread>
#include <mutex>
using std::cout;
using std::endl;
using std::vector;

int g_value = 0;
std::mutex count_mutex;

void Increase() {
  const int kLoops = 100;
  for (int i = 0; i < kLoops; ++i) {
    count_mutex.lock();
    g_value++;
    count_mutex.unlock();
  }
}

int main(int argc, char *argv[]) {
  const int kNumThreads = 5;
  vector<std::thread> threads;
  for (int i = 0; i < kNumThreads; ++i) {
    threads.push_back(std::thread(Increase));
  }
  for (auto &thread : threads) {
    thread.join();
  }
  cout << "value = " << g_value << endl;
  return 0;
}
#+end_src
** =recursive_mutex= 类
<<recursive_mutex_class>>可递归的排它锁.如下基本接口如 =mutex= 基本一
样.
#+begin_src c++
  namespace std {
  class recursive_mutex {
   public:
    recursive_mutex();
    ~recursive_mutex();
    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;
    void lock();
    bool try_lock() noexcept;
    void unlock();
    typedef implementation-defined native_handle_type; // See 30.2.3
    native_handle_type native_handle(); // See 30.2.3
  };
  }
#+end_src
** =timed_mutex= 类
<<timed_mutex_class>>
#+begin_src c++
  namespace std {
  class timed_mutex {
   public:
    timed_mutex();
    ~timed_mutex();
    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;
    void lock();
    bool try_lock();
    template <class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
    typedef implementation-defined native_handle_type; // See 30.2.3
    native_handle_type native_handle(); // See 30.2.3
  };
  }
#+end_src
** =recursive_timed_mutex= 类
<<recursive_timed_mutex_class>>

#+begin_src c++
  namespace std {
  class recursive_timed_mutex {
   public:
    recursive_timed_mutex();
    ~recursive_timed_mutex();
    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;
    void lock();
    bool try_lock() noexcept;
    template <class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
    typedef implementation-defined native_handle_type; // See 30.2.3
    native_handle_type native_handle(); // See 30.2.3
  };
  }
#+end_src
** Mutex Exception safety
基本保证: 当exception被以上 mutex 的成员函数抛出时,这些mutex对象保持有效
状态. 如果是 =lock= 操作被exception, lock不会被抛出exception的线程所拥
有.

抛出的是一个 =system_error= exception, 导致的基本情况是:
| exception 类型 | error情况                             | 描述                   |
|----------------+---------------------------------------+------------------------|
| =system_error= | =errc::resource_deadlock_would_occur= | deadlock被检测到       |
| =system_error= | =errc::operation_not_permitted=       | 线程没有权利做这个操作 |
| =system_error= | =errc::device_or_resource_busy=       | native handle已经被锁  |

** =lock_guard= 类
<<lock_guard_class>>

之前的mutex必须写明lock和unlock调用,如果在lock和unlock之间产生
exception,那么必须在exception处理中不能忘记处理unlock.当只是在一个关键区域
内需要mutex保护,使用这样的mutex既不方便也容易忘记unlock而造成死锁.

引入对之前的mutex的封装后的 =lock_guard= 和 =unique_lock= ,提供易用性
的 [[http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization][RAII-style]] 机制来获取锁在一段区域内.

lock guard 是一个用来管理一个 mutex 对象,并保持锁住它的对象.

在构造时,mutex 对象被调用的线程锁住,然后在析构时,mutex 被解锁.它是最简
单的lock,并且作为自动作用范围直到它的作用区域结束时特别有用.通过这种方
法,它保证 mutex 对象得到解锁即使在exception被抛出时.

#+begin_src c++
  namespace std {
  template <class Mutex>
  class lock_guard {
   public:
    typedef Mutex mutex_type;
    explicit lock_guard(mutex_type& m);
    lock_guard(mutex_type& m, adopt_lock_t);
    ~lock_guard();
    lock_guard(lock_guard const&) = delete;
    lock_guard& operator=(lock_guard const&) = delete;
   private:
    mutex_type& pm; // exposition only
  };
  }
#+end_src

实例:
#+begin_src c++
#include <iostream>  // NOLINT
#include <thread>
#include <mutex>
#include <stdexcept>

std::mutex mtx;

void PrintEven(int x) {
  if (x % 2 == 0) {
    std::cout << x << " is even\n";
  } else {
    throw(std::logic_error("not even"));
  }
}

void PrintThreadEvenId(int id) {
  try {
    std::lock_guard<std::mutex> lck(mtx);
    PrintEven(id);
  } catch (std::logic_error&) {
    std::cout << "[exception caught]" << std::endl;
  }
}

int main() {
  std::thread threads[10];
  for (int i = 0; i < 10; ++i) {
    threads[i] = std::thread(PrintThreadEvenId, i+1);
  }
  for (auto& th : threads) {
    th.join();
  }
  return 0;
}
#+end_src
** =unique_lock= 类
<<unique_lock_class>>

=unique_lock= 与上面的 =lock_guard= 基本差不多,同样是 [[http://en.wikipedia.com/wiki/Resource_Acquisition_Is_Initialization][RAII-style]] 机制
来获取锁在一段区域内的对象.

但 =lock_guard= 非常简单,只提供构造自动拥有锁和析构释放锁,如果需要一些
其他的操作,那么就需要更复杂和接口更多的类来处理, =lock_guard= 能满足如
此要求. 它类基本接口如下.

*** class
#+begin_src c++
  namespace std {
  template <class Mutex>
  class unique_lock {
   public:
    typedef Mutex mutex_type;
    // 30.4.2.2.1, construct/copy/destroy:
    unique_lock() noexcept;
    explicit unique_lock(mutex_type& m);
    unique_lock(mutex_type& m, defer_lock_t) noexcept;
    unique_lock(mutex_type& m, try_to_lock_t);
    unique_lock(mutex_type& m, adopt_lock_t);
    template <class Clock, class Duration>
    unique_lock(mutex_type& m, const chrono::time_point<Clock, Duration>& abs_time);
    template <class Rep, class Period>
    unique_lock(mutex_type& m, const chrono::duration<Rep, Period>& rel_time);
    ~unique_lock();
    unique_lock(unique_lock const&) = delete;
    unique_lock& operator=(unique_lock const&) = delete;
    unique_lock(unique_lock&& u) noexcept;
    unique_lock& operator=(unique_lock&& u) noexcept;
    // 30.4.2.2.2, locking:
    void lock();
    bool try_lock();
    template <class Rep, class Period>
    bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);
    template <class Clock, class Duration>
    bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);
    void unlock();
    // 30.4.2.2.3, modifiers:
    void swap(unique_lock& u) noexcept;
    mutex_type *release() noexcept;
    // 30.4.2.2.4, observers:
    bool owns_lock() const noexcept;
    explicit operator bool () const noexcept;
    mutex_type* mutex() const noexcept;
   private:
    mutex_type *pm; // exposition only
    bool owns; // exposition only
  };
  template <class Mutex>
  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;
  }
#+end_src
*** lock type
在[[mutex_header][mutex header概要]]中可以看到构造不同 =unique_lock= 对象传入不同的类型:

#+begin_src c++
struct defer_lock_t { };
struct try_to_lock_t { };
struct adopt_lock_t { };
constexpr std::defer_lock_t defer_lock = std::defer_lock_t();
constexpr std::try_to_lock_t try_to_lock = std::try_to_lock_t();
constexpr std::adopt_lock_t adopt_lock = std::adopt_lock_t();
#+end_src

*** 实例
#+begin_src c++
#include <iostream>  // NOLINT
#include <mutex>
#include <thread>
#include <chrono>
using std::cout;
using std::endl;

struct Box {
  explicit Box(int num) : num_things{num} {}
  int num_things;
  std::mutex m;
};

void Transfer(Box *from, Box *to, int num) {
  // don't actually take the locks yet
  std::unique_lock<std::mutex> lock1(from->m, std::defer_lock);
  std::unique_lock<std::mutex> lock2(to->m, std::defer_lock);
  // lock both unique_locks without deadlock
  std::lock(lock1, lock2);
  from->num_things -= num;
  to->num_things += num;
  // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors
}

int main() {
  Box acc1(100);
  Box acc2(50);
  cout << "acc1 num = " << acc1.num_things <<
      " ,acc2 num = " << acc2.num_things << endl;
  std::thread t1(Transfer, &acc1, &acc2, 10);
  std::thread t2(Transfer, &acc2, &acc1, 5);
  t1.join();
  t2.join();
  cout << "after transfer: " << "acc1 num = " << acc1.num_things <<
      " ,acc2 num = " << acc2.num_things << endl;
  return 0;
}
#+end_src
** =lock_guard= VS =unique_lock=

+ lock multiple:
  http://stackoverflow.com/questions/17113619/whats-the-best-way-to-lock-multiple-stdmutexes/17113678#17113678

 I think it's less a question of efficiency than of functionality. If
  std::lock_guard is enough for your case A, then you should use it.
  Not only it avoids unnecessary overhead but also shows intent to the
  reader that you will never unlock this guard

lock_guard and unique_lock are pretty much the same thing; lock_guard
is a restricted version with a limited interface.


A lock_guard always holds a lock from its construction to its
destruction. A unique_lock can be created without immediately locking,
can unlock at any point in its existence, and can transfer ownership
of the lock from one instance to another.


So you always use lock_guard, unless you need the capabilities of
unique_lock. A condition_variable needs a unique_lock.
** =try_lock= 和 =lock=
<<try_lock_func>>

<<lock_func>>
** =call_once=
<<call_once_func>>
* Condition variables
** =<condition_variable>= 概要
#+begin_src c++
  namespace std {
  class condition_variable;
  class condition_variable_any;
  void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
  enum class cv_status { no_timeout, timeout };
  }
#+end_src
** =condition_variable= 类
#+begin_src c++
  namespace std {
  class condition_variable {
   public:
    condition_variable();
    ~condition_variable();
    condition_variable(const condition_variable&) = delete;
    condition_variable& operator=(const condition_variable&) = delete;
    void notify_one() noexcept;
    void notify_all() noexcept;
    void wait(unique_lock<mutex>& lock);
    template <class Predicate>
    void wait(unique_lock<mutex>& lock, Predicate pred);
    template <class Clock, class Duration>
    cv_status wait_until(unique_lock<mutex>& lock,
                         const chrono::time_point<Clock, Duration>& abs_time);
    template <class Clock, class Duration, class Predicate>
    bool wait_until(unique_lock<mutex>& lock,
                    const chrono::time_point<Clock, Duration>& abs_time,
                    Predicate pred);
    template <class Rep, class Period>
    cv_status wait_for(unique_lock<mutex>& lock,
                       const chrono::duration<Rep, Period>& rel_time);
    template <class Rep, class Period, class Predicate>
    bool wait_for(unique_lock<mutex>& lock,
                  const chrono::duration<Rep, Period>& rel_time,
                  Predicate pred);
    typedef implementation-defined native_handle_type; // See 30.2.3
    native_handle_type native_handle(); // See 30.2.3
  };
  }
#+end_src
** =condition_variable_any= 类
#+begin_src c++
  namespace std {
  class condition_variable_any {
   public:
    condition_variable_any();
    ~condition_variable_any();
    condition_variable_any(const condition_variable_any&) = delete;
    condition_variable_any& operator=(const condition_variable_any&) = delete;
    void notify_one() noexcept;
    void notify_all() noexcept;
    template <class Lock>
    void wait(Lock& lock);
    template <class Lock, class Predicate>
    void wait(Lock& lock, Predicate pred);
    template <class Lock, class Clock, class Duration>
    cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
    template <class Lock, class Clock, class Duration, class Predicate>
    bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time,
                    Predicate pred);
    template <class Lock, class Rep, class Period>
    cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
    template <class Lock, class Rep, class Period, class Predicate>
    bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time,
                  Predicate pred);
  };
  }
#+end_src
** =condition_variable= vs =condition_variable_any=

std::condition_variable is more specialized, and therefore can be more
efficient when you don't need the flexibility of
std::condition_variable_any.


From N3290 §30.5[thread.condition]/1

Class condition_variable provides a condition variable that can only
wait on an object of type unique_lock<mutex>, allowing maximum
efficiency on some platforms. Class condition_variable_any provides a
general condition variable that can wait on objects of user-supplied
lock types.


When using std::condition_variable_any, there is potential for
additional costs in terms of size, performance or operating system
resources, because it is more general than std::condition_variable.
std::condition_variable works with std::unique_lock<std::mutex>, while
std::condition_variable_any can operate on any objects that have lock
and unlock member functions.
* Futures
** =<future>= 概要

<<future_header>>

** =future_error= 类
#+begin_src c++
  namespace std {
  class future_error : public logic_error {
   public:
    future_error(error_code ec); // exposition only
    const error_code& code() const noexcept;
    const char* what() const noexcept;
  };
  }
  const error_code& code() const noexcept;
#+end_src
** =template promise= 类
#+begin_src c++
  namespace std {
  template <class R>
  class promise {
   public:
    promise();
    template <class Allocator>
    promise(allocator_arg_t, const Allocator& a);
    promise(promise&& rhs) noexcept;
    promise(const promise& rhs) = delete;
    ~promise();
    // assignment
    promise& operator=(promise&& rhs) noexcept;
    promise& operator=(const promise& rhs) = delete;
    void swap(promise& other) noexcept;
    // retrieving the result
    future<R> get_future();
    // setting the result
    void set_value(see below );
    void set_exception(exception_ptr p);
    // setting the result with deferred notification
    void set_value_at_thread_exit(const R& r);
    void set_value_at_thread_exit(see below );
    void set_exception_at_thread_exit(exception_ptr p);
  };
  template <class R>
  void swap(promise<R>& x, promise<R>& y) noexcept;
  template <class R, class Alloc>
  struct uses_allocator<promise<R>, Alloc>;
  }
#+end_src

** =template future= 类
#+begin_src c++
  namespace std {
  template <class R>
  class future {
   public:
    future() noexcept;
    future(future &&) noexcept;
    future(const future& rhs) = delete;
    ~future();
    future& operator=(const future& rhs) = delete;
    future& operator=(future&&) noexcept;
    shared_future<R> share();
    // retrieving the value
    see below get();
    // functions to check state
    bool valid() const noexcept;
    void wait() const;
    template <class Rep, class Period>
    future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
    template <class Clock, class Duration>
    future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
  };
  }
#+end_src
** =template shared_future= 类
#+begin_src c++
  namespace std {
  template <class R>
  class shared_future {
   public:
    shared_future() noexcept;
    shared_future(const shared_future& rhs);
    shared_future(future<R>&&) noexcept;
    shared_future(shared_future&& rhs) noexcept;
    ~shared_future();
    shared_future& operator=(const shared_future& rhs);
    shared_future& operator=(shared_future&& rhs) noexcept;
    // retrieving the value
    see below get() const;
    // functions to check state
    bool valid() const noexcept;
    void wait() const;
    template <class Rep, class Period>
    future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;
    template <class Clock, class Duration>
    future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time) const;
  };
  }
#+end_src
** =template async= 函数
#+begin_src c++
template <class F, class... Args>
future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
async(F&& f, Args&&... args);
template <class F, class... Args>
future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
async(launch policy, F&& f, Args&&... args);
#+end_src
** =template packaged_task= 函数
#+begin_src c++
  namespace std {
  template<class> class packaged_task; // undefined
  template<class R, class... ArgTypes>
  class packaged_task<R(ArgTypes...)> {
   public:
    // construction and destruction
    packaged_task() noexcept;
    template <class F>
    explicit packaged_task(F&& f);
    template <class F, class Allocator>
    explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);
    ~packaged_task();
    // no copy
    packaged_task(const packaged_task&) = delete;
    packaged_task& operator=(const packaged_task&) = delete;
    // move support
    packaged_task(packaged_task&& rhs) noexcept;
    packaged_task& operator=(packaged_task&& rhs) noexcept;
    void swap(packaged_task& other) noexcept;
    bool valid() const noexcept;
    // result retrieval
    future<R> get_future();
    // execution
    void operator()(ArgTypes... );
    void make_ready_at_thread_exit(ArgTypes...);
    void reset();
  };
  template <class R, class... ArgTypes>
  void swap(packaged_task<R(ArgTypes...)>& x, packaged_task<R(ArgTypes...)>& y) noexcept;
  template <class R, class Alloc>
  struct uses_allocator<packaged_task<R>, Alloc>;
  }
#+end_src
* Header synopsis
** =<thread>=
<<thread_header>>
基本概要如下(§30.3 [thread.threads] of N3690):
#+begin_src c++
// Header <thread> synopsis
namespace std {
class thread;
void swap(thread& x, thread& y) noexcept;
namespace this_thread {
thread::id get_id() noexcept;
void yield() noexcept;
template <class Clock, class Duration>
void sleep_until(const chrono::time_point<Clock, Duration>& abs_time);
template <class Rep, class Period>
void sleep_for(const chrono::duration<Rep, Period>& rel_time);
}
}
#+end_src
** =<mutex>= 
<<mutex_header>>
#+begin_src c++
  // Header <mutex> synopsis
  namespace std {
  class mutex;
  class recursive_mutex;
  class timed_mutex;
  class recursive_timed_mutex;
  struct defer_lock_t { };
  struct try_to_lock_t { };
  struct adopt_lock_t { };
  constexpr defer_lock_t defer_lock { };
  constexpr try_to_lock_t try_to_lock { };
  constexpr adopt_lock_t adopt_lock { };
  template <class Mutex> class lock_guard;
  template <class Mutex> class unique_lock;
  template <class Mutex>
  void swap(unique_lock<Mutex>& x, unique_lock<Mutex>& y) noexcept;
  template <class L1, class L2, class... L3> int try_lock(L1&, L2&, L3&...);
  template <class L1, class L2, class... L3> void lock(L1&, L2&, L3&...);
  struct once_flag {
    constexpr once_flag() noexcept;
    once_flag(const once_flag&) = delete;
    once_flag& operator=(const once_flag&) = delete;
  };
  template<class Callable, class ...Args>
  void call_once(once_flag& flag, Callable func, Args&&... args);
  }
#+end_src
** =<future>= 
<<future_header>>
#+begin_src c++
namespace std {
enum class future_errc {
broken_promise = implementation-defined ,
future_already_retrieved = implementation-defined ,
promise_already_satisfied = implementation-defined ,
no_state = implementation-defined
};
enum class launch : unspecified {
async = unspecified ,
deferred = unspecified ,
implementation-defined
};
enum class future_status {
ready,
timeout,
deferred
};
template <> struct is_error_code_enum<future_errc> : public true_type { };
error_code make_error_code(future_errc e) noexcept;
error_condition make_error_condition(future_errc e) noexcept;
const error_category& future_category() noexcept;
class future_error;
template <class R> class promise;
template <class R> class promise<R&>;
template <> class promise<void>;
template <class R>
void swap(promise<R>& x, promise<R>& y) noexcept;
template <class R, class Alloc>
struct uses_allocator<promise<R>, Alloc>;
template <class R> class future;
template <class R> class future<R&>;
template <> class future<void>;
template <class R> class shared_future;
template <class R> class shared_future<R&>;
template <> class shared_future<void>;
template <class> class packaged_task; // undefined
template <class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)>;
template <class R>
void swap(packaged_task<R(ArgTypes...)>&, packaged_task<R(ArgTypes...)>&) noexcept;
template <class R, class Alloc>
struct uses_allocator<packaged_task<R>, Alloc>;
template <class F, class... Args>
future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
async(F&& f, Args&&... args);
template <class F, class... Args>
future<typename result_of<typename decay<F>::type(typename decay<Args>::type...)>::type>
async(launch policy, F&& f, Args&&... args);
}
#+end_src
* 其他资料
<<reference>>
** Books
+ Scott Meyers的[[http://www.artima.com/shop/overview_of_the_new_cpp][ Overview of the New C++ (C++11/14)]]
** Online resources
+ Scott Meyers的[[http://www.aristeia.com/C++11/C++11FeatureAvailability.htm][Summary of C++11 Feature Availability in gcc and MSVC]]
+ [[http://en.cppreference.com/w/cpp][C++11 on cppreference]]
+ [[http://www.cplusplus.com/reference/multithreading/][C++11 on cplusplus]]
+ Bjarne Stroustrup的[[http://www.stroustrup.com/C++11FAQ.html][C++11 FAQ]]
+ [[https://en.wikipedia.org/wiki/C++11][C++11 Wiki]]
+ [[https://github.com/cplusplus/draft][C++ standards drafts on GitHub]]
* cc
实例:
#+begin_src c++

#+end_src

